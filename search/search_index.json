{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to HERMES","text":"<p>We are working hard to deliver high-quality documentation to you as soon as possible.</p> <p>Stay tuned!</p> <p>In the meantime, check out our socials and GitHub</p>"},{"location":"api/","title":"Reference","text":"<p>HERMES is a namespace framework, which allows easy installation of support for additional Nodes as pip packages that become available under the same namespace <code>hermes.&lt;new_package&gt;</code>. Specifying</p> <p>Adding a new <code>Node</code></p> <p>Integrating user-defined new Node into the rest of the framework is trivial. Wrap the custom logic, including non-HERMES code, in the provided template.</p> <p>HERMES follows the PEP 8 public/private method naming convention.</p> <p>Regular users</p> <p>Only use the available public methods, without leading underscores <code>_&lt;method_name&gt;()</code>. The private methods are shown for informative purposes only. Extending the system to new sensors is easy with ready-made templates and provided decoupling from the low-level controls.</p> <p>Developers</p> <p>When extending the system functionality, understanding of low-level methods could become useful. Private methods also influence performance and could be the first place to look for enhancements.</p>"},{"location":"api/base/","title":"Overview","text":"<p>TODO: details of the <code>base</code> module structure and function.</p> <p><code>state_interface</code> - base interface for FSM creation.</p>"},{"location":"api/base/#hermes.base.state_interface","title":"state_interface","text":"<p>Classes:</p> Name Description <code>StateInterface</code> <p>Basic FSM interface for Broker, Node, Storage.</p>"},{"location":"api/base/#hermes.base.state_interface.StateInterface","title":"StateInterface","text":"<p>               Bases: <code>ABC</code></p> <p>Basic FSM interface for Broker, Node, Storage.</p> <p>Methods:</p> Name Description <code>is_continue</code> <p>Check if to stay in the current state.</p> <code>kill</code> <p>Trigger to enter the KILL state from any other.</p> <code>run</code> <p>Run the logic of the currently selected state.</p>"},{"location":"api/base/#hermes.base.state_interface.StateInterface.is_continue","title":"is_continue  <code>abstractmethod</code>","text":"<pre><code>is_continue() -&gt; bool\n</code></pre> <p>Check if to stay in the current state.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Whether to stay in the same state.</p>"},{"location":"api/base/#hermes.base.state_interface.StateInterface.kill","title":"kill  <code>abstractmethod</code>","text":"<pre><code>kill() -&gt; None\n</code></pre> <p>Trigger to enter the KILL state from any other.</p>"},{"location":"api/base/#hermes.base.state_interface.StateInterface.run","title":"run  <code>abstractmethod</code>","text":"<pre><code>run() -&gt; None\n</code></pre> <p>Run the logic of the currently selected state.</p>"},{"location":"api/base/broker/","title":"hermes.base.broker","text":"<p>The module is responsible for managing the lifecycle of all locally-hosted Nodes.  It is also the program's entrypoint to the continuous sensing and processing.</p> <p><code>broker_interface</code> - base interface for Broker function.</p> <p><code>broker</code> - concrete FSM-based Broker with distributed LAN connectivity.</p> <p><code>broker_states</code> - FSM states of the Broker.</p>"},{"location":"api/base/broker/#hermes.base.broker.broker_interface","title":"broker_interface","text":"<p>Classes:</p> Name Description <code>BrokerInterface</code> <p>Interface for the Broker component.</p>"},{"location":"api/base/broker/#hermes.base.broker.broker_interface.BrokerInterface","title":"BrokerInterface","text":"<p>               Bases: <code>ABC</code></p> <p>Interface for the Broker component.</p>"},{"location":"api/base/broker/#hermes.base.broker.broker_interface.BrokerInterface._activate_pubsub_poller","title":"_activate_pubsub_poller  <code>abstractmethod</code>","text":"<pre><code>_activate_pubsub_poller() -&gt; None\n</code></pre> <p>Register PUB-SUB sockets on both Broker interfaces for polling.</p>"},{"location":"api/base/broker/#hermes.base.broker.broker_interface.BrokerInterface._add_brokered_node","title":"_add_brokered_node  <code>abstractmethod</code>","text":"<pre><code>_add_brokered_node(topic: str) -&gt; None\n</code></pre> <p>Add a unique local Node identifier joining the exchange via the Broker.</p> <p>Noes uniquely self-identify by the data topic they produce.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>Unique identifier of the Node.</p> required"},{"location":"api/base/broker/#hermes.base.broker.broker_interface.BrokerInterface._add_brokered_node(topic)","title":"<code>topic</code>","text":""},{"location":"api/base/broker/#hermes.base.broker.broker_interface.BrokerInterface._broker_packets","title":"_broker_packets  <code>abstractmethod</code>","text":"<pre><code>_broker_packets(poll_res: ZMQResult, on_data_received: Callable[[list[bytes]], None] = lambda _: None, on_subscription_changed: Callable[[list[bytes]], None] = lambda _: None) -&gt; None\n</code></pre> <p>Move packets between publishers and subscribers, local and remote.</p> <p>Parameters:</p> Name Type Description Default <code>ZMQResult</code> <p>New ZeroMQ packets from PUB or SUB interfaces.</p> required <code>_type_</code> <p>Callback for data packets. Defaults to lambda_:None.</p> <code>lambda _: None</code> <code>_type_</code> <p>Callback for subscription status packets. Defaults to lambda_:None.</p> <code>lambda _: None</code>"},{"location":"api/base/broker/#hermes.base.broker.broker_interface.BrokerInterface._broker_packets(poll_res)","title":"<code>poll_res</code>","text":""},{"location":"api/base/broker/#hermes.base.broker.broker_interface.BrokerInterface._broker_packets(on_data_received)","title":"<code>on_data_received</code>","text":""},{"location":"api/base/broker/#hermes.base.broker.broker_interface.BrokerInterface._broker_packets(on_subscription_changed)","title":"<code>on_subscription_changed</code>","text":""},{"location":"api/base/broker/#hermes.base.broker.broker_interface.BrokerInterface._check_for_kill","title":"_check_for_kill  <code>abstractmethod</code>","text":"<pre><code>_check_for_kill(poll_res: ZMQResult) -&gt; bool\n</code></pre> <p>Check if received packets contain a kill signal from a downstream Broker.</p> <p>Parameters:</p> Name Type Description Default <code>ZMQResult</code> <p>New ZeroMQ packets from PUB or SUB interfaces.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Whether a KILL message is contained in messages.</p>"},{"location":"api/base/broker/#hermes.base.broker.broker_interface.BrokerInterface._check_for_kill(poll_res)","title":"<code>poll_res</code>","text":""},{"location":"api/base/broker/#hermes.base.broker.broker_interface.BrokerInterface._deactivate_pubsub_poller","title":"_deactivate_pubsub_poller  <code>abstractmethod</code>","text":"<pre><code>_deactivate_pubsub_poller() -&gt; None\n</code></pre> <p>Stop listening on the PUB or SUB interfaces for new data packets.</p>"},{"location":"api/base/broker/#hermes.base.broker.broker_interface.BrokerInterface._get_brokered_nodes","title":"_get_brokered_nodes  <code>abstractmethod</code>","text":"<pre><code>_get_brokered_nodes() -&gt; set[str]\n</code></pre> <p>Get the set of unique local Node identifiers that Broker manages.</p> <p>Returns:</p> Type Description <code>set[str]</code> <p>set[str]: Set of unique identifiers.</p>"},{"location":"api/base/broker/#hermes.base.broker.broker_interface.BrokerInterface._get_duration","title":"_get_duration  <code>abstractmethod</code>","text":"<pre><code>_get_duration() -&gt; float | None\n</code></pre> <p>Get the user-requested active duration of the capture/streaming. </p> <p>Returns:</p> Type Description <code>float | None</code> <p>float | None: Time in seconds, if specified on Broker launch.</p>"},{"location":"api/base/broker/#hermes.base.broker.broker_interface.BrokerInterface._get_host_ip","title":"_get_host_ip  <code>abstractmethod</code>","text":"<pre><code>_get_host_ip() -&gt; str\n</code></pre> <p>Get the Broker's host machine LAN IP address.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Host's IP address.</p>"},{"location":"api/base/broker/#hermes.base.broker.broker_interface.BrokerInterface._get_is_master_broker","title":"_get_is_master_broker  <code>abstractmethod</code>","text":"<pre><code>_get_is_master_broker() -&gt; bool\n</code></pre> <p>Get the master status of this Broker in a distributed setup.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Whether this Broker is the master.</p>"},{"location":"api/base/broker/#hermes.base.broker.broker_interface.BrokerInterface._get_node_addresses","title":"_get_node_addresses  <code>abstractmethod</code>","text":"<pre><code>_get_node_addresses() -&gt; dict[str, bytes]\n</code></pre> <p>Bulk-get socket identifiers and unique Node identifiers for Broker's local Nodes.</p> <p>Returns:</p> Type Description <code>dict[str, bytes]</code> <p>dict[str, bytes]: Mapping of unique Node topics and their ZeroMQ socket identifiers.</p>"},{"location":"api/base/broker/#hermes.base.broker.broker_interface.BrokerInterface._get_num_backends","title":"_get_num_backends  <code>abstractmethod</code>","text":"<pre><code>_get_num_backends() -&gt; int\n</code></pre> <p>Get the number of XSUB interfaces to remote hosts, the Broker listens to.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of sockets.</p>"},{"location":"api/base/broker/#hermes.base.broker.broker_interface.BrokerInterface._get_num_frontends","title":"_get_num_frontends  <code>abstractmethod</code>","text":"<pre><code>_get_num_frontends() -&gt; int\n</code></pre> <p>Get the number of XPUB interfaces to remote hosts, listening to the Broker.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of sockets.</p>"},{"location":"api/base/broker/#hermes.base.broker.broker_interface.BrokerInterface._get_num_local_nodes","title":"_get_num_local_nodes  <code>abstractmethod</code>","text":"<pre><code>_get_num_local_nodes() -&gt; int\n</code></pre> <p>Get the number of Nodes hosted and managed by this Broker.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of locally attached Nodes.</p>"},{"location":"api/base/broker/#hermes.base.broker.broker_interface.BrokerInterface._get_poller","title":"_get_poller  <code>abstractmethod</code>","text":"<pre><code>_get_poller() -&gt; Poller\n</code></pre> <p>Get the ZeroMQ Poller object responsible for socket management.</p> <p>Returns:</p> Type Description <code>Poller</code> <p>zmq.Poller: ZeroMQ poller to (de)activate listening on an interface.</p>"},{"location":"api/base/broker/#hermes.base.broker.broker_interface.BrokerInterface._get_remote_broker_addresses","title":"_get_remote_broker_addresses  <code>abstractmethod</code>","text":"<pre><code>_get_remote_broker_addresses() -&gt; dict[str, bytes]\n</code></pre> <p>Bulk-get socket identifiers and IP addresses of remote Brokers.</p> <p>Returns:</p> Type Description <code>dict[str, bytes]</code> <p>dict[str, bytes]: Mapping of remote IPs and their ZeroMQ socket identifiers.</p>"},{"location":"api/base/broker/#hermes.base.broker.broker_interface.BrokerInterface._get_remote_pub_brokers","title":"_get_remote_pub_brokers  <code>abstractmethod</code>","text":"<pre><code>_get_remote_pub_brokers() -&gt; list[str]\n</code></pre> <p>Get the list of remote publishing Brokers' IPs. </p> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: List of IP addresses.</p>"},{"location":"api/base/broker/#hermes.base.broker.broker_interface.BrokerInterface._get_remote_sub_brokers","title":"_get_remote_sub_brokers  <code>abstractmethod</code>","text":"<pre><code>_get_remote_sub_brokers() -&gt; list[str]\n</code></pre> <p>Get the list of remote subscribing Brokers' IPs. </p> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: List of IP addresses.</p>"},{"location":"api/base/broker/#hermes.base.broker.broker_interface.BrokerInterface._get_start_time","title":"_get_start_time  <code>abstractmethod</code>","text":"<pre><code>_get_start_time() -&gt; float\n</code></pre> <p>Get the start time when the Broker set everything up and started streaming.</p> <p>Useful for measuring run time of the experiment, excluding the lengthy setup process.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Time in seconds since epoch.</p>"},{"location":"api/base/broker/#hermes.base.broker.broker_interface.BrokerInterface._get_sync_host_socket","title":"_get_sync_host_socket  <code>abstractmethod</code>","text":"<pre><code>_get_sync_host_socket() -&gt; SyncSocket\n</code></pre> <p>Get the reference to the RCV socket for syncing local Nodes.</p> <p>Returns:</p> Type Description <code>SyncSocket</code> <p>zmq.SyncSocket: ZeroMQ socket used to communicate SYNC process.</p>"},{"location":"api/base/broker/#hermes.base.broker.broker_interface.BrokerInterface._get_sync_remote_socket","title":"_get_sync_remote_socket  <code>abstractmethod</code>","text":"<pre><code>_get_sync_remote_socket() -&gt; SyncSocket\n</code></pre> <p>Get the reference to the RCV socket for syncing remote Brokers.</p> <p>Returns:</p> Type Description <code>SyncSocket</code> <p>zmq.SyncSocket: ZeroMQ socket used to communicate SYNC process.</p>"},{"location":"api/base/broker/#hermes.base.broker.broker_interface.BrokerInterface._log_source_tag","title":"_log_source_tag  <code>abstractmethod</code> <code>classmethod</code>","text":"<pre><code>_log_source_tag() -&gt; str\n</code></pre> <p>Read-only class property identifying the component.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Unique identifier.</p>"},{"location":"api/base/broker/#hermes.base.broker.broker_interface.BrokerInterface._poll","title":"_poll  <code>abstractmethod</code>","text":"<pre><code>_poll(timeout_ms: int) -&gt; ZMQResult\n</code></pre> <p>Block until any new packets are available on PUB or SUB Broker interfaces.</p> <p>Parameters:</p> Name Type Description Default <code>int</code> <p>Polling timeout duration to re-evaluate check for manual CLI termination.</p> required <p>Returns:</p> Name Type Description <code>ZMQResult</code> <code>ZMQResult</code> <p>New ZeroMQ packets from PUB or SUB interfaces.</p>"},{"location":"api/base/broker/#hermes.base.broker.broker_interface.BrokerInterface._poll(timeout_ms)","title":"<code>timeout_ms</code>","text":""},{"location":"api/base/broker/#hermes.base.broker.broker_interface.BrokerInterface._publish_kill","title":"_publish_kill  <code>abstractmethod</code>","text":"<pre><code>_publish_kill()\n</code></pre> <p>Send kill signals to upstream Brokers and local Nodes.</p>"},{"location":"api/base/broker/#hermes.base.broker.broker_interface.BrokerInterface._remove_brokered_node","title":"_remove_brokered_node  <code>abstractmethod</code>","text":"<pre><code>_remove_brokered_node(topic: str) -&gt; None\n</code></pre> <p>Remove the existing local Node identifier from the exchange via the Broker.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>Unique identifier of the Node.</p> required"},{"location":"api/base/broker/#hermes.base.broker.broker_interface.BrokerInterface._remove_brokered_node(topic)","title":"<code>topic</code>","text":""},{"location":"api/base/broker/#hermes.base.broker.broker_interface.BrokerInterface._set_node_addresses","title":"_set_node_addresses  <code>abstractmethod</code>","text":"<pre><code>_set_node_addresses(node_addresses: dict[str, bytes]) -&gt; None\n</code></pre> <p>Bulk-set socket identifiers and unique Node identifiers for Broker's local Nodes.</p> <p>Parameters:</p> Name Type Description Default <code>dict[str, bytes]</code> <p>Mapping of unique Node topics and their ZeroMQ socket identifiers.</p> required"},{"location":"api/base/broker/#hermes.base.broker.broker_interface.BrokerInterface._set_node_addresses(node_addresses)","title":"<code>node_addresses</code>","text":""},{"location":"api/base/broker/#hermes.base.broker.broker_interface.BrokerInterface._set_remote_broker_addresses","title":"_set_remote_broker_addresses  <code>abstractmethod</code>","text":"<pre><code>_set_remote_broker_addresses(remote_brokers: dict[str, bytes]) -&gt; None\n</code></pre> <p>Bulk-set socket identifiers and IP addresses of remote Brokers for this Broker.</p> <p>Parameters:</p> Name Type Description Default <code>dict[str, bytes]</code> <p>Mapping of remote IPs and their ZeroMQ socket identifiers.</p> required"},{"location":"api/base/broker/#hermes.base.broker.broker_interface.BrokerInterface._set_remote_broker_addresses(remote_brokers)","title":"<code>remote_brokers</code>","text":""},{"location":"api/base/broker/#hermes.base.broker.broker_interface.BrokerInterface._set_state","title":"_set_state  <code>abstractmethod</code>","text":"<pre><code>_set_state(state) -&gt; None\n</code></pre> <p>User defined logic for FSM state transition.</p> <p>Parameters:</p> Name Type Description Default <code>Any</code> <p>New state to transition to.</p> required"},{"location":"api/base/broker/#hermes.base.broker.broker_interface.BrokerInterface._set_state(state)","title":"<code>state</code>","text":""},{"location":"api/base/broker/#hermes.base.broker.broker_interface.BrokerInterface._start_local_nodes","title":"_start_local_nodes  <code>abstractmethod</code>","text":"<pre><code>_start_local_nodes() -&gt; None\n</code></pre> <p>Spawn specified locally hosted Nodes, each in a separate process.</p>"},{"location":"api/base/broker/#hermes.base.broker.broker","title":"broker","text":"<p>Classes:</p> Name Description <code>Broker</code> <p>Manager of the lifecycle of all connected local Nodes and data broker.</p>"},{"location":"api/base/broker/#hermes.base.broker.broker.Broker","title":"Broker","text":"<p>               Bases: <code>BrokerInterface</code></p> <p>Manager of the lifecycle of all connected local Nodes and data broker.</p> <p>Facilitates high-performance message exchange using ZeroMQ zero-copy  communication across distributed sensing and computing hosts. Passes data over sockets to external Brokers or over shared memory for local Nodes. </p> <p>Hosts control logic of interactive proxy/server.  Will launch/destroy/connect to Nodes on creation and ad-hoc. Will use a separate process for each streamer and consumer. Each Node connects only to its local Broker,   which then exposes its data to outside LAN subscribers.</p> <p>Uses fixed ports for communication under <code>zmq_utils.py</code>. Use of other ports is discouraged.</p> <p>Methods:</p> Name Description <code>__call__</code> <p>The main FSM loop of the Broker.</p> <code>__init__</code> <p>Constructor of the Broker main entrypoint.</p> <code>connect_to_remote_broker</code> <p>Connects to a known address and port of external LAN data broker.</p> <code>expose_to_remote_broker</code> <p>Exposes a known address and port to remote networked subscribers if configured.</p> <code>set_is_quit</code> <p>External asynchronous trigger to indicate termination to the Broker.</p> <code>subscribe_to_killsig</code> <p>Subscribes to external kill signal of another host as master.</p>"},{"location":"api/base/broker/#hermes.base.broker.broker.Broker.__call__","title":"__call__","text":"<pre><code>__call__(duration_s: float | None = None) -&gt; None\n</code></pre> <p>The main FSM loop of the Broker.</p> <p>Runs continuously until the user ends the experiment or after the specified duration. The duration start to count only after all Nodes established communication and synced.</p> <p>Parameters:</p> Name Type Description Default <code>float | None</code> <p>Duration of data capturing/streaming. Defaults to None.</p> <code>None</code>"},{"location":"api/base/broker/#hermes.base.broker.broker.Broker.__call__(duration_s)","title":"<code>duration_s</code>","text":""},{"location":"api/base/broker/#hermes.base.broker.broker.Broker.__init__","title":"__init__","text":"<pre><code>__init__(host_ip: str, node_specs: list[dict], port_backend: str = PORT_BACKEND, port_frontend: str = PORT_FRONTEND, port_sync_host: str = PORT_SYNC_HOST, port_sync_remote: str = PORT_SYNC_REMOTE, port_killsig: str = PORT_KILL, is_master_broker: bool = False) -&gt; None\n</code></pre> <p>Macro-defined ports are preferred for consistency in a distributed, multi-host setup. </p> <p>Uses hierarchical coordination of distributed host synchronization/setup. Each Broker first starts up and sync local Nodes. Then syncs with all expected remote hosts, until all are ready. After all are ready, master Broker communicates trigger signal to start streaming.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>Public LAN IP address of this host.</p> required <code>list[dict]</code> <p>List of to-be-created Node specification dictionaries.</p> required <code>str</code> <p>XSUB port of the Broker. Defaults to PORT_BACKEND.</p> <code>PORT_BACKEND</code> <code>str</code> <p>XPUB port of the Broker. Defaults to PORT_FRONTEND.</p> <code>PORT_FRONTEND</code> <code>str</code> <p>Port for SYNC socket to coordinate startup of local Nodes. Defaults to PORT_SYNC_HOST.</p> <code>PORT_SYNC_HOST</code> <code>str</code> <p>Port for SYNC socket to coordinate startup across remote hosts. Defaults to PORT_SYNC_REMOTE.</p> <code>PORT_SYNC_REMOTE</code> <code>str</code> <p>Port of the KILL signal this Broker announces from. Defaults to PORT_KILL.</p> <code>PORT_KILL</code> <code>bool</code> <p>Whether this Broker is the master in the distributed host setup. Defaults to False.</p> <code>False</code>"},{"location":"api/base/broker/#hermes.base.broker.broker.Broker.__init__(host_ip)","title":"<code>host_ip</code>","text":""},{"location":"api/base/broker/#hermes.base.broker.broker.Broker.__init__(node_specs)","title":"<code>node_specs</code>","text":""},{"location":"api/base/broker/#hermes.base.broker.broker.Broker.__init__(port_backend)","title":"<code>port_backend</code>","text":""},{"location":"api/base/broker/#hermes.base.broker.broker.Broker.__init__(port_frontend)","title":"<code>port_frontend</code>","text":""},{"location":"api/base/broker/#hermes.base.broker.broker.Broker.__init__(port_sync_host)","title":"<code>port_sync_host</code>","text":""},{"location":"api/base/broker/#hermes.base.broker.broker.Broker.__init__(port_sync_remote)","title":"<code>port_sync_remote</code>","text":""},{"location":"api/base/broker/#hermes.base.broker.broker.Broker.__init__(port_killsig)","title":"<code>port_killsig</code>","text":""},{"location":"api/base/broker/#hermes.base.broker.broker.Broker.__init__(is_master_broker)","title":"<code>is_master_broker</code>","text":""},{"location":"api/base/broker/#hermes.base.broker.broker.Broker._stop","title":"_stop","text":"<pre><code>_stop() -&gt; None\n</code></pre> <p>Gracefully exit after all local subprocesses terminate, and cleanup.</p>"},{"location":"api/base/broker/#hermes.base.broker.broker.Broker.connect_to_remote_broker","title":"connect_to_remote_broker","text":"<pre><code>connect_to_remote_broker(addr: str, port_pub: str = PORT_FRONTEND) -&gt; None\n</code></pre> <p>Connects to a known address and port of external LAN data broker.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>Remote host IP to connect to as a listener.</p> required <code>str</code> <p>Port number on which remote host publishes local Nodes' data. Defaults to PORT_FRONTEND.</p> <code>PORT_FRONTEND</code>"},{"location":"api/base/broker/#hermes.base.broker.broker.Broker.connect_to_remote_broker(addr)","title":"<code>addr</code>","text":""},{"location":"api/base/broker/#hermes.base.broker.broker.Broker.connect_to_remote_broker(port_pub)","title":"<code>port_pub</code>","text":""},{"location":"api/base/broker/#hermes.base.broker.broker.Broker.expose_to_remote_broker","title":"expose_to_remote_broker","text":"<pre><code>expose_to_remote_broker(addr: list[str]) -&gt; None\n</code></pre> <p>Exposes a known address and port to remote networked subscribers if configured.</p> <p>Parameters:</p> Name Type Description Default <code>list[str]</code> <p>List of IP addresses of remote hosts (other Brokers).</p> required"},{"location":"api/base/broker/#hermes.base.broker.broker.Broker.expose_to_remote_broker(addr)","title":"<code>addr</code>","text":""},{"location":"api/base/broker/#hermes.base.broker.broker.Broker.set_is_quit","title":"set_is_quit","text":"<pre><code>set_is_quit() -&gt; None\n</code></pre> <p>External asynchronous trigger to indicate termination to the Broker.</p>"},{"location":"api/base/broker/#hermes.base.broker.broker.Broker.subscribe_to_killsig","title":"subscribe_to_killsig","text":"<pre><code>subscribe_to_killsig(addr: str, port_killsig: str = PORT_KILL) -&gt; None\n</code></pre> <p>Subscribes to external kill signal of another host as master.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>IP address of the master Broker in a distributed setting.</p> required <code>str</code> <p>Port of the remote Broker to listen to for the termination signal. Defaults to PORT_KILL.</p> <code>PORT_KILL</code>"},{"location":"api/base/broker/#hermes.base.broker.broker.Broker.subscribe_to_killsig(addr)","title":"<code>addr</code>","text":""},{"location":"api/base/broker/#hermes.base.broker.broker.Broker.subscribe_to_killsig(port_killsig)","title":"<code>port_killsig</code>","text":""},{"location":"api/base/broker/#hermes.base.broker.broker_states","title":"broker_states","text":"<p>Classes:</p> Name Description <code>AbstractBrokerState</code> <p>Abstract class for the Broker component.</p> <code>InitState</code> <p>Initialization state of the Broker to launch local Nodes.</p> <code>JoinBrokerBarrierState</code> <p>Waits until all remote Brokers, if any, have their local Nodes gracefully terminated.</p> <code>JoinNodeBarrierState</code> <p>Waits until all local Nodes send final packets then quits itself.</p> <code>KillState</code> <p>Received 1 of 3 possible KILL signals to terminate.</p> <code>RunningState</code> <p>Stead-state capturing or streaming state of the Broker.</p> <code>StartState</code> <p>Start state of the Broker that waits or initiates distributed launch.</p> <code>SyncBrokerBarrierState</code> <p>Synchronization state of the Broker that waits until all remote Brokers setup.</p> <code>SyncNodeBarrierState</code> <p>Synchronization state of the Broker that waits until all local Nodes setup.</p>"},{"location":"api/base/broker/#hermes.base.broker.broker_states.AbstractBrokerState","title":"AbstractBrokerState","text":"<p>               Bases: <code>StateInterface</code></p> <p>Abstract class for the Broker component.</p> <p>Can be externally triggered into the KILL state from any child State class.</p> <p>Methods:</p> Name Description <code>run</code> <p>Run the logic of the currently selected state.</p>"},{"location":"api/base/broker/#hermes.base.broker.broker_states.AbstractBrokerState.run","title":"run  <code>abstractmethod</code>","text":"<pre><code>run() -&gt; None\n</code></pre> <p>Run the logic of the currently selected state.</p>"},{"location":"api/base/broker/#hermes.base.broker.broker_states.InitState","title":"InitState","text":"<p>               Bases: <code>AbstractBrokerState</code></p> <p>Initialization state of the Broker to launch local Nodes.</p> <p>Activates broker poller sockets and goes in sync to wait for local Nodes to start up.</p>"},{"location":"api/base/broker/#hermes.base.broker.broker_states.JoinBrokerBarrierState","title":"JoinBrokerBarrierState","text":"<p>               Bases: <code>AbstractBrokerState</code></p> <p>Waits until all remote Brokers, if any, have their local Nodes gracefully terminated.</p> <p>Wait for all dependent remote Brokers to send the acknowledgement messages that they no longer dependend on this Broker's data.</p> <p>Continue brokering packets until signalled by all remote hosts that there will be no more packets. Use the remote SYNC socket to coordinate when every Broker can exit.</p>"},{"location":"api/base/broker/#hermes.base.broker.broker_states.JoinNodeBarrierState","title":"JoinNodeBarrierState","text":"<p>               Bases: <code>AbstractBrokerState</code></p> <p>Waits until all local Nodes send final packets then quits itself.</p> <p>Wait for all processes (local and remote) to send the last messages before closing. Continue brokering packets until signalled by all publishers that there will be no more packets. Append a frame to the ZeroMQ message that indicates the last message from the sensor.</p>"},{"location":"api/base/broker/#hermes.base.broker.broker_states.JoinNodeBarrierState._check_host_sync_socket","title":"_check_host_sync_socket","text":"<pre><code>_check_host_sync_socket(poll_res: ZMQResult) -&gt; None\n</code></pre> <p>Check if a local Node sent a request on the SYNC socket to indicate its closure.</p> <p>Can be triggered by all local Nodes: Producer, Consumer, or Pipeline, sending 'EXIT?' request.</p>"},{"location":"api/base/broker/#hermes.base.broker.broker_states.JoinNodeBarrierState._is_finished","title":"_is_finished","text":"<pre><code>_is_finished() -&gt; bool\n</code></pre> <p>Convenience method indicating if any local Nodes remain active. </p> <p>Will wait until all local Nodes finish.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Whether all local Nodes gracefully terminated.</p>"},{"location":"api/base/broker/#hermes.base.broker.broker_states.JoinNodeBarrierState._on_is_end_packet","title":"_on_is_end_packet","text":"<pre><code>_on_is_end_packet(msg: list[bytes]) -&gt; None\n</code></pre> <p>Callback to track brokering of last packets of local Producers and Pipelines.</p> <p>Will get trigerred at most once per Node because publishing Nodes send it only once.</p>"},{"location":"api/base/broker/#hermes.base.broker.broker_states.JoinNodeBarrierState._release_local_node","title":"_release_local_node","text":"<pre><code>_release_local_node(topic: str) -&gt; None\n</code></pre> <p>Release the local Node from the list of active Nodes of the Broker.</p>"},{"location":"api/base/broker/#hermes.base.broker.broker_states.KillState","title":"KillState","text":"<p>               Bases: <code>AbstractBrokerState</code></p> <p>Received 1 of 3 possible KILL signals to terminate.</p> <p>Relay it to all Nodes and Brokers and wrap up gracefully.   from the local Keyboard Interrupt;   from the Master Broker;   from the GUI;</p>"},{"location":"api/base/broker/#hermes.base.broker.broker_states.RunningState","title":"RunningState","text":"<p>               Bases: <code>AbstractBrokerState</code></p> <p>Stead-state capturing or streaming state of the Broker.</p> <p>Will run until the the experiment is stopped or after a fixed period, if provided.</p>"},{"location":"api/base/broker/#hermes.base.broker.broker_states.RunningState._on_subscription_added","title":"_on_subscription_added","text":"<pre><code>_on_subscription_added(msg: list[bytes]) -&gt; None\n</code></pre> <p>Update a list on the Broker that keeps track of which Nodes are being brokered for.</p>"},{"location":"api/base/broker/#hermes.base.broker.broker_states.StartState","title":"StartState","text":"<p>               Bases: <code>AbstractBrokerState</code></p> <p>Start state of the Broker that waits or initiates distributed launch.</p> <p>Trigger local Nodes to start logging when the agreed start time arrives.</p>"},{"location":"api/base/broker/#hermes.base.broker.broker_states.SyncBrokerBarrierState","title":"SyncBrokerBarrierState","text":"<p>               Bases: <code>AbstractBrokerState</code></p> <p>Synchronization state of the Broker that waits until all remote Brokers setup.</p> <p>Communicate to other Brokers that every local device is ready.</p>"},{"location":"api/base/broker/#hermes.base.broker.broker_states.SyncNodeBarrierState","title":"SyncNodeBarrierState","text":"<p>               Bases: <code>AbstractBrokerState</code></p> <p>Synchronization state of the Broker that waits until all local Nodes setup.</p> <p>Waits until all local Nodes signalled that they are initialized and ready to go.</p>"},{"location":"api/base/delay_estimator/","title":"hermes.base.delay_estimator","text":"<p>The module exposes a hook for user-defined device-specific estimation of the propagation delay of a Stream (e.g. from an interfaced sensor), and lives inside a Node.</p> <p>User provides a callback function and sets corresponding parameters in the configuration of the Node.</p>"},{"location":"api/base/delay_estimator/#hermes.base.delay_estimator","title":"delay_estimator","text":"<p>Classes:</p> Name Description <code>DelayEstimator</code> <p>Functional callable class for periodic device-specific propagation delay estimation.</p>"},{"location":"api/base/delay_estimator/#hermes.base.delay_estimator.DelayEstimator","title":"DelayEstimator","text":"<p>Functional callable class for periodic device-specific propagation delay estimation.</p> <p>Methods:</p> Name Description <code>__call__</code> <p>Callable that runs periodic propagation delay estimation.</p> <code>cleanup</code> <p>Method for external trigger to terminate the delay estimator.</p>"},{"location":"api/base/delay_estimator/#hermes.base.delay_estimator.DelayEstimator.__call__","title":"__call__","text":"<pre><code>__call__(ping_fn: Callable, publish_fn: Callable)\n</code></pre> <p>Callable that runs periodic propagation delay estimation.</p> <p>Uses user-passed estimation and callback functions until termination.</p> <p>Parameters:</p> Name Type Description Default <code>Callable</code> <p>Propagation delay estimation function pointer.</p> required <code>Callable</code> <p>Callback function pointer.</p> required"},{"location":"api/base/delay_estimator/#hermes.base.delay_estimator.DelayEstimator.__call__(ping_fn)","title":"<code>ping_fn</code>","text":""},{"location":"api/base/delay_estimator/#hermes.base.delay_estimator.DelayEstimator.__call__(publish_fn)","title":"<code>publish_fn</code>","text":""},{"location":"api/base/delay_estimator/#hermes.base.delay_estimator.DelayEstimator.cleanup","title":"cleanup","text":"<pre><code>cleanup()\n</code></pre> <p>Method for external trigger to terminate the delay estimator.</p>"},{"location":"api/base/storage/","title":"hermes.base.storage","text":"<p>The module is responsible for high-performance asynchronous file IO.  It periodically spins up coroutines to offset long IO operations with concurrent writes of different files.</p> <p><code>storage_interface</code> - base interface for Storage function.</p> <p><code>storage</code> - concrete FSM-based Storage with streaming and dumping features.</p> <p><code>storage_states</code> - FSM states of the Storage.</p>"},{"location":"api/base/storage/#hermes.base.storage.storage_interface","title":"storage_interface","text":"<p>Classes:</p> Name Description <code>StorageInterface</code> <p>Interface for the AsyncIO Storage component.</p>"},{"location":"api/base/storage/#hermes.base.storage.storage_interface.StorageInterface","title":"StorageInterface","text":"<p>               Bases: <code>ABC</code></p> <p>Interface for the AsyncIO Storage component.</p>"},{"location":"api/base/storage/#hermes.base.storage.storage_interface.StorageInterface._initialize","title":"_initialize  <code>abstractmethod</code>","text":"<pre><code>_initialize(streams: OrderedDict[str, Stream]) -&gt; None\n</code></pre> <p>Initializes files and indices for write pointer tracking.</p> <p>Parameters:</p> Name Type Description Default <code>OrderedDict[str, Stream]</code> <p>Reference to the Stream objects to flush to disk.</p> required"},{"location":"api/base/storage/#hermes.base.storage.storage_interface.StorageInterface._initialize(streams)","title":"<code>streams</code>","text":""},{"location":"api/base/storage/#hermes.base.storage.storage_interface.StorageInterface._is_to_dump","title":"_is_to_dump  <code>abstractmethod</code>","text":"<pre><code>_is_to_dump() -&gt; bool\n</code></pre> <p>Check if any streams were configured to record.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Whether there are any streams configured to dump record data.</p>"},{"location":"api/base/storage/#hermes.base.storage.storage_interface.StorageInterface._is_to_stream","title":"_is_to_stream  <code>abstractmethod</code>","text":"<pre><code>_is_to_stream() -&gt; bool\n</code></pre> <p>Check if any streams were configured to stream.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Whether there are any streams configured to stream data.</p>"},{"location":"api/base/storage/#hermes.base.storage.storage_interface.StorageInterface._log_data","title":"_log_data  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>_log_data() -&gt; None\n</code></pre> <p>Main AsyncIO loop for Storage to write files concurrentlyto disk.</p>"},{"location":"api/base/storage/#hermes.base.storage.storage_interface.StorageInterface._release_thread_pool","title":"_release_thread_pool  <code>abstractmethod</code>","text":"<pre><code>_release_thread_pool() -&gt; None\n</code></pre> <p>Trigger release of AsyncIO resources used for writing files.</p>"},{"location":"api/base/storage/#hermes.base.storage.storage_interface.StorageInterface._set_state","title":"_set_state  <code>abstractmethod</code>","text":"<pre><code>_set_state(state) -&gt; None\n</code></pre> <p>User defined logic for FSM state transition.</p> <p>Parameters:</p> Name Type Description Default <code>Any</code> <p>New state to transition to.</p> required"},{"location":"api/base/storage/#hermes.base.storage.storage_interface.StorageInterface._set_state(state)","title":"<code>state</code>","text":""},{"location":"api/base/storage/#hermes.base.storage.storage_interface.StorageInterface._start_dump_logging","title":"_start_dump_logging  <code>abstractmethod</code>","text":"<pre><code>_start_dump_logging() -&gt; None\n</code></pre> <p>Initialize passive recording until terminated to dump data once.</p>"},{"location":"api/base/storage/#hermes.base.storage.storage_interface.StorageInterface._start_stream_logging","title":"_start_stream_logging  <code>abstractmethod</code>","text":"<pre><code>_start_stream_logging() -&gt; None\n</code></pre> <p>Set up AV/HDF5 file writers for stream-logging, if desired.</p>"},{"location":"api/base/storage/#hermes.base.storage.storage_interface.StorageInterface._stop_stream_logging","title":"_stop_stream_logging  <code>abstractmethod</code>","text":"<pre><code>_stop_stream_logging() -&gt; None\n</code></pre> <p>Trigger termination and flushing of accumulated streamed data.</p> <p>Will wait for the thread to finish before returning.</p>"},{"location":"api/base/storage/#hermes.base.storage.storage_interface.StorageInterface._wait_till_flush","title":"_wait_till_flush  <code>abstractmethod</code>","text":"<pre><code>_wait_till_flush() -&gt; None\n</code></pre> <p>Sleep until the Storage is triggered to terminate after flushing.</p>"},{"location":"api/base/storage/#hermes.base.storage.storage","title":"storage","text":"<p>Classes:</p> Name Description <code>Storage</code> <p>Manages IO operations of all stream data.</p>"},{"location":"api/base/storage/#hermes.base.storage.storage.Storage","title":"Storage","text":"<p>               Bases: <code>StorageInterface</code></p> <p>Manages IO operations of all stream data.</p> <p>Flushes data periodically for continuous operation and clears from memory to reduce RAM usage, or all at once if user guarantees enough memory. In continuous mode, will flush leftover data once the program is stopped.</p> <p>Logs video and audio data with FFmpeg to MKV/MP4 and MP3, respectively. Logs all other sensor data in a single hierarchical HDF5 file. CSV format is also supported, but discouraged -&gt; creates file per sub-stream.</p> <p>If sub-stream elements contain a burst of samples of sample_size, will automatically unroll it.</p> <p>Will fail if no FFmpeg is installed on the system.</p> <p>Methods:</p> Name Description <code>__call__</code> <p>Callable that runs main FSM loop.</p> <code>cleanup</code> <p>Stop stream-logging and wait for it to finish.</p>"},{"location":"api/base/storage/#hermes.base.storage.storage.Storage.__call__","title":"__call__","text":"<pre><code>__call__(streams: OrderedDict[str, Stream]) -&gt; None\n</code></pre> <p>Callable that runs main FSM loop.</p> <p>Runs continuously, ignoring Ctrl+C interrupt, until owner Node triggers an exit.</p> <p>Parameters:</p> Name Type Description Default <code>OrderedDict[str, Stream]</code> <p>Reference to the Stream objects to flush to disk.</p> required"},{"location":"api/base/storage/#hermes.base.storage.storage.Storage.__call__(streams)","title":"<code>streams</code>","text":""},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._close_files","title":"_close_files","text":"<pre><code>_close_files() -&gt; None\n</code></pre> <p>Convenience method to close all files writers.</p>"},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._close_files_audio","title":"_close_files_audio","text":"<pre><code>_close_files_audio() -&gt; None\n</code></pre> <p>Flush/close the audio file writers.</p>"},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._close_files_csv","title":"_close_files_csv","text":"<pre><code>_close_files_csv() -&gt; None\n</code></pre> <p>Flush/close the CSV file writers.</p>"},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._close_files_hdf5","title":"_close_files_hdf5","text":"<pre><code>_close_files_hdf5() -&gt; None\n</code></pre> <p>Flush/close the HDF5 file writer.</p> <p>Resizes datasets to remove extra empty rows.</p>"},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._close_files_video","title":"_close_files_video","text":"<pre><code>_close_files_video() -&gt; None\n</code></pre> <p>Flush/close the video files writers.</p>"},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._init_files_audio","title":"_init_files_audio","text":"<pre><code>_init_files_audio() -&gt; int\n</code></pre> <p>[Not implemented] Create and initialize audio writers, one for each device.</p> <p>TODO: implement audio streaming info on the Stream object.</p> <p>Will fail if no FFmpeg installed.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>When no supported codec specification was provided in config file.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of initialized writers.</p>"},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._init_files_csv","title":"_init_files_csv","text":"<pre><code>_init_files_csv() -&gt; int\n</code></pre> <p>Create and initialize CSV files.</p> <p>Will have a separate file for each stream of each device. Currently assumes that device names are unique across all streamers.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of initialized writers.</p>"},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._init_files_hdf5","title":"_init_files_hdf5","text":"<pre><code>_init_files_hdf5() -&gt; int\n</code></pre> <p>Create and initialize a hierarchical HDF5 file.</p> <p>Will have a single file for all streams from all devices. Currently assumes that device names are unique across all streamers.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of initialized writers.</p>"},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._init_files_video","title":"_init_files_video","text":"<pre><code>_init_files_video() -&gt; int\n</code></pre> <p>Create and initialize video writers, one for each device.</p> <p>Will fail if no FFmpeg installed.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>When no supported codec specification was provided in config file.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of initialized writers.</p>"},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._init_log_indices","title":"_init_log_indices","text":"<pre><code>_init_log_indices() -&gt; None\n</code></pre> <p>Initialize the data indices to fetch for logging</p> <p>Will record the next data indices that should be fetched for each stream, and the number of timesteps that each streamer needs before data is solidified.</p>"},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._log_data","title":"_log_data  <code>async</code>","text":"<pre><code>_log_data() -&gt; None\n</code></pre> <p>Trigger release of AsyncIO resources used for writing files.</p> <p>Polls data from each Node periodically or all at once.</p> <p>The poll period is set by self._stream_period_s.</p> <p>Will loop until self._is_streaming is False, and then will do one final fetch/log if self._is_flush is True.</p> <p>Assert self._is_streaming and deassert self._is_flush for streaming.   To finish, deassert self._is_streaming to False and assert self._is_flush.</p> <p>Deassert self._is_streaming and assert self._is_flush to dump record.   The thread will be inactive until terminated.   User is responsible to provision sufficient memory.</p>"},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._log_metadata","title":"_log_metadata","text":"<pre><code>_log_metadata()\n</code></pre> <p>Convenience method to add metadata to all file types.</p> <p>Will include device-level metadata and any lower-level data notes.</p>"},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._log_metadata_audio","title":"_log_metadata_audio","text":"<pre><code>_log_metadata_audio() -&gt; None\n</code></pre> <p>Add experiment metadata on the audio files.</p> <p>Dummy method, metadata is written on instantiation.</p>"},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._log_metadata_csv","title":"_log_metadata_csv","text":"<pre><code>_log_metadata_csv() -&gt; None\n</code></pre> <p>Add experiment metadata on the CSV files.</p> <p>TODO: validate logic.</p>"},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._log_metadata_hdf5","title":"_log_metadata_hdf5","text":"<pre><code>_log_metadata_hdf5() -&gt; None\n</code></pre> <p>Add experiment metadata on the HDF5 file.</p>"},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._log_metadata_video","title":"_log_metadata_video","text":"<pre><code>_log_metadata_video() -&gt; None\n</code></pre> <p>Add experiment metadata on the video files.</p> <p>Dummy method, metadata is written on instantiation.</p>"},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._sync_write_audio","title":"_sync_write_audio","text":"<pre><code>_sync_write_audio(audio_writer: Popen, node_name: str, device_name: str, stream_name: str)\n</code></pre> <p>Write provided data to the audio files.</p> <p>Can be called during streaming (periodic writing) and post-experiment dumping.</p> <p>Parameters:</p> Name Type Description Default <code>Popen</code> <p>FFmpeg writer corresponding to the audio.</p> required <code>str</code> <p>Valid unique tag of the Node owning the data.</p> required <code>str</code> <p>Valid device tree name.</p> required <code>str</code> <p>Valid sub-stream name.</p> required"},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._sync_write_audio(audio_writer)","title":"<code>audio_writer</code>","text":""},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._sync_write_audio(node_name)","title":"<code>node_name</code>","text":""},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._sync_write_audio(device_name)","title":"<code>device_name</code>","text":""},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._sync_write_audio(stream_name)","title":"<code>stream_name</code>","text":""},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._sync_write_csv","title":"_sync_write_csv","text":"<pre><code>_sync_write_csv(csv_writer: TextIOWrapper, node_name: str, device_name: str, stream_name: str) -&gt; None\n</code></pre> <p>Write provided data to the CSV file.</p> <p>Can be called during streaming (periodic writing) and post-experiment dumping.</p> <p>Parameters:</p> Name Type Description Default <code>TextIOWrapper</code> <p>Text file writer corresponding to the stream.</p> required <code>str</code> <p>Valid unique tag of the Node owning the data.</p> required <code>str</code> <p>Valid device tree name.</p> required <code>str</code> <p>Valid sub-stream name.</p> required"},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._sync_write_csv(csv_writer)","title":"<code>csv_writer</code>","text":""},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._sync_write_csv(node_name)","title":"<code>node_name</code>","text":""},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._sync_write_csv(device_name)","title":"<code>device_name</code>","text":""},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._sync_write_csv(stream_name)","title":"<code>stream_name</code>","text":""},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._sync_write_hdf5","title":"_sync_write_hdf5","text":"<pre><code>_sync_write_hdf5(node_name: str, device_name: str, stream_name: str) -&gt; None\n</code></pre> <p>Write provided data to the HDF5 file.</p> <p>Can be called during streaming (periodic writing) and post-experiment dumping.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>Valid unique tag of the Node owning the data.</p> required <code>str</code> <p>Valid device tree name.</p> required <code>str</code> <p>Valid sub-stream name.</p> required"},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._sync_write_hdf5(node_name)","title":"<code>node_name</code>","text":""},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._sync_write_hdf5(device_name)","title":"<code>device_name</code>","text":""},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._sync_write_hdf5(stream_name)","title":"<code>stream_name</code>","text":""},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._sync_write_video","title":"_sync_write_video","text":"<pre><code>_sync_write_video(video_writer: Popen, node_name: str, device_name: str, stream_name: str)\n</code></pre> <p>Write provided data to the video files.</p> <p>Can be called during streaming (periodic writing) and post-experiment dumping.</p> <p>Parameters:</p> Name Type Description Default <code>Popen</code> <p>FFmpeg writer corresponding to the video.</p> required <code>str</code> <p>Valid unique tag of the Node owning the data.</p> required <code>str</code> <p>Valid device tree name.</p> required <code>str</code> <p>Valid sub-stream name.</p> required"},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._sync_write_video(video_writer)","title":"<code>video_writer</code>","text":""},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._sync_write_video(node_name)","title":"<code>node_name</code>","text":""},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._sync_write_video(device_name)","title":"<code>device_name</code>","text":""},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._sync_write_video(stream_name)","title":"<code>stream_name</code>","text":""},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._write_audio","title":"_write_audio  <code>async</code>","text":"<pre><code>_write_audio(audio_writer: Popen, node_name: str, device_name: str, stream_name: str)\n</code></pre> <p>Coroutine asynchronous wrapper for multiple audio streams.</p> <p>Wraps synchronous IO of each video file into an asynchronous pool of coroutines.</p> <p>Parameters:</p> Name Type Description Default <code>Popen</code> <p>FFmpeg writer corresponding to the audio.</p> required <code>str</code> <p>Valid unique tag of the Node owning the data.</p> required <code>str</code> <p>Valid device tree name.</p> required <code>str</code> <p>Valid sub-stream name.</p> required"},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._write_audio(audio_writer)","title":"<code>audio_writer</code>","text":""},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._write_audio(node_name)","title":"<code>node_name</code>","text":""},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._write_audio(device_name)","title":"<code>device_name</code>","text":""},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._write_audio(stream_name)","title":"<code>stream_name</code>","text":""},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._write_csv","title":"_write_csv  <code>async</code>","text":"<pre><code>_write_csv(csv_writer: TextIOWrapper, node_name: str, device_name: str, stream_name: str)\n</code></pre> <p>Coroutine asynchronous wrapper for multiple CSV streams.</p> <p>Wraps synchronous IO of each CSV file into an asynchronous pool of coroutines.</p> <p>Parameters:</p> Name Type Description Default <code>TextIOWrapper</code> <p>Text file writer corresponding to the stream.</p> required <code>str</code> <p>Valid unique tag of the Node owning the data.</p> required <code>str</code> <p>Valid device tree name.</p> required <code>str</code> <p>Valid sub-stream name.</p> required"},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._write_csv(csv_writer)","title":"<code>csv_writer</code>","text":""},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._write_csv(node_name)","title":"<code>node_name</code>","text":""},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._write_csv(device_name)","title":"<code>device_name</code>","text":""},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._write_csv(stream_name)","title":"<code>stream_name</code>","text":""},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._write_files_audio","title":"_write_files_audio  <code>async</code>","text":"<pre><code>_write_files_audio()\n</code></pre> <p>Convenience method to asynchronously write all audio data to files.</p> <p>Will launch coroutine concurrently with other IO writer types.</p>"},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._write_files_csv","title":"_write_files_csv  <code>async</code>","text":"<pre><code>_write_files_csv()\n</code></pre> <p>Convenience method to asynchronously write all CSV data to files.</p> <p>Will launch coroutine concurrently with other IO writer types.</p>"},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._write_files_hdf5","title":"_write_files_hdf5  <code>async</code>","text":"<pre><code>_write_files_hdf5()\n</code></pre> <p>Convenience method to asynchronously write all HDF5 data to file.</p> <p>Will launch coroutine concurrently with other IO writer types.</p>"},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._write_files_video","title":"_write_files_video  <code>async</code>","text":"<pre><code>_write_files_video()\n</code></pre> <p>Convenience method to asynchronously write all video data to files.</p> <p>Will launch coroutines concurrently with other IO writer types.</p>"},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._write_hdf5","title":"_write_hdf5","text":"<pre><code>_write_hdf5() -&gt; None\n</code></pre> <p>Convenience wrapper to write new data for multiple HDF5 streams.</p> <p>Writes all new text data to a single HDF5 file.</p>"},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._write_video","title":"_write_video  <code>async</code>","text":"<pre><code>_write_video(video_writer: Popen, node_name: str, device_name: str, stream_name: str)\n</code></pre> <p>Coroutine asynchronous wrapper for multiple video streams.</p> <p>Wraps synchronous IO of each video file into an asynchronous pool of coroutines.</p> <p>Parameters:</p> Name Type Description Default <code>Popen</code> <p>FFmpeg writer corresponding to the video.</p> required <code>str</code> <p>Valid unique tag of the Node owning the data.</p> required <code>str</code> <p>Valid device tree name.</p> required <code>str</code> <p>Valid sub-stream name.</p> required"},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._write_video(video_writer)","title":"<code>video_writer</code>","text":""},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._write_video(node_name)","title":"<code>node_name</code>","text":""},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._write_video(device_name)","title":"<code>device_name</code>","text":""},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._write_video(stream_name)","title":"<code>stream_name</code>","text":""},{"location":"api/base/storage/#hermes.base.storage.storage.Storage.cleanup","title":"cleanup","text":"<pre><code>cleanup() -&gt; None\n</code></pre> <p>Stop stream-logging and wait for it to finish.</p> <p>Will stop stream-logging, if it is active. Will trigger data dump, if configured. Node pushing data to the Stream should stop adding new data before cleaning up Logger.</p>"},{"location":"api/base/storage/#hermes.base.storage.storage_states","title":"storage_states","text":"<p>Classes:</p> Name Description <code>AbstractStorageState</code> <p>Abstract class for the Storage component.</p> <code>DumpState</code> <p>Passive recording state of the Storage component.</p> <code>StartState</code> <p>Startup state that initializes Storage.</p> <code>StreamState</code> <p>Streaming state of the Storage component.</p>"},{"location":"api/base/storage/#hermes.base.storage.storage_states.AbstractStorageState","title":"AbstractStorageState","text":"<p>               Bases: <code>StateInterface</code></p> <p>Abstract class for the Storage component.</p>"},{"location":"api/base/storage/#hermes.base.storage.storage_states.DumpState","title":"DumpState","text":"<p>               Bases: <code>AbstractStorageState</code></p> <p>Passive recording state of the Storage component.</p> <p>Will flush data to disk once upon system termination.</p> <p>May run out of memory if the recording is long or user doesn't provision sufficient data.</p> <p>Using some streams in stream and others in dump has undefined behavior.</p>"},{"location":"api/base/storage/#hermes.base.storage.storage_states.StartState","title":"StartState","text":"<p>               Bases: <code>AbstractStorageState</code></p> <p>Startup state that initializes Storage.</p> <p>Will immediately transition into <code>StreamState</code> after initialization.</p>"},{"location":"api/base/storage/#hermes.base.storage.storage_states.StreamState","title":"StreamState","text":"<p>               Bases: <code>AbstractStorageState</code></p> <p>Streaming state of the Storage component.</p> <p>Will periodically flush data to disk, to clear memory, if any streams were specified to stream.</p> <p>Will flush remaining data to disk on exit.</p> <p>Using some streams in stream and others in dump has undefined behavior.</p>"},{"location":"api/base/stream/","title":"hermes.base.stream","text":"<p>Stream is a high-performance parallel thread-safe streaming data structure, which the rest of HERMES is based on. It is used to coordinate information between Broker, Producer/Consumer/Pipeline Nodes, and Storage component.</p>"},{"location":"api/base/stream/#hermes.base.stream","title":"stream","text":"<p>Classes:</p> Name Description <code>Stream</code> <p>An abstract class to store data of a Node.</p>"},{"location":"api/base/stream/#hermes.base.stream.Stream","title":"Stream","text":"<p>               Bases: <code>ABC</code></p> <p>An abstract class to store data of a Node.</p> <p>Tree-like structure of FIFO buffers. May contain multiple sub-streams for a single device, e.g. acceleration and gyroscope of an IMU.</p> <p>Data for sub-streams under the same device tree arrives as a single packet. Packets containing decoupled data are better treated as independent device trees.</p> <p>Uses a lock for each device tree to delegate access to the start of the FIFO: ensures high performance from parallel acquisition, processing, and logging blocks. This allows the end of the FIFO to be saved and discarded by the Storage.</p> <p>Will store the class name of each sensor in HDF5 metadata.</p> <p>Can periodically clear old data (if needed).</p> <p>Methods:</p> Name Description <code>add_stream</code> <p>Add a new sub-stream to an existing device tree or creates new.</p> <code>append_data</code> <p>Thread-safe append of new sample to the stream.</p> <code>clear_data</code> <p>Clear data in a stream.</p> <code>clear_data_all</code> <p>Clear all sub-streams from all device trees.</p> <code>get_device_names</code> <p>Get the names of the asynchronous device trees.</p> <code>get_fps</code> <p>Get effective frame rate of this unique stream's captured data.</p> <code>get_num_devices</code> <p>Get the number of asynchronous device trees.</p> <code>get_stream_info</code> <p>Get metadata of a sub-stream.</p> <code>get_stream_info_all</code> <p>Get metadata of all sub-streams.</p> <code>get_stream_names</code> <p>Get the names of sub-streams in a device tree.</p> <code>peek_data_new</code> <p>Wrap N newest samples in an iterator to peek.</p> <code>pop_data</code> <p>Wrap all samples ready to be popped in an iterator oldest-&gt;newest.</p>"},{"location":"api/base/stream/#hermes.base.stream.Stream._add_stream","title":"_add_stream","text":"<pre><code>_add_stream(device_name: str, stream_name: str, data_type: str, sample_size: Iterable[int], sampling_rate_hz: float = 0.0, is_measure_rate_hz: bool = False, data_notes: Mapping[str, str] = {}, is_video: bool = False, color_format: str | None = None, is_audio: bool = False, timesteps_before_solidified: int = 0, extra_data_info: ExtraDataInfoDict = {}) -&gt; None\n</code></pre> <p>[Internal] Underlying logic for adding a stream.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If supplied color format is not supported or misspelled.</p>"},{"location":"api/base/stream/#hermes.base.stream.Stream._append","title":"_append","text":"<pre><code>_append(device_name: str, stream_name: str, data: Any) -&gt; None\n</code></pre> <p>[Internal] Non thread-safe append of new sample.</p>"},{"location":"api/base/stream/#hermes.base.stream.Stream._get_fps","title":"_get_fps","text":"<pre><code>_get_fps(device_name: str, stream_name: str) -&gt; float | None\n</code></pre> <p>[Internal] Retrieve the effective sampling rate of a signal, if recorded.</p> <p>Records and refreshes rolling statistics on each data structure append over 1-second windows.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>Valid device tree name.</p> required <code>str</code> <p>Valid sub-stream name.</p> required <p>Returns:</p> Type Description <code>float | None</code> <p>float | None: Measured acquisition sampling rate of the sub-stream.</p>"},{"location":"api/base/stream/#hermes.base.stream.Stream._get_fps(device_name)","title":"<code>device_name</code>","text":""},{"location":"api/base/stream/#hermes.base.stream.Stream._get_fps(stream_name)","title":"<code>stream_name</code>","text":""},{"location":"api/base/stream/#hermes.base.stream.Stream.add_stream","title":"add_stream","text":"<pre><code>add_stream(device_name: str, stream_name: str, data_type: str, sample_size: Iterable[int], sampling_rate_hz: float = 0.0, is_measure_rate_hz: bool = False, data_notes: Mapping[str, str] = {}, is_video: bool = False, color_format: str | None = None, is_audio: bool = False, timesteps_before_solidified: int = 0, extra_data_info: ExtraDataInfoDict = {}) -&gt; None\n</code></pre> <p>Add a new sub-stream to an existing device tree or creates new.</p> <p>Will by default add a stream for each device to mark each captured sample with the host's time-of-arrival.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>Device tree name. Will autocreate if doesn't exist.</p> required <code>str</code> <p>Unique sub-stream name under this device tree.</p> required <code>str</code> <p>Fixed data type expected in the sub-stream.</p> required <code>Iterable[int]</code> <p>An interable of dimensions of given data type in each captured sample.</p> required <code>float</code> <p>Expected sampling frequency of the signal. Defaults to 0.0.</p> <code>0.0</code> <code>bool</code> <p>Whether to compute the effective sampling frequency. Defaults to False.</p> <code>False</code> <code>Mapping[str, str]</code> <p>Mapping of streams to notes for Storage to use in file metadata. Defaults to {}.</p> <code>{}</code> <code>bool</code> <p>Whether it is a video stream. Defaults to False.</p> <code>False</code> <code>str | None</code> <p>One of the supported VIDEO_FORMAT identifiers. Defaults to None.</p> <code>None</code> <code>bool</code> <p>Whether it is an audio stream. Defaults to False.</p> <code>False</code> <code>int</code> <p>How many most recent samples to keep in memory before flushing. Defaults to 0.</p> <code>0</code> <code>ExtraDataInfoDict</code> <p>Additional mapping that will be streamed along with data,  with at least 'data_type' and 'sample_size'. Defaults to {}.</p> <code>{}</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If stream name is not unique or is reserved.</p>"},{"location":"api/base/stream/#hermes.base.stream.Stream.add_stream(device_name)","title":"<code>device_name</code>","text":""},{"location":"api/base/stream/#hermes.base.stream.Stream.add_stream(stream_name)","title":"<code>stream_name</code>","text":""},{"location":"api/base/stream/#hermes.base.stream.Stream.add_stream(data_type)","title":"<code>data_type</code>","text":""},{"location":"api/base/stream/#hermes.base.stream.Stream.add_stream(sample_size)","title":"<code>sample_size</code>","text":""},{"location":"api/base/stream/#hermes.base.stream.Stream.add_stream(sampling_rate_hz)","title":"<code>sampling_rate_hz</code>","text":""},{"location":"api/base/stream/#hermes.base.stream.Stream.add_stream(is_measure_rate_hz)","title":"<code>is_measure_rate_hz</code>","text":""},{"location":"api/base/stream/#hermes.base.stream.Stream.add_stream(data_notes)","title":"<code>data_notes</code>","text":""},{"location":"api/base/stream/#hermes.base.stream.Stream.add_stream(is_video)","title":"<code>is_video</code>","text":""},{"location":"api/base/stream/#hermes.base.stream.Stream.add_stream(color_format)","title":"<code>color_format</code>","text":""},{"location":"api/base/stream/#hermes.base.stream.Stream.add_stream(is_audio)","title":"<code>is_audio</code>","text":""},{"location":"api/base/stream/#hermes.base.stream.Stream.add_stream(timesteps_before_solidified)","title":"<code>timesteps_before_solidified</code>","text":""},{"location":"api/base/stream/#hermes.base.stream.Stream.add_stream(extra_data_info)","title":"<code>extra_data_info</code>","text":""},{"location":"api/base/stream/#hermes.base.stream.Stream.append_data","title":"append_data","text":"<pre><code>append_data(process_time_s: float, data: NewDataDict) -&gt; None\n</code></pre> <p>Thread-safe append of new sample to the stream.</p> <p>Locks the device tree of the sub-stream, to avoid immutability error in reverse iterator of the GUI thread when trying to peek N newest  samples of the stream while new are written.</p> <p>Parameters:</p> Name Type Description Default <code>float</code> <p>Time-of-processing of the sample.</p> required <code>NewDataDict</code> <p>Newly processed sample.</p> required"},{"location":"api/base/stream/#hermes.base.stream.Stream.append_data(process_time_s)","title":"<code>process_time_s</code>","text":""},{"location":"api/base/stream/#hermes.base.stream.Stream.append_data(data)","title":"<code>data</code>","text":""},{"location":"api/base/stream/#hermes.base.stream.Stream.clear_data","title":"clear_data","text":"<pre><code>clear_data(device_name: str, stream_name: str, num_oldest_to_clear: int | None = None) -&gt; None\n</code></pre> <p>Clear data in a stream.</p> <p>Initializes the sub-stream if it doesn't exist. Optionally can clear N oldest samples.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>Valid device tree name.</p> required <code>str</code> <p>Valid sub-stream name.</p> required <code>int | None</code> <p>Number of oldest samples to clear. Defaults to None.</p> <code>None</code>"},{"location":"api/base/stream/#hermes.base.stream.Stream.clear_data(device_name)","title":"<code>device_name</code>","text":""},{"location":"api/base/stream/#hermes.base.stream.Stream.clear_data(stream_name)","title":"<code>stream_name</code>","text":""},{"location":"api/base/stream/#hermes.base.stream.Stream.clear_data(num_oldest_to_clear)","title":"<code>num_oldest_to_clear</code>","text":""},{"location":"api/base/stream/#hermes.base.stream.Stream.clear_data_all","title":"clear_data_all","text":"<pre><code>clear_data_all() -&gt; None\n</code></pre> <p>Clear all sub-streams from all device trees.</p>"},{"location":"api/base/stream/#hermes.base.stream.Stream.get_device_names","title":"get_device_names","text":"<pre><code>get_device_names() -&gt; list[str]\n</code></pre> <p>Get the names of the asynchronous device trees.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: Names of device trees.</p>"},{"location":"api/base/stream/#hermes.base.stream.Stream.get_fps","title":"get_fps  <code>abstractmethod</code>","text":"<pre><code>get_fps() -&gt; dict[str, float | None]\n</code></pre> <p>Get effective frame rate of this unique stream's captured data.</p> <p>Subject to expected transmission delay and throughput limitation.  Computed based on how fast data becomes available to the data structure. Used to measure the performance of the system - local or remote nodes.</p> <p>Returns:</p> Type Description <code>dict[str, float | None]</code> <p>dict[str, float | None]: Mapping of measured FPS to stream names.</p>"},{"location":"api/base/stream/#hermes.base.stream.Stream.get_num_devices","title":"get_num_devices","text":"<pre><code>get_num_devices() -&gt; int\n</code></pre> <p>Get the number of asynchronous device trees.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of device trees.</p>"},{"location":"api/base/stream/#hermes.base.stream.Stream.get_stream_info","title":"get_stream_info","text":"<pre><code>get_stream_info(device_name: str, stream_name: str) -&gt; Dict[str, Any]\n</code></pre> <p>Get metadata of a sub-stream.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>Valid device tree name.</p> required <code>str</code> <p>Valid sub-stream name.</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: Metadata dictionary with keys: data_type is_video is_audio sample_size sampling_rate_hz timesteps_before_solidified extra_data_info data_notes if is_measure_rate_hz:   actual_rate_hz   dt_circular_buffer   dt_circular_index   dt_running_sum   old_toa</p>"},{"location":"api/base/stream/#hermes.base.stream.Stream.get_stream_info(device_name)","title":"<code>device_name</code>","text":""},{"location":"api/base/stream/#hermes.base.stream.Stream.get_stream_info(stream_name)","title":"<code>stream_name</code>","text":""},{"location":"api/base/stream/#hermes.base.stream.Stream.get_stream_info_all","title":"get_stream_info_all","text":"<pre><code>get_stream_info_all() -&gt; StreamInfoDict\n</code></pre> <p>Get metadata of all sub-streams.</p> <p>Returns:</p> Name Type Description <code>StreamInfoDict</code> <code>StreamInfoDict</code> <p>Nested dictionary of metadata, with device trees and sub-streams as keys.</p>"},{"location":"api/base/stream/#hermes.base.stream.Stream.get_stream_names","title":"get_stream_names","text":"<pre><code>get_stream_names(device_name: str | None = None) -&gt; list[str]\n</code></pre> <p>Get the names of sub-streams in a device tree.</p> <p>If device_name is None, will assume streams are the same for every device.</p> <p>Parameters:</p> Name Type Description Default <code>str | None</code> <p>Name of the device tree to query. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: Names of sub-streams in a device tree.</p>"},{"location":"api/base/stream/#hermes.base.stream.Stream.get_stream_names(device_name)","title":"<code>device_name</code>","text":""},{"location":"api/base/stream/#hermes.base.stream.Stream.peek_data_new","title":"peek_data_new","text":"<pre><code>peek_data_new(device_name: str, stream_name: str, num_newest_to_peek: int | None = None) -&gt; Iterator[Any]\n</code></pre> <p>Wrap N newest samples in an iterator to peek.</p> <p>Will lock the device tree of the sub-stream to prevent appends muttating the iterator. Will allow popping of the oldest data (e.g. for Storage to flush). Peeking and popping ranges are protected by <code>timesteps_before_solidified</code>.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>Valid device tree name.</p> required <code>str</code> <p>Valid sub-stream name.</p> required <code>int | None</code> <p>Number of samples to peek, if less than <code>timesteps_before_solidified</code>. Defaults to None.</p> <code>None</code> <p>Yields:</p> Type Description <code>Any</code> <p>Iterator[Any]: Iterator over peekable newest samples.</p>"},{"location":"api/base/stream/#hermes.base.stream.Stream.peek_data_new(device_name)","title":"<code>device_name</code>","text":""},{"location":"api/base/stream/#hermes.base.stream.Stream.peek_data_new(stream_name)","title":"<code>stream_name</code>","text":""},{"location":"api/base/stream/#hermes.base.stream.Stream.peek_data_new(num_newest_to_peek)","title":"<code>num_newest_to_peek</code>","text":""},{"location":"api/base/stream/#hermes.base.stream.Stream.pop_data","title":"pop_data","text":"<pre><code>pop_data(device_name: str, stream_name: str, num_oldest_to_pop: int | None = None, is_flush: bool = False) -&gt; Iterator[Any]\n</code></pre> <p>Wrap all samples ready to be popped in an iterator oldest-&gt;newest.</p> <p>Used by Storage to flush data to disk. Popped data is cleared from memory. Thread-safe without locks while appending new data.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>Valid device tree name.</p> required <code>str</code> <p>Valid sub-stream name.</p> required <code>int | None</code> <p>Number of samples to pop. Defaults to None.</p> <code>None</code> <code>bool</code> <p>Whether to pop all data in the stream, regardless of timesteps_before_solidified. Defaults to False.</p> <code>False</code> <p>Yields:</p> Type Description <code>Any</code> <p>Iterator[Any]: Iterator over poppable oldest-&gt;newest samples.</p>"},{"location":"api/base/stream/#hermes.base.stream.Stream.pop_data(device_name)","title":"<code>device_name</code>","text":""},{"location":"api/base/stream/#hermes.base.stream.Stream.pop_data(stream_name)","title":"<code>stream_name</code>","text":""},{"location":"api/base/stream/#hermes.base.stream.Stream.pop_data(num_oldest_to_pop)","title":"<code>num_oldest_to_pop</code>","text":""},{"location":"api/base/stream/#hermes.base.stream.Stream.pop_data(is_flush)","title":"<code>is_flush</code>","text":""},{"location":"api/datastructures/","title":"Datastructures","text":"<p>The module contains useful reusable datastructures encapsulated in the higher-level components of HERMES. </p>"},{"location":"api/datastructures/cache/","title":"Cache","text":""},{"location":"api/datastructures/cache/#hermes.datastructures.cache","title":"cache","text":"<p>Classes:</p> Name Description <code>FFmpegCache</code>"},{"location":"api/datastructures/cache/#hermes.datastructures.cache.FFmpegCache","title":"FFmpegCache","text":"<p>Methods:</p> Name Description <code>get_data</code> <p>Request data from cache.</p> <code>start</code> <p>Start the background cache management thread.</p> <code>stop</code> <p>Stop the background cache management task.</p>"},{"location":"api/datastructures/cache/#hermes.datastructures.cache.FFmpegCache._cache_manager","title":"_cache_manager","text":"<pre><code>_cache_manager()\n</code></pre> <p>Background continuous task: cache management. Processes requests from the GUI and predicts future needs.</p>"},{"location":"api/datastructures/cache/#hermes.datastructures.cache.FFmpegCache._fetch_data_from_source","title":"_fetch_data_from_source","text":"<pre><code>_fetch_data_from_source(key: Any) -&gt; Dict[Any, bytes]\n</code></pre> <p>Simulate fetching data from external source. Replace this with your actual data source (database, API, etc.)</p>"},{"location":"api/datastructures/cache/#hermes.datastructures.cache.FFmpegCache._process_request","title":"_process_request","text":"<pre><code>_process_request(request: DataRequest)\n</code></pre> <p>Process data request</p>"},{"location":"api/datastructures/cache/#hermes.datastructures.cache.FFmpegCache.get_data","title":"get_data","text":"<pre><code>get_data(key: Any) -&gt; bytes\n</code></pre> <p>Request data from cache. Returns immediately if cached, otherwise waits for the background task to fetch.</p>"},{"location":"api/datastructures/cache/#hermes.datastructures.cache.FFmpegCache.start","title":"start","text":"<pre><code>start()\n</code></pre> <p>Start the background cache management thread.</p>"},{"location":"api/datastructures/cache/#hermes.datastructures.cache.FFmpegCache.stop","title":"stop","text":"<pre><code>stop()\n</code></pre> <p>Stop the background cache management task.</p>"},{"location":"api/datastructures/fifo/","title":"FIFO","text":""},{"location":"api/datastructures/fifo/#hermes.datastructures.fifo","title":"fifo","text":""},{"location":"api/utils/","title":"Utilities","text":"<p>Some useful utilities abstracting or enriching functionality of the main source.</p>"},{"location":"api/utils/#hermes.utils.types","title":"types","text":""},{"location":"api/utils/#hermes.utils.time_utils","title":"time_utils","text":""},{"location":"api/utils/#hermes.utils.node_utils","title":"node_utils","text":""},{"location":"api/utils/#hermes.utils.mp_utils","title":"mp_utils","text":""},{"location":"api/utils/#hermes.utils.msgpack_utils","title":"msgpack_utils","text":""},{"location":"api/utils/#hermes.utils.argparse_utils","title":"argparse_utils","text":""},{"location":"api/utils/#hermes.utils.sensor_utils","title":"sensor_utils","text":""},{"location":"api/utils/#hermes.utils.numpy_utils","title":"numpy_utils","text":""},{"location":"api/utils/#hermes.utils.dict_utils","title":"dict_utils","text":""},{"location":"api/utils/#hermes.utils.angle_utils","title":"angle_utils","text":""},{"location":"api/utils/#hermes.utils.print_utils","title":"print_utils","text":""},{"location":"api/utils/#hermes.utils.zmq_utils","title":"zmq_utils","text":""},{"location":"architecture/","title":"Architecture","text":"<p>TODO: showcase how HERMES is designed and what are its primary principles.</p>"},{"location":"firststeps/","title":"Getting started","text":""},{"location":"firststeps/#installation","title":"Installation","text":"<p>TODO: provide explanation on how to install the base and any optional supported packages.</p>"},{"location":"firststeps/#ssh-keys","title":"SSH keys","text":"<p>Generate and exchange public SSH keys across distributed hosts.</p>"},{"location":"firststeps/#extra-modules","title":"Extra modules","text":"<p>Install any of the desired supported modules for the sensors you intend to use.</p>"},{"location":"firststeps/#adding-custom-device","title":"Adding custom device","text":"<p>User creates the proper structure that Python recognizes as a namespace HERMES module.</p>"},{"location":"firststeps/#running","title":"Running","text":"<p>User specifies YAML configuration file (incl. custom Nodes) and launches the CLI. The CLI spins up stream processing on all the distributed hosts on the local network.</p>"},{"location":"firststeps/changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog.</p> <p>This project adheres to Semantic Versioning.</p>"},{"location":"firststeps/changelog/#hermes","title":"HERMES","text":""},{"location":"firststeps/changelog/#010-october-11-2025","title":"0.1.0 October 11, 2025","text":"<ul> <li>Initial publically available version of the framework.</li> </ul>"},{"location":"firststeps/contributing/","title":"Contributing","text":"<p>We want to make contributing to this project as easy and transparent as possible.</p>"},{"location":"firststeps/contributing/#pull-requests","title":"Pull Requests","text":"<p>We actively welcome your pull requests.</p> <ol> <li>Fork the repo and create your branch from <code>main</code>.</li> <li>If you've added code that should be tested, add tests.</li> <li>If you've changed APIs, update the documentation.</li> </ol>"},{"location":"firststeps/contributing/#issues","title":"Issues","text":"<p>We use GitHub issues to track public bugs. Please ensure your description is clear and has sufficient instructions to be able to reproduce the issue.</p>"},{"location":"firststeps/contributing/#license","title":"License","text":"<p>By contributing to HERMES, you agree that your contributions will be licensed under the LICENSE file in the root directory of this source tree.</p>"},{"location":"firststeps/license/","title":"License","text":""},{"location":"firststeps/license/#sourcecode-license","title":"Sourcecode license","text":"<p>The MIT License (MIT)</p> <p>Copyright (c) 2024-2025 Maxim Yudayev and KU Leuven eMedia Lab.</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"firststeps/license/#creative-artworks-license","title":"Creative artworks license","text":"<p>The creative artwork for HERMES is Copyright (c) 2025 Maxim Yudayev, all rights reserved.</p> <p>The logo is trademark (or service mark) of Maxim Yudayev and is licensed under the  Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License (CC BY-NC-ND 4.0).</p> <p>Use of this logo does not constitute an endorsement by Maxim Yudayev.</p> <p>Any commercial use, modification, or use in a manner that suggests endorsement or association  with the project's source or origin is strictly prohibited without a separate written agreement.</p>"},{"location":"firststeps/tutorials/","title":"Tutorials","text":"<p>TODO: introduction of the sample projects enabled by HERMES to inspire your usage.</p>"},{"location":"firststeps/tutorials/acquisition/","title":"Data acquisition","text":""},{"location":"firststeps/tutorials/ai-worker/","title":"Closed-loop AI worker","text":""},{"location":"firststeps/tutorials/annotation/","title":"Data annotation","text":""},{"location":"helpdesk/faq/","title":"FAQ","text":"<p>TODO: what is frequently missed by the user and how to resolve it.</p>"},{"location":"helpdesk/issues/","title":"Known issues","text":"<p>TODO: we are aware of these shortcomings and are fixing them.</p>"},{"location":"helpdesk/limitations/","title":"Current limitations","text":"<p>TODO: transparent acknowledgement of current limitations (either outside of scope, on the roadmap, or has room for improvement).</p>"},{"location":"helpdesk/roadmap/","title":"Development roadmap","text":"<p>TODO: items planned on our roadmap to enhance the functionality of the system.</p>"}]}