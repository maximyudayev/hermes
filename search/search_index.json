{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to HERMES","text":"<p>We are working hard to deliver high-quality documentation to you as soon as possible.</p> <p>Stay tuned!</p> <p>In the meantime, check out our socials and GitHub</p>"},{"location":"api/","title":"Reference","text":"<p>HERMES is a namespace framework, which allows easy installation of support for additional Nodes as pip packages that become available under the same namespace <code>hermes.&lt;new_package&gt;</code>. Specifying</p> <p>Adding a new <code>Node</code></p> <p>Integrating user-defined new Node into the rest of the framework is trivial. Wrap the custom logic, including non-HERMES code, in the provided template.</p> <p>HERMES follows the PEP 8 public/private method naming convention.</p> <p>Regular users</p> <p>Only use the available public methods, without leading underscores <code>_&lt;method_name&gt;()</code>. The private methods are shown for informative purposes only. Extending the system to new sensors is easy with ready-made templates and provided decoupling from the low-level controls.</p> <p>Developers</p> <p>When extending the system functionality, understanding of low-level methods could become useful. Private methods also influence performance and could be the first place to look for enhancements.</p>"},{"location":"api/base/","title":"Overview","text":"<p>TODO: details of the <code>base</code> module structure and function.</p> <p><code>state_interface</code> - base interface for FSM creation.</p>"},{"location":"api/base/#hermes.base.state_interface","title":"state_interface","text":"<p>Classes:</p> Name Description <code>StateInterface</code> <p>Basic FSM interface for Broker, Node, Storage.</p>"},{"location":"api/base/#hermes.base.state_interface.StateInterface","title":"StateInterface","text":"<p>               Bases: <code>ABC</code></p> <pre><code>\n              flowchart TD\n              hermes.base.state_interface.StateInterface[StateInterface]\n\n              \n\n              click hermes.base.state_interface.StateInterface href \"\" \"hermes.base.state_interface.StateInterface\"\n            </code></pre> <p>Basic FSM interface for Broker, Node, Storage.</p> <p>Methods:</p> Name Description <code>is_continue</code> <p>Check if to stay in the current state.</p> <code>kill</code> <p>Trigger to enter the KILL state from any other.</p> <code>run</code> <p>Run the logic of the currently selected state.</p>"},{"location":"api/base/#hermes.base.state_interface.StateInterface.is_continue","title":"is_continue  <code>abstractmethod</code>","text":"<pre><code>is_continue() -&gt; bool\n</code></pre> <p>Check if to stay in the current state.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Whether to stay in the same state.</p>"},{"location":"api/base/#hermes.base.state_interface.StateInterface.kill","title":"kill  <code>abstractmethod</code>","text":"<pre><code>kill() -&gt; None\n</code></pre> <p>Trigger to enter the KILL state from any other.</p>"},{"location":"api/base/#hermes.base.state_interface.StateInterface.run","title":"run  <code>abstractmethod</code>","text":"<pre><code>run() -&gt; None\n</code></pre> <p>Run the logic of the currently selected state.</p>"},{"location":"api/base/broker/","title":"hermes.base.broker","text":"<p>The module is responsible for managing the lifecycle of all locally-hosted Nodes.  It is also the program's entrypoint to the continuous sensing and processing.</p> <p><code>broker_interface</code> - base interface for Broker function.</p> <p><code>broker</code> - concrete FSM-based Broker with distributed LAN connectivity.</p> <p><code>broker_states</code> - FSM states of the Broker.</p>"},{"location":"api/base/broker/#hermes.base.broker.broker_interface","title":"broker_interface","text":"<p>Classes:</p> Name Description <code>BrokerInterface</code> <p>Interface for the Broker component.</p>"},{"location":"api/base/broker/#hermes.base.broker.broker_interface.BrokerInterface","title":"BrokerInterface","text":"<p>               Bases: <code>ABC</code></p> <pre><code>\n              flowchart TD\n              hermes.base.broker.broker_interface.BrokerInterface[BrokerInterface]\n\n              \n\n              click hermes.base.broker.broker_interface.BrokerInterface href \"\" \"hermes.base.broker.broker_interface.BrokerInterface\"\n            </code></pre> <p>Interface for the Broker component.</p>"},{"location":"api/base/broker/#hermes.base.broker.broker_interface.BrokerInterface._activate_pubsub_poller","title":"_activate_pubsub_poller  <code>abstractmethod</code>","text":"<pre><code>_activate_pubsub_poller() -&gt; None\n</code></pre> <p>Register PUB-SUB sockets on both Broker interfaces for polling.</p>"},{"location":"api/base/broker/#hermes.base.broker.broker_interface.BrokerInterface._add_brokered_node","title":"_add_brokered_node  <code>abstractmethod</code>","text":"<pre><code>_add_brokered_node(topic: str) -&gt; None\n</code></pre> <p>Add a unique local Node identifier joining the exchange via the Broker.</p> <p>Noes uniquely self-identify by the data topic they produce.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>Unique identifier of the Node.</p> required"},{"location":"api/base/broker/#hermes.base.broker.broker_interface.BrokerInterface._add_brokered_node(topic)","title":"<code>topic</code>","text":""},{"location":"api/base/broker/#hermes.base.broker.broker_interface.BrokerInterface._broker_packets","title":"_broker_packets  <code>abstractmethod</code>","text":"<pre><code>_broker_packets(\n    poll_res: ZMQResult,\n    on_data_received: Callable[[list[bytes]], None] = lambda _: None,\n    on_subscription_changed: Callable[[list[bytes]], None] = lambda _: None,\n) -&gt; None\n</code></pre> <p>Move packets between publishers and subscribers, local and remote.</p> <p>Parameters:</p> Name Type Description Default <code>ZMQResult</code> <p>New ZeroMQ packets from PUB or SUB interfaces.</p> required <code>_type_</code> <p>Callback for data packets. Defaults to lambda_:None.</p> <code>lambda _: None</code> <code>_type_</code> <p>Callback for subscription status packets. Defaults to lambda_:None.</p> <code>lambda _: None</code>"},{"location":"api/base/broker/#hermes.base.broker.broker_interface.BrokerInterface._broker_packets(poll_res)","title":"<code>poll_res</code>","text":""},{"location":"api/base/broker/#hermes.base.broker.broker_interface.BrokerInterface._broker_packets(on_data_received)","title":"<code>on_data_received</code>","text":""},{"location":"api/base/broker/#hermes.base.broker.broker_interface.BrokerInterface._broker_packets(on_subscription_changed)","title":"<code>on_subscription_changed</code>","text":""},{"location":"api/base/broker/#hermes.base.broker.broker_interface.BrokerInterface._check_for_kill","title":"_check_for_kill  <code>abstractmethod</code>","text":"<pre><code>_check_for_kill(poll_res: ZMQResult) -&gt; bool\n</code></pre> <p>Check if received packets contain a kill signal from a downstream Broker.</p> <p>Parameters:</p> Name Type Description Default <code>ZMQResult</code> <p>New ZeroMQ packets from PUB or SUB interfaces.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Whether a KILL message is contained in messages.</p>"},{"location":"api/base/broker/#hermes.base.broker.broker_interface.BrokerInterface._check_for_kill(poll_res)","title":"<code>poll_res</code>","text":""},{"location":"api/base/broker/#hermes.base.broker.broker_interface.BrokerInterface._deactivate_pubsub_poller","title":"_deactivate_pubsub_poller  <code>abstractmethod</code>","text":"<pre><code>_deactivate_pubsub_poller() -&gt; None\n</code></pre> <p>Stop listening on the PUB or SUB interfaces for new data packets.</p>"},{"location":"api/base/broker/#hermes.base.broker.broker_interface.BrokerInterface._get_brokered_nodes","title":"_get_brokered_nodes  <code>abstractmethod</code>","text":"<pre><code>_get_brokered_nodes() -&gt; set[str]\n</code></pre> <p>Get the set of unique local Node identifiers that Broker manages.</p> <p>Returns:</p> Type Description <code>set[str]</code> <p>set[str]: Set of unique identifiers.</p>"},{"location":"api/base/broker/#hermes.base.broker.broker_interface.BrokerInterface._get_duration","title":"_get_duration  <code>abstractmethod</code>","text":"<pre><code>_get_duration() -&gt; float | None\n</code></pre> <p>Get the user-requested active duration of the capture/streaming.</p> <p>Returns:</p> Type Description <code>float | None</code> <p>float | None: Time in seconds, if specified on Broker launch.</p>"},{"location":"api/base/broker/#hermes.base.broker.broker_interface.BrokerInterface._get_host_ip","title":"_get_host_ip  <code>abstractmethod</code>","text":"<pre><code>_get_host_ip() -&gt; str\n</code></pre> <p>Get the Broker's host machine LAN IP address.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Host's IP address.</p>"},{"location":"api/base/broker/#hermes.base.broker.broker_interface.BrokerInterface._get_is_master_broker","title":"_get_is_master_broker  <code>abstractmethod</code>","text":"<pre><code>_get_is_master_broker() -&gt; bool\n</code></pre> <p>Get the master status of this Broker in a distributed setup.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Whether this Broker is the master.</p>"},{"location":"api/base/broker/#hermes.base.broker.broker_interface.BrokerInterface._get_node_addresses","title":"_get_node_addresses  <code>abstractmethod</code>","text":"<pre><code>_get_node_addresses() -&gt; dict[str, bytes]\n</code></pre> <p>Bulk-get socket identifiers and unique Node identifiers for Broker's local Nodes.</p> <p>Returns:</p> Type Description <code>dict[str, bytes]</code> <p>dict[str, bytes]: Mapping of unique Node topics and their ZeroMQ socket identifiers.</p>"},{"location":"api/base/broker/#hermes.base.broker.broker_interface.BrokerInterface._get_num_backends","title":"_get_num_backends  <code>abstractmethod</code>","text":"<pre><code>_get_num_backends() -&gt; int\n</code></pre> <p>Get the number of XSUB interfaces to remote hosts, the Broker listens to.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of sockets.</p>"},{"location":"api/base/broker/#hermes.base.broker.broker_interface.BrokerInterface._get_num_frontends","title":"_get_num_frontends  <code>abstractmethod</code>","text":"<pre><code>_get_num_frontends() -&gt; int\n</code></pre> <p>Get the number of XPUB interfaces to remote hosts, listening to the Broker.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of sockets.</p>"},{"location":"api/base/broker/#hermes.base.broker.broker_interface.BrokerInterface._get_num_local_nodes","title":"_get_num_local_nodes  <code>abstractmethod</code>","text":"<pre><code>_get_num_local_nodes() -&gt; int\n</code></pre> <p>Get the number of Nodes hosted and managed by this Broker.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of locally attached Nodes.</p>"},{"location":"api/base/broker/#hermes.base.broker.broker_interface.BrokerInterface._get_poller","title":"_get_poller  <code>abstractmethod</code>","text":"<pre><code>_get_poller() -&gt; Poller\n</code></pre> <p>Get the ZeroMQ Poller object responsible for socket management.</p> <p>Returns:</p> Type Description <code>Poller</code> <p>zmq.Poller: ZeroMQ poller to (de)activate listening on an interface.</p>"},{"location":"api/base/broker/#hermes.base.broker.broker_interface.BrokerInterface._get_remote_broker_addresses","title":"_get_remote_broker_addresses  <code>abstractmethod</code>","text":"<pre><code>_get_remote_broker_addresses() -&gt; dict[str, bytes]\n</code></pre> <p>Bulk-get socket identifiers and IP addresses of remote Brokers.</p> <p>Returns:</p> Type Description <code>dict[str, bytes]</code> <p>dict[str, bytes]: Mapping of remote IPs and their ZeroMQ socket identifiers.</p>"},{"location":"api/base/broker/#hermes.base.broker.broker_interface.BrokerInterface._get_remote_pub_brokers","title":"_get_remote_pub_brokers  <code>abstractmethod</code>","text":"<pre><code>_get_remote_pub_brokers() -&gt; list[str]\n</code></pre> <p>Get the list of remote publishing Brokers' IPs.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: List of IP addresses.</p>"},{"location":"api/base/broker/#hermes.base.broker.broker_interface.BrokerInterface._get_remote_sub_brokers","title":"_get_remote_sub_brokers  <code>abstractmethod</code>","text":"<pre><code>_get_remote_sub_brokers() -&gt; list[str]\n</code></pre> <p>Get the list of remote subscribing Brokers' IPs.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: List of IP addresses.</p>"},{"location":"api/base/broker/#hermes.base.broker.broker_interface.BrokerInterface._get_start_time","title":"_get_start_time  <code>abstractmethod</code>","text":"<pre><code>_get_start_time() -&gt; float\n</code></pre> <p>Get the start time when the Broker set everything up and started streaming.</p> <p>Useful for measuring run time of the experiment, excluding the lengthy setup process.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Time in seconds since epoch.</p>"},{"location":"api/base/broker/#hermes.base.broker.broker_interface.BrokerInterface._get_sync_host_socket","title":"_get_sync_host_socket  <code>abstractmethod</code>","text":"<pre><code>_get_sync_host_socket() -&gt; SyncSocket\n</code></pre> <p>Get the reference to the RCV socket for syncing local Nodes.</p> <p>Returns:</p> Type Description <code>SyncSocket</code> <p>zmq.SyncSocket: ZeroMQ socket used to communicate SYNC process.</p>"},{"location":"api/base/broker/#hermes.base.broker.broker_interface.BrokerInterface._get_sync_remote_socket","title":"_get_sync_remote_socket  <code>abstractmethod</code>","text":"<pre><code>_get_sync_remote_socket() -&gt; SyncSocket\n</code></pre> <p>Get the reference to the RCV socket for syncing remote Brokers.</p> <p>Returns:</p> Type Description <code>SyncSocket</code> <p>zmq.SyncSocket: ZeroMQ socket used to communicate SYNC process.</p>"},{"location":"api/base/broker/#hermes.base.broker.broker_interface.BrokerInterface._log_source_tag","title":"_log_source_tag  <code>abstractmethod</code> <code>classmethod</code>","text":"<pre><code>_log_source_tag() -&gt; str\n</code></pre> <p>Read-only class property identifying the component.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Unique identifier.</p>"},{"location":"api/base/broker/#hermes.base.broker.broker_interface.BrokerInterface._poll","title":"_poll  <code>abstractmethod</code>","text":"<pre><code>_poll(timeout_ms: int) -&gt; ZMQResult\n</code></pre> <p>Block until any new packets are available on PUB or SUB Broker interfaces.</p> <p>Parameters:</p> Name Type Description Default <code>int</code> <p>Polling timeout duration to re-evaluate check for manual CLI termination.</p> required <p>Returns:</p> Name Type Description <code>ZMQResult</code> <code>ZMQResult</code> <p>New ZeroMQ packets from PUB or SUB interfaces.</p>"},{"location":"api/base/broker/#hermes.base.broker.broker_interface.BrokerInterface._poll(timeout_ms)","title":"<code>timeout_ms</code>","text":""},{"location":"api/base/broker/#hermes.base.broker.broker_interface.BrokerInterface._publish_kill","title":"_publish_kill  <code>abstractmethod</code>","text":"<pre><code>_publish_kill()\n</code></pre> <p>Send kill signals to upstream Brokers and local Nodes.</p>"},{"location":"api/base/broker/#hermes.base.broker.broker_interface.BrokerInterface._remove_brokered_node","title":"_remove_brokered_node  <code>abstractmethod</code>","text":"<pre><code>_remove_brokered_node(topic: str) -&gt; None\n</code></pre> <p>Remove the existing local Node identifier from the exchange via the Broker.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>Unique identifier of the Node.</p> required"},{"location":"api/base/broker/#hermes.base.broker.broker_interface.BrokerInterface._remove_brokered_node(topic)","title":"<code>topic</code>","text":""},{"location":"api/base/broker/#hermes.base.broker.broker_interface.BrokerInterface._set_broker_ready","title":"_set_broker_ready  <code>abstractmethod</code>","text":"<pre><code>_set_broker_ready() -&gt; None\n</code></pre> <p>Hook for FSM to set Broker's internal state as ready.</p>"},{"location":"api/base/broker/#hermes.base.broker.broker_interface.BrokerInterface._set_node_addresses","title":"_set_node_addresses  <code>abstractmethod</code>","text":"<pre><code>_set_node_addresses(node_addresses: dict[str, bytes]) -&gt; None\n</code></pre> <p>Bulk-set socket identifiers and unique Node identifiers for Broker's local Nodes.</p> <p>Parameters:</p> Name Type Description Default <code>dict[str, bytes]</code> <p>Mapping of unique Node topics and their ZeroMQ socket identifiers.</p> required"},{"location":"api/base/broker/#hermes.base.broker.broker_interface.BrokerInterface._set_node_addresses(node_addresses)","title":"<code>node_addresses</code>","text":""},{"location":"api/base/broker/#hermes.base.broker.broker_interface.BrokerInterface._set_remote_broker_addresses","title":"_set_remote_broker_addresses  <code>abstractmethod</code>","text":"<pre><code>_set_remote_broker_addresses(remote_brokers: dict[str, bytes]) -&gt; None\n</code></pre> <p>Bulk-set socket identifiers and IP addresses of remote Brokers for this Broker.</p> <p>Parameters:</p> Name Type Description Default <code>dict[str, bytes]</code> <p>Mapping of remote IPs and their ZeroMQ socket identifiers.</p> required"},{"location":"api/base/broker/#hermes.base.broker.broker_interface.BrokerInterface._set_remote_broker_addresses(remote_brokers)","title":"<code>remote_brokers</code>","text":""},{"location":"api/base/broker/#hermes.base.broker.broker_interface.BrokerInterface._set_state","title":"_set_state  <code>abstractmethod</code>","text":"<pre><code>_set_state(state) -&gt; None\n</code></pre> <p>User defined logic for FSM state transition.</p> <p>Parameters:</p> Name Type Description Default <code>Any</code> <p>New state to transition to.</p> required"},{"location":"api/base/broker/#hermes.base.broker.broker_interface.BrokerInterface._set_state(state)","title":"<code>state</code>","text":""},{"location":"api/base/broker/#hermes.base.broker.broker_interface.BrokerInterface._start_local_nodes","title":"_start_local_nodes  <code>abstractmethod</code>","text":"<pre><code>_start_local_nodes() -&gt; None\n</code></pre> <p>Spawn specified locally hosted Nodes, each in a separate process.</p>"},{"location":"api/base/broker/#hermes.base.broker.broker","title":"broker","text":"<p>Classes:</p> Name Description <code>Broker</code> <p>Manager of the lifecycle of all connected local Nodes and data broker.</p>"},{"location":"api/base/broker/#hermes.base.broker.broker.Broker","title":"Broker","text":"<p>               Bases: <code>BrokerInterface</code></p> <pre><code>\n              flowchart TD\n              hermes.base.broker.broker.Broker[Broker]\n              hermes.base.broker.broker_interface.BrokerInterface[BrokerInterface]\n\n                              hermes.base.broker.broker_interface.BrokerInterface --&gt; hermes.base.broker.broker.Broker\n                \n\n\n              click hermes.base.broker.broker.Broker href \"\" \"hermes.base.broker.broker.Broker\"\n              click hermes.base.broker.broker_interface.BrokerInterface href \"\" \"hermes.base.broker.broker_interface.BrokerInterface\"\n            </code></pre> <p>Manager of the lifecycle of all connected local Nodes and data broker.</p> <p>Facilitates high-performance message exchange using ZeroMQ zero-copy communication across distributed sensing and computing hosts. Passes data over sockets to external Brokers or over shared memory for local Nodes.</p> <p>Hosts control logic of interactive proxy/server. Will launch/destroy/connect to Nodes on creation and ad-hoc. Will use a separate process for each streamer and consumer. Each Node connects only to its local Broker,     which then exposes its data to outside LAN subscribers.</p> <p>Uses fixed ports for communication under <code>zmq_utils.py</code>. Use of other ports is discouraged.</p> <p>Macro-defined ports are preferred for consistency in a distributed, multi-host setup.</p> <p>Uses hierarchical coordination of distributed host synchronization/setup. Each Broker first starts up and sync local Nodes. Then syncs with all expected remote hosts, until all are ready. After all are ready, master Broker communicates trigger signal to start streaming.</p> <p>Methods:</p> Name Description <code>__call__</code> <p>The main FSM loop of the Broker.</p> <code>__init__</code> <p>Constructor of the Broker component responsible for the lifecycle of all local Nodes and for message exchange across them and distributed hosts.</p> <code>connect_to_remote_broker</code> <p>Connects to a known address and port of external LAN data broker.</p> <code>expose_to_remote_broker</code> <p>Exposes a known address and port to remote networked subscribers if configured.</p> <code>subscribe_to_killsig</code> <p>Subscribes to external kill signal of another host as master.</p>"},{"location":"api/base/broker/#hermes.base.broker.broker.Broker.__call__","title":"__call__","text":"<pre><code>__call__(duration_s: float | None = None) -&gt; None\n</code></pre> <p>The main FSM loop of the Broker.</p> <p>Runs continuously until the user ends the experiment or after the specified duration. The duration start to count only after all Nodes established communication and synced.</p> <p>Parameters:</p> Name Type Description Default <code>float | None</code> <p>Duration of data capturing/streaming. Defaults to <code>None</code>.</p> <code>None</code>"},{"location":"api/base/broker/#hermes.base.broker.broker.Broker.__call__(duration_s)","title":"<code>duration_s</code>","text":""},{"location":"api/base/broker/#hermes.base.broker.broker.Broker.__init__","title":"__init__","text":"<pre><code>__init__(\n    host_ip: str,\n    node_specs: list[dict],\n    is_ready_event: Event,\n    is_quit_event: Event,\n    is_done_event: Event,\n    is_master_broker: bool = False,\n    port_backend: str = PORT_BACKEND,\n    port_frontend: str = PORT_FRONTEND,\n    port_sync_host: str = PORT_SYNC_HOST,\n    port_sync_remote: str = PORT_SYNC_REMOTE,\n    port_killsig: str = PORT_KILL,\n) -&gt; None\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>Public LAN IP address of this host.</p> required <code>list[dict]</code> <p>List of to-be-created Node specification dictionaries.</p> required <code>Event</code> <p>Synchronization primitive to indicate to external readers that Broker is ready.</p> required <code>Event</code> <p>Synchronization primitive to externally trigger closure of Broker.</p> required <code>Event</code> <p>Synchronization primitive to indicate to external readers completion of Broker.</p> required <code>bool</code> <p>Whether this Broker is the master in the distributed host setup. Defaults to <code>False</code>.</p> <code>False</code> <code>str</code> <p>XSUB port of the Broker. Defaults to <code>PORT_BACKEND</code>.</p> <code>PORT_BACKEND</code> <code>str</code> <p>XPUB port of the Broker. Defaults to <code>PORT_FRONTEND</code>.</p> <code>PORT_FRONTEND</code> <code>str</code> <p>Port for SYNC socket to coordinate startup of local Nodes. Defaults to <code>PORT_SYNC_HOST</code>.</p> <code>PORT_SYNC_HOST</code> <code>str</code> <p>Port for SYNC socket to coordinate startup across remote hosts. Defaults to <code>PORT_SYNC_REMOTE</code>.</p> <code>PORT_SYNC_REMOTE</code> <code>str</code> <p>Port of the KILL signal this Broker announces from. Defaults to <code>PORT_KILL</code>.</p> <code>PORT_KILL</code>"},{"location":"api/base/broker/#hermes.base.broker.broker.Broker.__init__(host_ip)","title":"<code>host_ip</code>","text":""},{"location":"api/base/broker/#hermes.base.broker.broker.Broker.__init__(node_specs)","title":"<code>node_specs</code>","text":""},{"location":"api/base/broker/#hermes.base.broker.broker.Broker.__init__(is_ready_event)","title":"<code>is_ready_event</code>","text":""},{"location":"api/base/broker/#hermes.base.broker.broker.Broker.__init__(is_quit_event)","title":"<code>is_quit_event</code>","text":""},{"location":"api/base/broker/#hermes.base.broker.broker.Broker.__init__(is_done_event)","title":"<code>is_done_event</code>","text":""},{"location":"api/base/broker/#hermes.base.broker.broker.Broker.__init__(is_master_broker)","title":"<code>is_master_broker</code>","text":""},{"location":"api/base/broker/#hermes.base.broker.broker.Broker.__init__(port_backend)","title":"<code>port_backend</code>","text":""},{"location":"api/base/broker/#hermes.base.broker.broker.Broker.__init__(port_frontend)","title":"<code>port_frontend</code>","text":""},{"location":"api/base/broker/#hermes.base.broker.broker.Broker.__init__(port_sync_host)","title":"<code>port_sync_host</code>","text":""},{"location":"api/base/broker/#hermes.base.broker.broker.Broker.__init__(port_sync_remote)","title":"<code>port_sync_remote</code>","text":""},{"location":"api/base/broker/#hermes.base.broker.broker.Broker.__init__(port_killsig)","title":"<code>port_killsig</code>","text":""},{"location":"api/base/broker/#hermes.base.broker.broker.Broker._fanout_user_input","title":"_fanout_user_input","text":"<pre><code>_fanout_user_input(user_input: tuple[float, str]) -&gt; None\n</code></pre> <p>Forward user keyboard input from the main thread of the parent process, to all the subprocesses.</p> <p>Parameters:</p> Name Type Description Default <code>tuple[float, str]</code> <p>Keyboard user input from the <code>input()</code> call.</p> required"},{"location":"api/base/broker/#hermes.base.broker.broker.Broker._fanout_user_input(user_input)","title":"<code>user_input</code>","text":""},{"location":"api/base/broker/#hermes.base.broker.broker.Broker._stop","title":"_stop","text":"<pre><code>_stop() -&gt; None\n</code></pre> <p>Gracefully exit after all local subprocesses terminate, and cleanup.</p>"},{"location":"api/base/broker/#hermes.base.broker.broker.Broker.connect_to_remote_broker","title":"connect_to_remote_broker","text":"<pre><code>connect_to_remote_broker(addr: str, port_pub: str = PORT_FRONTEND) -&gt; None\n</code></pre> <p>Connects to a known address and port of external LAN data broker.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>Remote host IP to connect to as a listener.</p> required <code>str</code> <p>Port number on which remote host publishes local Nodes' data. Defaults to <code>PORT_FRONTEND</code>.</p> <code>PORT_FRONTEND</code>"},{"location":"api/base/broker/#hermes.base.broker.broker.Broker.connect_to_remote_broker(addr)","title":"<code>addr</code>","text":""},{"location":"api/base/broker/#hermes.base.broker.broker.Broker.connect_to_remote_broker(port_pub)","title":"<code>port_pub</code>","text":""},{"location":"api/base/broker/#hermes.base.broker.broker.Broker.expose_to_remote_broker","title":"expose_to_remote_broker","text":"<pre><code>expose_to_remote_broker(addr: list[str]) -&gt; None\n</code></pre> <p>Exposes a known address and port to remote networked subscribers if configured.</p> <p>Parameters:</p> Name Type Description Default <code>list[str]</code> <p>List of IP addresses of remote hosts (other Brokers).</p> required"},{"location":"api/base/broker/#hermes.base.broker.broker.Broker.expose_to_remote_broker(addr)","title":"<code>addr</code>","text":""},{"location":"api/base/broker/#hermes.base.broker.broker.Broker.subscribe_to_killsig","title":"subscribe_to_killsig","text":"<pre><code>subscribe_to_killsig(addr: str, port_killsig: str = PORT_KILL) -&gt; None\n</code></pre> <p>Subscribes to external kill signal of another host as master.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>IP address of the master Broker in a distributed setting.</p> required <code>str</code> <p>Port of the remote Broker to listen to for the termination signal. Defaults to <code>PORT_KILL</code>.</p> <code>PORT_KILL</code>"},{"location":"api/base/broker/#hermes.base.broker.broker.Broker.subscribe_to_killsig(addr)","title":"<code>addr</code>","text":""},{"location":"api/base/broker/#hermes.base.broker.broker.Broker.subscribe_to_killsig(port_killsig)","title":"<code>port_killsig</code>","text":""},{"location":"api/base/broker/#hermes.base.broker.broker_states","title":"broker_states","text":"<p>Classes:</p> Name Description <code>AbstractBrokerState</code> <p>Abstract class for the Broker FSM.</p> <code>InitState</code> <p>Initialization state of the Broker to launch local Nodes.</p> <code>JoinBrokerBarrierState</code> <p>Waits until all remote Brokers, if any, have their local Nodes gracefully terminated.</p> <code>JoinNodeBarrierState</code> <p>Waits until all local Nodes send final packets then quits itself.</p> <code>KillState</code> <p>Received 1 of 3 possible KILL signals to terminate.</p> <code>RunningState</code> <p>Stead-state capturing or streaming state of the Broker.</p> <code>StartState</code> <p>Start state of the Broker that waits or initiates distributed launch.</p> <code>SyncBrokerBarrierState</code> <p>Synchronization state of the Broker that waits until all remote Brokers setup.</p> <code>SyncNodeBarrierState</code> <p>Synchronization state of the Broker that waits until all local Nodes setup.</p>"},{"location":"api/base/broker/#hermes.base.broker.broker_states.AbstractBrokerState","title":"AbstractBrokerState","text":"<p>               Bases: <code>StateInterface</code></p> <pre><code>\n              flowchart TD\n              hermes.base.broker.broker_states.AbstractBrokerState[AbstractBrokerState]\n              hermes.base.state_interface.StateInterface[StateInterface]\n\n                              hermes.base.state_interface.StateInterface --&gt; hermes.base.broker.broker_states.AbstractBrokerState\n                \n\n\n              click hermes.base.broker.broker_states.AbstractBrokerState href \"\" \"hermes.base.broker.broker_states.AbstractBrokerState\"\n              click hermes.base.state_interface.StateInterface href \"\" \"hermes.base.state_interface.StateInterface\"\n            </code></pre> <p>Abstract class for the Broker FSM.</p> <p>Can be externally triggered into the KILL state from any child State class.</p> <p>Methods:</p> Name Description <code>__init__</code> <p>Constructor of the AbstractBrokerState class.</p> <code>run</code> <p>Run the logic of the currently selected state.</p>"},{"location":"api/base/broker/#hermes.base.broker.broker_states.AbstractBrokerState.__init__","title":"__init__","text":"<pre><code>__init__(context: BrokerInterface)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>BrokerInterface</code> <p>Reference to the Broker object.</p> required"},{"location":"api/base/broker/#hermes.base.broker.broker_states.AbstractBrokerState.__init__(context)","title":"<code>context</code>","text":""},{"location":"api/base/broker/#hermes.base.broker.broker_states.AbstractBrokerState.run","title":"run  <code>abstractmethod</code>","text":"<pre><code>run() -&gt; None\n</code></pre> <p>Run the logic of the currently selected state.</p>"},{"location":"api/base/broker/#hermes.base.broker.broker_states.InitState","title":"InitState","text":"<p>               Bases: <code>AbstractBrokerState</code></p> <pre><code>\n              flowchart TD\n              hermes.base.broker.broker_states.InitState[InitState]\n              hermes.base.broker.broker_states.AbstractBrokerState[AbstractBrokerState]\n              hermes.base.state_interface.StateInterface[StateInterface]\n\n                              hermes.base.broker.broker_states.AbstractBrokerState --&gt; hermes.base.broker.broker_states.InitState\n                                hermes.base.state_interface.StateInterface --&gt; hermes.base.broker.broker_states.AbstractBrokerState\n                \n\n\n\n              click hermes.base.broker.broker_states.InitState href \"\" \"hermes.base.broker.broker_states.InitState\"\n              click hermes.base.broker.broker_states.AbstractBrokerState href \"\" \"hermes.base.broker.broker_states.AbstractBrokerState\"\n              click hermes.base.state_interface.StateInterface href \"\" \"hermes.base.state_interface.StateInterface\"\n            </code></pre> <p>Initialization state of the Broker to launch local Nodes.</p> <p>Activates broker poller sockets and goes in sync to wait for local Nodes to start up.</p> <p>Methods:</p> Name Description <code>__init__</code> <p>Constructor of the AbstractBrokerState class.</p>"},{"location":"api/base/broker/#hermes.base.broker.broker_states.InitState.__init__","title":"__init__","text":"<pre><code>__init__(context: BrokerInterface)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>BrokerInterface</code> <p>Reference to the Broker object.</p> required"},{"location":"api/base/broker/#hermes.base.broker.broker_states.InitState.__init__(context)","title":"<code>context</code>","text":""},{"location":"api/base/broker/#hermes.base.broker.broker_states.JoinBrokerBarrierState","title":"JoinBrokerBarrierState","text":"<p>               Bases: <code>AbstractBrokerState</code></p> <pre><code>\n              flowchart TD\n              hermes.base.broker.broker_states.JoinBrokerBarrierState[JoinBrokerBarrierState]\n              hermes.base.broker.broker_states.AbstractBrokerState[AbstractBrokerState]\n              hermes.base.state_interface.StateInterface[StateInterface]\n\n                              hermes.base.broker.broker_states.AbstractBrokerState --&gt; hermes.base.broker.broker_states.JoinBrokerBarrierState\n                                hermes.base.state_interface.StateInterface --&gt; hermes.base.broker.broker_states.AbstractBrokerState\n                \n\n\n\n              click hermes.base.broker.broker_states.JoinBrokerBarrierState href \"\" \"hermes.base.broker.broker_states.JoinBrokerBarrierState\"\n              click hermes.base.broker.broker_states.AbstractBrokerState href \"\" \"hermes.base.broker.broker_states.AbstractBrokerState\"\n              click hermes.base.state_interface.StateInterface href \"\" \"hermes.base.state_interface.StateInterface\"\n            </code></pre> <p>Waits until all remote Brokers, if any, have their local Nodes gracefully terminated.</p> <p>Wait for all dependent remote Brokers to send the acknowledgement messages that they no longer dependend on this Broker's data.</p> <p>Continue brokering packets until signalled by all remote hosts that there will be no more packets. Use the remote SYNC socket to coordinate when every Broker can exit.</p>"},{"location":"api/base/broker/#hermes.base.broker.broker_states.JoinNodeBarrierState","title":"JoinNodeBarrierState","text":"<p>               Bases: <code>AbstractBrokerState</code></p> <pre><code>\n              flowchart TD\n              hermes.base.broker.broker_states.JoinNodeBarrierState[JoinNodeBarrierState]\n              hermes.base.broker.broker_states.AbstractBrokerState[AbstractBrokerState]\n              hermes.base.state_interface.StateInterface[StateInterface]\n\n                              hermes.base.broker.broker_states.AbstractBrokerState --&gt; hermes.base.broker.broker_states.JoinNodeBarrierState\n                                hermes.base.state_interface.StateInterface --&gt; hermes.base.broker.broker_states.AbstractBrokerState\n                \n\n\n\n              click hermes.base.broker.broker_states.JoinNodeBarrierState href \"\" \"hermes.base.broker.broker_states.JoinNodeBarrierState\"\n              click hermes.base.broker.broker_states.AbstractBrokerState href \"\" \"hermes.base.broker.broker_states.AbstractBrokerState\"\n              click hermes.base.state_interface.StateInterface href \"\" \"hermes.base.state_interface.StateInterface\"\n            </code></pre> <p>Waits until all local Nodes send final packets then quits itself.</p> <p>Wait for all processes (local and remote) to send the last messages before closing. Continue brokering packets until signalled by all publishers that there will be no more packets. Append a frame to the ZeroMQ message that indicates the last message from the sensor.</p>"},{"location":"api/base/broker/#hermes.base.broker.broker_states.JoinNodeBarrierState._check_host_sync_socket","title":"_check_host_sync_socket","text":"<pre><code>_check_host_sync_socket(poll_res: ZMQResult) -&gt; None\n</code></pre> <p>Check if a local Node sent a request on the SYNC socket to indicate its closure.</p> <p>Can be triggered by all local Nodes: Producer, Consumer, or Pipeline, sending 'EXIT?' request.</p>"},{"location":"api/base/broker/#hermes.base.broker.broker_states.JoinNodeBarrierState._is_finished","title":"_is_finished","text":"<pre><code>_is_finished() -&gt; bool\n</code></pre> <p>Convenience method indicating if any local Nodes remain active.</p> <p>Will wait until all local Nodes finish.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Whether all local Nodes gracefully terminated.</p>"},{"location":"api/base/broker/#hermes.base.broker.broker_states.JoinNodeBarrierState._on_is_end_packet","title":"_on_is_end_packet","text":"<pre><code>_on_is_end_packet(msg: list[bytes]) -&gt; None\n</code></pre> <p>Callback to track brokering of last packets of local Producers and Pipelines.</p> <p>Will get trigerred at most once per Node because publishing Nodes send it only once.</p>"},{"location":"api/base/broker/#hermes.base.broker.broker_states.JoinNodeBarrierState._release_local_node","title":"_release_local_node","text":"<pre><code>_release_local_node(topic: str) -&gt; None\n</code></pre> <p>Release the local Node from the list of active Nodes of the Broker.</p>"},{"location":"api/base/broker/#hermes.base.broker.broker_states.KillState","title":"KillState","text":"<p>               Bases: <code>AbstractBrokerState</code></p> <pre><code>\n              flowchart TD\n              hermes.base.broker.broker_states.KillState[KillState]\n              hermes.base.broker.broker_states.AbstractBrokerState[AbstractBrokerState]\n              hermes.base.state_interface.StateInterface[StateInterface]\n\n                              hermes.base.broker.broker_states.AbstractBrokerState --&gt; hermes.base.broker.broker_states.KillState\n                                hermes.base.state_interface.StateInterface --&gt; hermes.base.broker.broker_states.AbstractBrokerState\n                \n\n\n\n              click hermes.base.broker.broker_states.KillState href \"\" \"hermes.base.broker.broker_states.KillState\"\n              click hermes.base.broker.broker_states.AbstractBrokerState href \"\" \"hermes.base.broker.broker_states.AbstractBrokerState\"\n              click hermes.base.state_interface.StateInterface href \"\" \"hermes.base.state_interface.StateInterface\"\n            </code></pre> <p>Received 1 of 3 possible KILL signals to terminate.</p> <p>Relay it to all Nodes and Brokers and wrap up gracefully.     from the local Keyboard Interrupt;     from the Master Broker;     from the GUI;</p> <p>Methods:</p> Name Description <code>__init__</code> <p>Constructor of the AbstractBrokerState class.</p>"},{"location":"api/base/broker/#hermes.base.broker.broker_states.KillState.__init__","title":"__init__","text":"<pre><code>__init__(context: BrokerInterface)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>BrokerInterface</code> <p>Reference to the Broker object.</p> required"},{"location":"api/base/broker/#hermes.base.broker.broker_states.KillState.__init__(context)","title":"<code>context</code>","text":""},{"location":"api/base/broker/#hermes.base.broker.broker_states.RunningState","title":"RunningState","text":"<p>               Bases: <code>AbstractBrokerState</code></p> <pre><code>\n              flowchart TD\n              hermes.base.broker.broker_states.RunningState[RunningState]\n              hermes.base.broker.broker_states.AbstractBrokerState[AbstractBrokerState]\n              hermes.base.state_interface.StateInterface[StateInterface]\n\n                              hermes.base.broker.broker_states.AbstractBrokerState --&gt; hermes.base.broker.broker_states.RunningState\n                                hermes.base.state_interface.StateInterface --&gt; hermes.base.broker.broker_states.AbstractBrokerState\n                \n\n\n\n              click hermes.base.broker.broker_states.RunningState href \"\" \"hermes.base.broker.broker_states.RunningState\"\n              click hermes.base.broker.broker_states.AbstractBrokerState href \"\" \"hermes.base.broker.broker_states.AbstractBrokerState\"\n              click hermes.base.state_interface.StateInterface href \"\" \"hermes.base.state_interface.StateInterface\"\n            </code></pre> <p>Stead-state capturing or streaming state of the Broker.</p> <p>Will run until the the experiment is stopped or after a fixed period, if provided.</p>"},{"location":"api/base/broker/#hermes.base.broker.broker_states.RunningState._on_subscription_added","title":"_on_subscription_added","text":"<pre><code>_on_subscription_added(msg: list[bytes]) -&gt; None\n</code></pre> <p>Update a list on the Broker that keeps track of which Nodes are being brokered for.</p>"},{"location":"api/base/broker/#hermes.base.broker.broker_states.StartState","title":"StartState","text":"<p>               Bases: <code>AbstractBrokerState</code></p> <pre><code>\n              flowchart TD\n              hermes.base.broker.broker_states.StartState[StartState]\n              hermes.base.broker.broker_states.AbstractBrokerState[AbstractBrokerState]\n              hermes.base.state_interface.StateInterface[StateInterface]\n\n                              hermes.base.broker.broker_states.AbstractBrokerState --&gt; hermes.base.broker.broker_states.StartState\n                                hermes.base.state_interface.StateInterface --&gt; hermes.base.broker.broker_states.AbstractBrokerState\n                \n\n\n\n              click hermes.base.broker.broker_states.StartState href \"\" \"hermes.base.broker.broker_states.StartState\"\n              click hermes.base.broker.broker_states.AbstractBrokerState href \"\" \"hermes.base.broker.broker_states.AbstractBrokerState\"\n              click hermes.base.state_interface.StateInterface href \"\" \"hermes.base.state_interface.StateInterface\"\n            </code></pre> <p>Start state of the Broker that waits or initiates distributed launch.</p> <p>Trigger local Nodes to start logging when the agreed start time arrives.</p> <p>Methods:</p> Name Description <code>__init__</code> <p>Constructor of the AbstractBrokerState class.</p>"},{"location":"api/base/broker/#hermes.base.broker.broker_states.StartState.__init__","title":"__init__","text":"<pre><code>__init__(context: BrokerInterface)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>BrokerInterface</code> <p>Reference to the Broker object.</p> required"},{"location":"api/base/broker/#hermes.base.broker.broker_states.StartState.__init__(context)","title":"<code>context</code>","text":""},{"location":"api/base/broker/#hermes.base.broker.broker_states.SyncBrokerBarrierState","title":"SyncBrokerBarrierState","text":"<p>               Bases: <code>AbstractBrokerState</code></p> <pre><code>\n              flowchart TD\n              hermes.base.broker.broker_states.SyncBrokerBarrierState[SyncBrokerBarrierState]\n              hermes.base.broker.broker_states.AbstractBrokerState[AbstractBrokerState]\n              hermes.base.state_interface.StateInterface[StateInterface]\n\n                              hermes.base.broker.broker_states.AbstractBrokerState --&gt; hermes.base.broker.broker_states.SyncBrokerBarrierState\n                                hermes.base.state_interface.StateInterface --&gt; hermes.base.broker.broker_states.AbstractBrokerState\n                \n\n\n\n              click hermes.base.broker.broker_states.SyncBrokerBarrierState href \"\" \"hermes.base.broker.broker_states.SyncBrokerBarrierState\"\n              click hermes.base.broker.broker_states.AbstractBrokerState href \"\" \"hermes.base.broker.broker_states.AbstractBrokerState\"\n              click hermes.base.state_interface.StateInterface href \"\" \"hermes.base.state_interface.StateInterface\"\n            </code></pre> <p>Synchronization state of the Broker that waits until all remote Brokers setup.</p> <p>Communicate to other Brokers that every local device is ready.</p>"},{"location":"api/base/broker/#hermes.base.broker.broker_states.SyncNodeBarrierState","title":"SyncNodeBarrierState","text":"<p>               Bases: <code>AbstractBrokerState</code></p> <pre><code>\n              flowchart TD\n              hermes.base.broker.broker_states.SyncNodeBarrierState[SyncNodeBarrierState]\n              hermes.base.broker.broker_states.AbstractBrokerState[AbstractBrokerState]\n              hermes.base.state_interface.StateInterface[StateInterface]\n\n                              hermes.base.broker.broker_states.AbstractBrokerState --&gt; hermes.base.broker.broker_states.SyncNodeBarrierState\n                                hermes.base.state_interface.StateInterface --&gt; hermes.base.broker.broker_states.AbstractBrokerState\n                \n\n\n\n              click hermes.base.broker.broker_states.SyncNodeBarrierState href \"\" \"hermes.base.broker.broker_states.SyncNodeBarrierState\"\n              click hermes.base.broker.broker_states.AbstractBrokerState href \"\" \"hermes.base.broker.broker_states.AbstractBrokerState\"\n              click hermes.base.state_interface.StateInterface href \"\" \"hermes.base.state_interface.StateInterface\"\n            </code></pre> <p>Synchronization state of the Broker that waits until all local Nodes setup.</p> <p>Waits until all local Nodes signalled that they are initialized and ready to go.</p> <p>Methods:</p> Name Description <code>__init__</code> <p>Constructor of the AbstractBrokerState class.</p>"},{"location":"api/base/broker/#hermes.base.broker.broker_states.SyncNodeBarrierState.__init__","title":"__init__","text":"<pre><code>__init__(context: BrokerInterface)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>BrokerInterface</code> <p>Reference to the Broker object.</p> required"},{"location":"api/base/broker/#hermes.base.broker.broker_states.SyncNodeBarrierState.__init__(context)","title":"<code>context</code>","text":""},{"location":"api/base/delay_estimator/","title":"hermes.base.delay_estimator","text":"<p>The module exposes a hook for user-defined device-specific estimation of the propagation delay of a Stream (e.g. from an interfaced sensor), and lives inside a Node.</p> <p>User provides a callback function and sets corresponding parameters in the configuration of the Node.</p>"},{"location":"api/base/delay_estimator/#hermes.base.delay_estimator","title":"delay_estimator","text":"<p>Classes:</p> Name Description <code>DelayEstimator</code> <p>Functional callable class for periodic device-specific propagation delay estimation.</p>"},{"location":"api/base/delay_estimator/#hermes.base.delay_estimator.DelayEstimator","title":"DelayEstimator","text":"<p>Functional callable class for periodic device-specific propagation delay estimation.</p> <p>Methods:</p> Name Description <code>__call__</code> <p>Callable that runs periodic propagation delay estimation.</p> <code>__init__</code> <p>Constructor of the DelayEstimator component for propagation delay estimation.</p> <code>cleanup</code> <p>Method for external trigger to terminate the delay estimator.</p>"},{"location":"api/base/delay_estimator/#hermes.base.delay_estimator.DelayEstimator.__call__","title":"__call__","text":"<pre><code>__call__(ping_fn: Callable, publish_fn: Callable)\n</code></pre> <p>Callable that runs periodic propagation delay estimation.</p> <p>Uses user-passed estimation and callback functions until termination.</p> <p>Parameters:</p> Name Type Description Default <code>Callable</code> <p>Propagation delay estimation function pointer.</p> required <code>Callable</code> <p>Callback function pointer.</p> required"},{"location":"api/base/delay_estimator/#hermes.base.delay_estimator.DelayEstimator.__call__(ping_fn)","title":"<code>ping_fn</code>","text":""},{"location":"api/base/delay_estimator/#hermes.base.delay_estimator.DelayEstimator.__call__(publish_fn)","title":"<code>publish_fn</code>","text":""},{"location":"api/base/delay_estimator/#hermes.base.delay_estimator.DelayEstimator.__init__","title":"__init__","text":"<pre><code>__init__(sample_period_s: float)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>float</code> <p>Duration of periods over which to estimate propagation delay.</p> required"},{"location":"api/base/delay_estimator/#hermes.base.delay_estimator.DelayEstimator.__init__(sample_period_s)","title":"<code>sample_period_s</code>","text":""},{"location":"api/base/delay_estimator/#hermes.base.delay_estimator.DelayEstimator.cleanup","title":"cleanup","text":"<pre><code>cleanup()\n</code></pre> <p>Method for external trigger to terminate the delay estimator.</p>"},{"location":"api/base/storage/","title":"hermes.base.storage","text":"<p>The module is responsible for high-performance asynchronous file IO.  It periodically spins up coroutines to offset long IO operations with concurrent writes of different files.</p> <p><code>storage_interface</code> - base interface for Storage function.</p> <p><code>storage</code> - concrete FSM-based Storage with streaming and dumping features.</p> <p><code>storage_states</code> - FSM states of the Storage.</p>"},{"location":"api/base/storage/#hermes.base.storage.storage_interface","title":"storage_interface","text":"<p>Classes:</p> Name Description <code>StorageInterface</code> <p>Interface for the AsyncIO Storage component.</p>"},{"location":"api/base/storage/#hermes.base.storage.storage_interface.StorageInterface","title":"StorageInterface","text":"<p>               Bases: <code>ABC</code></p> <pre><code>\n              flowchart TD\n              hermes.base.storage.storage_interface.StorageInterface[StorageInterface]\n\n              \n\n              click hermes.base.storage.storage_interface.StorageInterface href \"\" \"hermes.base.storage.storage_interface.StorageInterface\"\n            </code></pre> <p>Interface for the AsyncIO Storage component.</p>"},{"location":"api/base/storage/#hermes.base.storage.storage_interface.StorageInterface._initialize","title":"_initialize  <code>abstractmethod</code>","text":"<pre><code>_initialize(streams: OrderedDict[str, Stream]) -&gt; None\n</code></pre> <p>Initializes files and indices for write pointer tracking.</p> <p>Parameters:</p> Name Type Description Default <code>OrderedDict[str, Stream]</code> <p>Reference to the Stream objects to flush to disk.</p> required"},{"location":"api/base/storage/#hermes.base.storage.storage_interface.StorageInterface._initialize(streams)","title":"<code>streams</code>","text":""},{"location":"api/base/storage/#hermes.base.storage.storage_interface.StorageInterface._is_to_dump","title":"_is_to_dump  <code>abstractmethod</code>","text":"<pre><code>_is_to_dump() -&gt; bool\n</code></pre> <p>Check if any streams were configured to record.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Whether there are any streams configured to dump record data.</p>"},{"location":"api/base/storage/#hermes.base.storage.storage_interface.StorageInterface._is_to_stream","title":"_is_to_stream  <code>abstractmethod</code>","text":"<pre><code>_is_to_stream() -&gt; bool\n</code></pre> <p>Check if any streams were configured to stream.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Whether there are any streams configured to stream data.</p>"},{"location":"api/base/storage/#hermes.base.storage.storage_interface.StorageInterface._log_data","title":"_log_data  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>_log_data() -&gt; None\n</code></pre> <p>Main AsyncIO loop for Storage to write files concurrentlyto disk.</p>"},{"location":"api/base/storage/#hermes.base.storage.storage_interface.StorageInterface._release_thread_pool","title":"_release_thread_pool  <code>abstractmethod</code>","text":"<pre><code>_release_thread_pool() -&gt; None\n</code></pre> <p>Trigger release of AsyncIO resources used for writing files.</p>"},{"location":"api/base/storage/#hermes.base.storage.storage_interface.StorageInterface._set_state","title":"_set_state  <code>abstractmethod</code>","text":"<pre><code>_set_state(state) -&gt; None\n</code></pre> <p>User defined logic for FSM state transition.</p> <p>Parameters:</p> Name Type Description Default <code>Any</code> <p>New state to transition to.</p> required"},{"location":"api/base/storage/#hermes.base.storage.storage_interface.StorageInterface._set_state(state)","title":"<code>state</code>","text":""},{"location":"api/base/storage/#hermes.base.storage.storage_interface.StorageInterface._start_dump_logging","title":"_start_dump_logging  <code>abstractmethod</code>","text":"<pre><code>_start_dump_logging() -&gt; None\n</code></pre> <p>Initialize passive recording until terminated to dump data once.</p>"},{"location":"api/base/storage/#hermes.base.storage.storage_interface.StorageInterface._start_stream_logging","title":"_start_stream_logging  <code>abstractmethod</code>","text":"<pre><code>_start_stream_logging() -&gt; None\n</code></pre> <p>Set up AV/HDF5 file writers for stream-logging, if desired.</p>"},{"location":"api/base/storage/#hermes.base.storage.storage_interface.StorageInterface._stop_stream_logging","title":"_stop_stream_logging  <code>abstractmethod</code>","text":"<pre><code>_stop_stream_logging() -&gt; None\n</code></pre> <p>Trigger termination and flushing of accumulated streamed data.</p> <p>Will wait for the thread to finish before returning.</p>"},{"location":"api/base/storage/#hermes.base.storage.storage_interface.StorageInterface._wait_till_flush","title":"_wait_till_flush  <code>abstractmethod</code>","text":"<pre><code>_wait_till_flush() -&gt; None\n</code></pre> <p>Sleep until the Storage is triggered to terminate after flushing.</p>"},{"location":"api/base/storage/#hermes.base.storage.storage","title":"storage","text":"<p>Classes:</p> Name Description <code>Storage</code> <p>Manages IO operations of all stream data.</p>"},{"location":"api/base/storage/#hermes.base.storage.storage.Storage","title":"Storage","text":"<p>               Bases: <code>StorageInterface</code></p> <pre><code>\n              flowchart TD\n              hermes.base.storage.storage.Storage[Storage]\n              hermes.base.storage.storage_interface.StorageInterface[StorageInterface]\n\n                              hermes.base.storage.storage_interface.StorageInterface --&gt; hermes.base.storage.storage.Storage\n                \n\n\n              click hermes.base.storage.storage.Storage href \"\" \"hermes.base.storage.storage.Storage\"\n              click hermes.base.storage.storage_interface.StorageInterface href \"\" \"hermes.base.storage.storage_interface.StorageInterface\"\n            </code></pre> <p>Manages IO operations of all stream data.</p> <p>Flushes data periodically for continuous operation and clears from memory to reduce RAM usage, or all at once if user guarantees enough memory. In continuous mode, will flush leftover data once the program is stopped.</p> <p>Logs video and audio data with FFmpeg to MKV/MP4 and MP3, respectively. Logs all other sensor data in a single hierarchical HDF5 file. CSV format is also supported, but discouraged -&gt; creates file per sub-stream.</p> <p>If sub-stream elements contain a burst of samples of sample_size, will automatically unroll it.</p> <p>Will fail if no FFmpeg is installed on the system.</p> <p>Methods:</p> Name Description <code>__call__</code> <p>Callable that runs main FSM loop.</p> <code>__init__</code> <p>Constructor of the Storage component responsible for all IO.</p> <code>cleanup</code> <p>Stop stream-logging and wait for it to finish.</p>"},{"location":"api/base/storage/#hermes.base.storage.storage.Storage.__call__","title":"__call__","text":"<pre><code>__call__(streams: OrderedDict[str, Stream]) -&gt; None\n</code></pre> <p>Callable that runs main FSM loop.</p> <p>Runs continuously, ignoring Ctrl+C interrupt, until owner Node triggers an exit.</p> <p>Parameters:</p> Name Type Description Default <code>OrderedDict[str, Stream]</code> <p>Reference to the Stream objects to flush to disk.</p> required"},{"location":"api/base/storage/#hermes.base.storage.storage.Storage.__call__(streams)","title":"<code>streams</code>","text":""},{"location":"api/base/storage/#hermes.base.storage.storage.Storage.__init__","title":"__init__","text":"<pre><code>__init__(log_tag: str, spec: LoggingSpec)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>Filename prefix.</p> required <code>LoggingSpec</code> <p>Specifies what and how to store to disk.</p> required"},{"location":"api/base/storage/#hermes.base.storage.storage.Storage.__init__(log_tag)","title":"<code>log_tag</code>","text":""},{"location":"api/base/storage/#hermes.base.storage.storage.Storage.__init__(spec)","title":"<code>spec</code>","text":""},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._close_files","title":"_close_files","text":"<pre><code>_close_files() -&gt; None\n</code></pre> <p>Convenience method to close all files writers.</p>"},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._close_files_audio","title":"_close_files_audio","text":"<pre><code>_close_files_audio() -&gt; None\n</code></pre> <p>Flush/close the audio file writers.</p>"},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._close_files_csv","title":"_close_files_csv","text":"<pre><code>_close_files_csv() -&gt; None\n</code></pre> <p>Flush/close the CSV file writers.</p>"},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._close_files_hdf5","title":"_close_files_hdf5","text":"<pre><code>_close_files_hdf5() -&gt; None\n</code></pre> <p>Flush/close the HDF5 file writer.</p> <p>Resizes datasets to remove extra empty rows.</p>"},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._close_files_video","title":"_close_files_video","text":"<pre><code>_close_files_video() -&gt; None\n</code></pre> <p>Flush/close the video files writers.</p>"},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._init_files_audio","title":"_init_files_audio","text":"<pre><code>_init_files_audio() -&gt; int\n</code></pre> <p>[Not implemented] Create and initialize audio writers, one for each device.</p> <p>TODO: implement audio streaming info on the Stream object.</p> <p>Will fail if no FFmpeg installed.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>When no supported codec specification was provided in config file.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of initialized writers.</p>"},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._init_files_csv","title":"_init_files_csv","text":"<pre><code>_init_files_csv() -&gt; int\n</code></pre> <p>Create and initialize CSV files.</p> <p>Will have a separate file for each stream of each device. Currently assumes that device names are unique across all streamers.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of initialized writers.</p>"},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._init_files_hdf5","title":"_init_files_hdf5","text":"<pre><code>_init_files_hdf5() -&gt; int\n</code></pre> <p>Create and initialize a hierarchical HDF5 file.</p> <p>Will have a single file for all streams from all devices. Currently assumes that device names are unique across all streamers.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of initialized writers.</p>"},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._init_files_video","title":"_init_files_video","text":"<pre><code>_init_files_video() -&gt; int\n</code></pre> <p>Create and initialize video writers, one for each device.</p> <p>Will fail if no FFmpeg installed.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>When no supported codec specification was provided in config file.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of initialized writers.</p>"},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._init_log_indices","title":"_init_log_indices","text":"<pre><code>_init_log_indices() -&gt; None\n</code></pre> <p>Initialize the data indices to fetch for logging</p> <p>Will record the next data indices that should be fetched for each stream, and the number of timesteps that each streamer needs before data is solidified.</p>"},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._log_data","title":"_log_data  <code>async</code>","text":"<pre><code>_log_data() -&gt; None\n</code></pre> <p>Trigger release of AsyncIO resources used for writing files.</p> <p>Polls data from each Node periodically or all at once.</p> <p>The poll period is set by self._stream_period_s.</p> <p>Will loop until self._is_streaming is False, and then will do one final fetch/log if self._is_flush is True.</p> <p>Assert self._is_streaming and deassert self._is_flush for streaming.     To finish, deassert self._is_streaming to False and assert self._is_flush.</p> <p>Deassert self._is_streaming and assert self._is_flush to dump record.     The thread will be inactive until terminated.     User is responsible to provision sufficient memory.</p>"},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._log_metadata","title":"_log_metadata","text":"<pre><code>_log_metadata()\n</code></pre> <p>Convenience method to add metadata to all file types.</p> <p>Will include device-level metadata and any lower-level data notes.</p>"},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._log_metadata_audio","title":"_log_metadata_audio","text":"<pre><code>_log_metadata_audio() -&gt; None\n</code></pre> <p>Add experiment metadata on the audio files.</p> <p>Dummy method, metadata is written on instantiation.</p>"},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._log_metadata_csv","title":"_log_metadata_csv","text":"<pre><code>_log_metadata_csv() -&gt; None\n</code></pre> <p>Add experiment metadata on the CSV files.</p> <p>TODO: validate logic.</p>"},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._log_metadata_hdf5","title":"_log_metadata_hdf5","text":"<pre><code>_log_metadata_hdf5() -&gt; None\n</code></pre> <p>Add experiment metadata on the HDF5 file.</p>"},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._log_metadata_video","title":"_log_metadata_video","text":"<pre><code>_log_metadata_video() -&gt; None\n</code></pre> <p>Add experiment metadata on the video files.</p> <p>Dummy method, metadata is written on instantiation.</p>"},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._sync_write_audio","title":"_sync_write_audio","text":"<pre><code>_sync_write_audio(\n    audio_writer: Popen, node_name: str, device_name: str, stream_name: str\n)\n</code></pre> <p>Write provided data to the audio files.</p> <p>Can be called during streaming (periodic writing) and post-experiment dumping.</p> <p>Parameters:</p> Name Type Description Default <code>Popen</code> <p>FFmpeg writer corresponding to the audio.</p> required <code>str</code> <p>Valid unique tag of the Node owning the data.</p> required <code>str</code> <p>Valid device tree name.</p> required <code>str</code> <p>Valid sub-stream name.</p> required"},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._sync_write_audio(audio_writer)","title":"<code>audio_writer</code>","text":""},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._sync_write_audio(node_name)","title":"<code>node_name</code>","text":""},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._sync_write_audio(device_name)","title":"<code>device_name</code>","text":""},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._sync_write_audio(stream_name)","title":"<code>stream_name</code>","text":""},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._sync_write_csv","title":"_sync_write_csv","text":"<pre><code>_sync_write_csv(\n    csv_writer: TextIOWrapper, node_name: str, device_name: str, stream_name: str\n) -&gt; None\n</code></pre> <p>Write provided data to the CSV file.</p> <p>Can be called during streaming (periodic writing) and post-experiment dumping.</p> <p>Parameters:</p> Name Type Description Default <code>TextIOWrapper</code> <p>Text file writer corresponding to the stream.</p> required <code>str</code> <p>Valid unique tag of the Node owning the data.</p> required <code>str</code> <p>Valid device tree name.</p> required <code>str</code> <p>Valid sub-stream name.</p> required"},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._sync_write_csv(csv_writer)","title":"<code>csv_writer</code>","text":""},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._sync_write_csv(node_name)","title":"<code>node_name</code>","text":""},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._sync_write_csv(device_name)","title":"<code>device_name</code>","text":""},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._sync_write_csv(stream_name)","title":"<code>stream_name</code>","text":""},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._sync_write_hdf5","title":"_sync_write_hdf5","text":"<pre><code>_sync_write_hdf5(node_name: str, device_name: str, stream_name: str) -&gt; None\n</code></pre> <p>Write provided data to the HDF5 file.</p> <p>Can be called during streaming (periodic writing) and post-experiment dumping.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>Valid unique tag of the Node owning the data.</p> required <code>str</code> <p>Valid device tree name.</p> required <code>str</code> <p>Valid sub-stream name.</p> required"},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._sync_write_hdf5(node_name)","title":"<code>node_name</code>","text":""},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._sync_write_hdf5(device_name)","title":"<code>device_name</code>","text":""},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._sync_write_hdf5(stream_name)","title":"<code>stream_name</code>","text":""},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._sync_write_video","title":"_sync_write_video","text":"<pre><code>_sync_write_video(\n    video_writer: Popen, node_name: str, device_name: str, stream_name: str\n)\n</code></pre> <p>Write provided data to the video files.</p> <p>Can be called during streaming (periodic writing) and post-experiment dumping.</p> <p>Parameters:</p> Name Type Description Default <code>Popen</code> <p>FFmpeg writer corresponding to the video.</p> required <code>str</code> <p>Valid unique tag of the Node owning the data.</p> required <code>str</code> <p>Valid device tree name.</p> required <code>str</code> <p>Valid sub-stream name.</p> required"},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._sync_write_video(video_writer)","title":"<code>video_writer</code>","text":""},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._sync_write_video(node_name)","title":"<code>node_name</code>","text":""},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._sync_write_video(device_name)","title":"<code>device_name</code>","text":""},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._sync_write_video(stream_name)","title":"<code>stream_name</code>","text":""},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._write_audio","title":"_write_audio  <code>async</code>","text":"<pre><code>_write_audio(audio_writer: Popen, node_name: str, device_name: str, stream_name: str)\n</code></pre> <p>Coroutine asynchronous wrapper for multiple audio streams.</p> <p>Wraps synchronous IO of each video file into an asynchronous pool of coroutines.</p> <p>Parameters:</p> Name Type Description Default <code>Popen</code> <p>FFmpeg writer corresponding to the audio.</p> required <code>str</code> <p>Valid unique tag of the Node owning the data.</p> required <code>str</code> <p>Valid device tree name.</p> required <code>str</code> <p>Valid sub-stream name.</p> required"},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._write_audio(audio_writer)","title":"<code>audio_writer</code>","text":""},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._write_audio(node_name)","title":"<code>node_name</code>","text":""},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._write_audio(device_name)","title":"<code>device_name</code>","text":""},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._write_audio(stream_name)","title":"<code>stream_name</code>","text":""},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._write_csv","title":"_write_csv  <code>async</code>","text":"<pre><code>_write_csv(\n    csv_writer: TextIOWrapper, node_name: str, device_name: str, stream_name: str\n)\n</code></pre> <p>Coroutine asynchronous wrapper for multiple CSV streams.</p> <p>Wraps synchronous IO of each CSV file into an asynchronous pool of coroutines.</p> <p>Parameters:</p> Name Type Description Default <code>TextIOWrapper</code> <p>Text file writer corresponding to the stream.</p> required <code>str</code> <p>Valid unique tag of the Node owning the data.</p> required <code>str</code> <p>Valid device tree name.</p> required <code>str</code> <p>Valid sub-stream name.</p> required"},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._write_csv(csv_writer)","title":"<code>csv_writer</code>","text":""},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._write_csv(node_name)","title":"<code>node_name</code>","text":""},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._write_csv(device_name)","title":"<code>device_name</code>","text":""},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._write_csv(stream_name)","title":"<code>stream_name</code>","text":""},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._write_files_audio","title":"_write_files_audio  <code>async</code>","text":"<pre><code>_write_files_audio()\n</code></pre> <p>Convenience method to asynchronously write all audio data to files.</p> <p>Will launch coroutine concurrently with other IO writer types.</p>"},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._write_files_csv","title":"_write_files_csv  <code>async</code>","text":"<pre><code>_write_files_csv()\n</code></pre> <p>Convenience method to asynchronously write all CSV data to files.</p> <p>Will launch coroutine concurrently with other IO writer types.</p>"},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._write_files_hdf5","title":"_write_files_hdf5  <code>async</code>","text":"<pre><code>_write_files_hdf5()\n</code></pre> <p>Convenience method to asynchronously write all HDF5 data to file.</p> <p>Will launch coroutine concurrently with other IO writer types.</p>"},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._write_files_video","title":"_write_files_video  <code>async</code>","text":"<pre><code>_write_files_video()\n</code></pre> <p>Convenience method to asynchronously write all video data to files.</p> <p>Will launch coroutines concurrently with other IO writer types.</p>"},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._write_hdf5","title":"_write_hdf5","text":"<pre><code>_write_hdf5() -&gt; None\n</code></pre> <p>Convenience wrapper to write new data for multiple HDF5 streams.</p> <p>Writes all new text data to a single HDF5 file.</p>"},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._write_video","title":"_write_video  <code>async</code>","text":"<pre><code>_write_video(video_writer: Popen, node_name: str, device_name: str, stream_name: str)\n</code></pre> <p>Coroutine asynchronous wrapper for multiple video streams.</p> <p>Wraps synchronous IO of each video file into an asynchronous pool of coroutines.</p> <p>Parameters:</p> Name Type Description Default <code>Popen</code> <p>FFmpeg writer corresponding to the video.</p> required <code>str</code> <p>Valid unique tag of the Node owning the data.</p> required <code>str</code> <p>Valid device tree name.</p> required <code>str</code> <p>Valid sub-stream name.</p> required"},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._write_video(video_writer)","title":"<code>video_writer</code>","text":""},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._write_video(node_name)","title":"<code>node_name</code>","text":""},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._write_video(device_name)","title":"<code>device_name</code>","text":""},{"location":"api/base/storage/#hermes.base.storage.storage.Storage._write_video(stream_name)","title":"<code>stream_name</code>","text":""},{"location":"api/base/storage/#hermes.base.storage.storage.Storage.cleanup","title":"cleanup","text":"<pre><code>cleanup() -&gt; None\n</code></pre> <p>Stop stream-logging and wait for it to finish.</p> <p>Will stop stream-logging, if it is active. Will trigger data dump, if configured. Node pushing data to the Stream should stop adding new data before cleaning up Logger.</p>"},{"location":"api/base/storage/#hermes.base.storage.storage_states","title":"storage_states","text":"<p>Classes:</p> Name Description <code>AbstractStorageState</code> <p>Abstract class for the Storage component.</p> <code>DumpState</code> <p>Passive recording state of the Storage component.</p> <code>StartState</code> <p>Startup state that initializes Storage.</p> <code>StreamState</code> <p>Streaming state of the Storage component.</p>"},{"location":"api/base/storage/#hermes.base.storage.storage_states.AbstractStorageState","title":"AbstractStorageState","text":"<p>               Bases: <code>StateInterface</code></p> <pre><code>\n              flowchart TD\n              hermes.base.storage.storage_states.AbstractStorageState[AbstractStorageState]\n              hermes.base.state_interface.StateInterface[StateInterface]\n\n                              hermes.base.state_interface.StateInterface --&gt; hermes.base.storage.storage_states.AbstractStorageState\n                \n\n\n              click hermes.base.storage.storage_states.AbstractStorageState href \"\" \"hermes.base.storage.storage_states.AbstractStorageState\"\n              click hermes.base.state_interface.StateInterface href \"\" \"hermes.base.state_interface.StateInterface\"\n            </code></pre> <p>Abstract class for the Storage component.</p> <p>Methods:</p> Name Description <code>__init__</code> <p>Constructor of the AbstractStorageState.</p>"},{"location":"api/base/storage/#hermes.base.storage.storage_states.AbstractStorageState.__init__","title":"__init__","text":"<pre><code>__init__(context: StorageInterface)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>StorageInterface</code> <p>Reference to the Storage object.</p> required"},{"location":"api/base/storage/#hermes.base.storage.storage_states.AbstractStorageState.__init__(context)","title":"<code>context</code>","text":""},{"location":"api/base/storage/#hermes.base.storage.storage_states.DumpState","title":"DumpState","text":"<p>               Bases: <code>AbstractStorageState</code></p> <pre><code>\n              flowchart TD\n              hermes.base.storage.storage_states.DumpState[DumpState]\n              hermes.base.storage.storage_states.AbstractStorageState[AbstractStorageState]\n              hermes.base.state_interface.StateInterface[StateInterface]\n\n                              hermes.base.storage.storage_states.AbstractStorageState --&gt; hermes.base.storage.storage_states.DumpState\n                                hermes.base.state_interface.StateInterface --&gt; hermes.base.storage.storage_states.AbstractStorageState\n                \n\n\n\n              click hermes.base.storage.storage_states.DumpState href \"\" \"hermes.base.storage.storage_states.DumpState\"\n              click hermes.base.storage.storage_states.AbstractStorageState href \"\" \"hermes.base.storage.storage_states.AbstractStorageState\"\n              click hermes.base.state_interface.StateInterface href \"\" \"hermes.base.state_interface.StateInterface\"\n            </code></pre> <p>Passive recording state of the Storage component.</p> <p>Will flush data to disk once upon system termination.</p> <p>May run out of memory if the recording is long or user doesn't provision sufficient data.</p> <p>Using some streams in stream and others in dump has undefined behavior.</p> <p>Methods:</p> Name Description <code>__init__</code> <p>Constructor of the DumpState.</p>"},{"location":"api/base/storage/#hermes.base.storage.storage_states.DumpState.__init__","title":"__init__","text":"<pre><code>__init__(context: StorageInterface)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>StorageInterface</code> <p>Reference to the Storage object.</p> required"},{"location":"api/base/storage/#hermes.base.storage.storage_states.DumpState.__init__(context)","title":"<code>context</code>","text":""},{"location":"api/base/storage/#hermes.base.storage.storage_states.StartState","title":"StartState","text":"<p>               Bases: <code>AbstractStorageState</code></p> <pre><code>\n              flowchart TD\n              hermes.base.storage.storage_states.StartState[StartState]\n              hermes.base.storage.storage_states.AbstractStorageState[AbstractStorageState]\n              hermes.base.state_interface.StateInterface[StateInterface]\n\n                              hermes.base.storage.storage_states.AbstractStorageState --&gt; hermes.base.storage.storage_states.StartState\n                                hermes.base.state_interface.StateInterface --&gt; hermes.base.storage.storage_states.AbstractStorageState\n                \n\n\n\n              click hermes.base.storage.storage_states.StartState href \"\" \"hermes.base.storage.storage_states.StartState\"\n              click hermes.base.storage.storage_states.AbstractStorageState href \"\" \"hermes.base.storage.storage_states.AbstractStorageState\"\n              click hermes.base.state_interface.StateInterface href \"\" \"hermes.base.state_interface.StateInterface\"\n            </code></pre> <p>Startup state that initializes Storage.</p> <p>Will immediately transition into <code>StreamState</code> after initialization.</p> <p>Methods:</p> Name Description <code>__init__</code> <p>Constructor of the StartState.</p>"},{"location":"api/base/storage/#hermes.base.storage.storage_states.StartState.__init__","title":"__init__","text":"<pre><code>__init__(context: StorageInterface, streams: OrderedDict[str, Stream])\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>StorageInterface</code> <p>Reference to the Storage object.</p> required <code>OrderedDict[str, Stream]</code> <p>Reference to the mapping between uniquly identifying Node keys and the corresponding Stream datastructures.</p> required"},{"location":"api/base/storage/#hermes.base.storage.storage_states.StartState.__init__(context)","title":"<code>context</code>","text":""},{"location":"api/base/storage/#hermes.base.storage.storage_states.StartState.__init__(streams)","title":"<code>streams</code>","text":""},{"location":"api/base/storage/#hermes.base.storage.storage_states.StreamState","title":"StreamState","text":"<p>               Bases: <code>AbstractStorageState</code></p> <pre><code>\n              flowchart TD\n              hermes.base.storage.storage_states.StreamState[StreamState]\n              hermes.base.storage.storage_states.AbstractStorageState[AbstractStorageState]\n              hermes.base.state_interface.StateInterface[StateInterface]\n\n                              hermes.base.storage.storage_states.AbstractStorageState --&gt; hermes.base.storage.storage_states.StreamState\n                                hermes.base.state_interface.StateInterface --&gt; hermes.base.storage.storage_states.AbstractStorageState\n                \n\n\n\n              click hermes.base.storage.storage_states.StreamState href \"\" \"hermes.base.storage.storage_states.StreamState\"\n              click hermes.base.storage.storage_states.AbstractStorageState href \"\" \"hermes.base.storage.storage_states.AbstractStorageState\"\n              click hermes.base.state_interface.StateInterface href \"\" \"hermes.base.state_interface.StateInterface\"\n            </code></pre> <p>Streaming state of the Storage component.</p> <p>Will periodically flush data to disk, to clear memory, if any streams were specified to stream.</p> <p>Will flush remaining data to disk on exit.</p> <p>Using some streams in stream and others in dump has undefined behavior.</p> <p>Methods:</p> Name Description <code>__init__</code> <p>Constructor of the StreamState.</p>"},{"location":"api/base/storage/#hermes.base.storage.storage_states.StreamState.__init__","title":"__init__","text":"<pre><code>__init__(context: StorageInterface)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>StorageInterface</code> <p>Reference to the Storage object.</p> required"},{"location":"api/base/storage/#hermes.base.storage.storage_states.StreamState.__init__(context)","title":"<code>context</code>","text":""},{"location":"api/base/stream/","title":"hermes.base.stream","text":"<p>Stream is a high-performance parallel thread-safe streaming data structure, which the rest of HERMES is based on. It is used to coordinate information between Broker, Producer/Consumer/Pipeline Nodes, and Storage component.</p>"},{"location":"api/base/stream/#hermes.base.stream","title":"stream","text":"<p>Classes:</p> Name Description <code>Stream</code> <p>An abstract class to store data of a Node.</p>"},{"location":"api/base/stream/#hermes.base.stream.Stream","title":"Stream","text":"<p>               Bases: <code>ABC</code></p> <pre><code>\n              flowchart TD\n              hermes.base.stream.Stream[Stream]\n\n              \n\n              click hermes.base.stream.Stream href \"\" \"hermes.base.stream.Stream\"\n            </code></pre> <p>An abstract class to store data of a Node.</p> <p>Tree-like structure of FIFO buffers. May contain multiple sub-streams for a single device, e.g. acceleration and gyroscope of an IMU.</p> <p>Data for sub-streams under the same device tree arrives as a single packet. Packets containing decoupled data are better treated as independent device trees.</p> <p>Uses a lock for each device tree to delegate access to the start of the FIFO: ensures high performance from parallel acquisition, processing, and logging blocks. This allows the end of the FIFO to be saved and discarded by the Storage.</p> <p>Will store the class name of each sensor in HDF5 metadata.</p> <p>Can periodically clear old data (if needed).</p> <p>Methods:</p> Name Description <code>add_stream</code> <p>Add a new sub-stream to an existing device tree or creates new.</p> <code>append_data</code> <p>Thread-safe append of new sample to the stream.</p> <code>clear_data</code> <p>Clear data in a stream.</p> <code>clear_data_all</code> <p>Clear all sub-streams from all device trees.</p> <code>get_device_names</code> <p>Get the names of the asynchronous device trees.</p> <code>get_fps</code> <p>Get effective frame rate of this unique stream's captured data.</p> <code>get_num_devices</code> <p>Get the number of asynchronous device trees.</p> <code>get_stream_info</code> <p>Get metadata of a sub-stream.</p> <code>get_stream_info_all</code> <p>Get metadata of all sub-streams.</p> <code>get_stream_names</code> <p>Get the names of sub-streams in a device tree.</p> <code>peek_data_new</code> <p>Wrap N newest samples in an iterator to peek.</p> <code>pop_data</code> <p>Wrap all samples ready to be popped in an iterator oldest-&gt;newest.</p>"},{"location":"api/base/stream/#hermes.base.stream.Stream._add_stream","title":"_add_stream","text":"<pre><code>_add_stream(\n    device_name: str,\n    stream_name: str,\n    data_type: str,\n    sample_size: Iterable[int],\n    sampling_rate_hz: float = 0.0,\n    is_measure_rate_hz: bool = False,\n    data_notes: Mapping[str, str] = {},\n    is_video: bool = False,\n    color_format: VideoFormatEnum | None = None,\n    is_audio: bool = False,\n    timesteps_before_solidified: int = 0,\n    extra_data_info: ExtraDataInfoDict = {},\n) -&gt; None\n</code></pre> <p>[Internal] Underlying logic for adding a stream.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If supplied color format is not supported or misspelled.</p>"},{"location":"api/base/stream/#hermes.base.stream.Stream._append","title":"_append","text":"<pre><code>_append(device_name: str, stream_name: str, data: Any) -&gt; None\n</code></pre> <p>[Internal] Non thread-safe append of new sample.</p>"},{"location":"api/base/stream/#hermes.base.stream.Stream._get_fps","title":"_get_fps","text":"<pre><code>_get_fps(device_name: str, stream_name: str) -&gt; float | None\n</code></pre> <p>[Internal] Retrieve the effective sampling rate of a signal, if recorded.</p> <p>Records and refreshes rolling statistics on each data structure append over 1-second windows.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>Valid device tree name.</p> required <code>str</code> <p>Valid sub-stream name.</p> required <p>Returns:</p> Type Description <code>float | None</code> <p>float | None: Measured acquisition sampling rate of the sub-stream.</p>"},{"location":"api/base/stream/#hermes.base.stream.Stream._get_fps(device_name)","title":"<code>device_name</code>","text":""},{"location":"api/base/stream/#hermes.base.stream.Stream._get_fps(stream_name)","title":"<code>stream_name</code>","text":""},{"location":"api/base/stream/#hermes.base.stream.Stream.add_stream","title":"add_stream","text":"<pre><code>add_stream(\n    device_name: str,\n    stream_name: str,\n    data_type: str,\n    sample_size: Iterable[int],\n    sampling_rate_hz: float = 0.0,\n    is_measure_rate_hz: bool = False,\n    data_notes: Mapping[str, str] = {},\n    is_video: bool = False,\n    color_format: VideoFormatEnum | None = None,\n    is_audio: bool = False,\n    timesteps_before_solidified: int = 0,\n    extra_data_info: ExtraDataInfoDict = {},\n) -&gt; None\n</code></pre> <p>Add a new sub-stream to an existing device tree or creates new.</p> <p>Will by default add a stream for each device to mark each captured sample with the host's time-of-arrival.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>Device tree name. Will autocreate if doesn't exist.</p> required <code>str</code> <p>Unique sub-stream name under this device tree.</p> required <code>str</code> <p>Fixed data type expected in the sub-stream.</p> required <code>Iterable[int]</code> <p>An interable of dimensions of given data type in each captured sample.</p> required <code>float</code> <p>Expected sampling frequency of the signal. Defaults to <code>0.0</code>.</p> <code>0.0</code> <code>bool</code> <p>Whether to compute the effective sampling frequency. Defaults to <code>False</code>.</p> <code>False</code> <code>Mapping[str, str]</code> <p>Mapping of streams to notes for Storage to use in file metadata. Defaults to <code>{}</code>.</p> <code>{}</code> <code>bool</code> <p>Whether it is a video stream. Defaults to <code>False</code>.</p> <code>False</code> <code>VideoFormatEnum | None</code> <p>One of the supported identifiers (see <code>types.py</code>). Defaults to <code>None</code>.</p> <code>None</code> <code>bool</code> <p>Whether it is an audio stream. Defaults to <code>False</code>.</p> <code>False</code> <code>int</code> <p>How many most recent samples to keep in memory before flushing. Defaults to <code>0</code>.</p> <code>0</code> <code>ExtraDataInfoDict</code> <p>Additional mapping that will be streamed along with data, with at least 'data_type' and 'sample_size'. Defaults to <code>{}</code>.</p> <code>{}</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If stream name is not unique or is reserved.</p>"},{"location":"api/base/stream/#hermes.base.stream.Stream.add_stream(device_name)","title":"<code>device_name</code>","text":""},{"location":"api/base/stream/#hermes.base.stream.Stream.add_stream(stream_name)","title":"<code>stream_name</code>","text":""},{"location":"api/base/stream/#hermes.base.stream.Stream.add_stream(data_type)","title":"<code>data_type</code>","text":""},{"location":"api/base/stream/#hermes.base.stream.Stream.add_stream(sample_size)","title":"<code>sample_size</code>","text":""},{"location":"api/base/stream/#hermes.base.stream.Stream.add_stream(sampling_rate_hz)","title":"<code>sampling_rate_hz</code>","text":""},{"location":"api/base/stream/#hermes.base.stream.Stream.add_stream(is_measure_rate_hz)","title":"<code>is_measure_rate_hz</code>","text":""},{"location":"api/base/stream/#hermes.base.stream.Stream.add_stream(data_notes)","title":"<code>data_notes</code>","text":""},{"location":"api/base/stream/#hermes.base.stream.Stream.add_stream(is_video)","title":"<code>is_video</code>","text":""},{"location":"api/base/stream/#hermes.base.stream.Stream.add_stream(color_format)","title":"<code>color_format</code>","text":""},{"location":"api/base/stream/#hermes.base.stream.Stream.add_stream(is_audio)","title":"<code>is_audio</code>","text":""},{"location":"api/base/stream/#hermes.base.stream.Stream.add_stream(timesteps_before_solidified)","title":"<code>timesteps_before_solidified</code>","text":""},{"location":"api/base/stream/#hermes.base.stream.Stream.add_stream(extra_data_info)","title":"<code>extra_data_info</code>","text":""},{"location":"api/base/stream/#hermes.base.stream.Stream.append_data","title":"append_data","text":"<pre><code>append_data(process_time_s: float, data: NewDataDict) -&gt; None\n</code></pre> <p>Thread-safe append of new sample to the stream.</p> <p>Locks the device tree of the sub-stream, to avoid immutability error in reverse iterator of the GUI thread when trying to peek N newest samples of the stream while new are written.</p> <p>Parameters:</p> Name Type Description Default <code>float</code> <p>Time-of-processing of the sample.</p> required <code>NewDataDict</code> <p>Newly processed sample.</p> required"},{"location":"api/base/stream/#hermes.base.stream.Stream.append_data(process_time_s)","title":"<code>process_time_s</code>","text":""},{"location":"api/base/stream/#hermes.base.stream.Stream.append_data(data)","title":"<code>data</code>","text":""},{"location":"api/base/stream/#hermes.base.stream.Stream.clear_data","title":"clear_data","text":"<pre><code>clear_data(\n    device_name: str, stream_name: str, num_oldest_to_clear: int | None = None\n) -&gt; None\n</code></pre> <p>Clear data in a stream.</p> <p>Initializes the sub-stream if it doesn't exist. Optionally can clear N oldest samples.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>Valid device tree name.</p> required <code>str</code> <p>Valid sub-stream name.</p> required <code>int | None</code> <p>Number of oldest samples to clear. Defaults to <code>None</code>.</p> <code>None</code>"},{"location":"api/base/stream/#hermes.base.stream.Stream.clear_data(device_name)","title":"<code>device_name</code>","text":""},{"location":"api/base/stream/#hermes.base.stream.Stream.clear_data(stream_name)","title":"<code>stream_name</code>","text":""},{"location":"api/base/stream/#hermes.base.stream.Stream.clear_data(num_oldest_to_clear)","title":"<code>num_oldest_to_clear</code>","text":""},{"location":"api/base/stream/#hermes.base.stream.Stream.clear_data_all","title":"clear_data_all","text":"<pre><code>clear_data_all() -&gt; None\n</code></pre> <p>Clear all sub-streams from all device trees.</p>"},{"location":"api/base/stream/#hermes.base.stream.Stream.get_device_names","title":"get_device_names","text":"<pre><code>get_device_names() -&gt; list[str]\n</code></pre> <p>Get the names of the asynchronous device trees.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: Names of device trees.</p>"},{"location":"api/base/stream/#hermes.base.stream.Stream.get_fps","title":"get_fps  <code>abstractmethod</code>","text":"<pre><code>get_fps() -&gt; dict[str, float | None]\n</code></pre> <p>Get effective frame rate of this unique stream's captured data.</p> <p>Subject to expected transmission delay and throughput limitation. Computed based on how fast data becomes available to the data structure. Used to measure the performance of the system - local or remote nodes.</p> <p>Returns:</p> Type Description <code>dict[str, float | None]</code> <p>dict[str, float | None]: Mapping of measured FPS to stream names.</p>"},{"location":"api/base/stream/#hermes.base.stream.Stream.get_num_devices","title":"get_num_devices","text":"<pre><code>get_num_devices() -&gt; int\n</code></pre> <p>Get the number of asynchronous device trees.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of device trees.</p>"},{"location":"api/base/stream/#hermes.base.stream.Stream.get_stream_info","title":"get_stream_info","text":"<pre><code>get_stream_info(device_name: str, stream_name: str) -&gt; Dict[str, Any]\n</code></pre> <p>Get metadata of a sub-stream.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>Valid device tree name.</p> required <code>str</code> <p>Valid sub-stream name.</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: Metadata dictionary with keys: data_type is_video is_audio sample_size sampling_rate_hz timesteps_before_solidified extra_data_info data_notes if is_measure_rate_hz: actual_rate_hz dt_circular_buffer dt_circular_index dt_running_sum old_toa</p>"},{"location":"api/base/stream/#hermes.base.stream.Stream.get_stream_info(device_name)","title":"<code>device_name</code>","text":""},{"location":"api/base/stream/#hermes.base.stream.Stream.get_stream_info(stream_name)","title":"<code>stream_name</code>","text":""},{"location":"api/base/stream/#hermes.base.stream.Stream.get_stream_info_all","title":"get_stream_info_all","text":"<pre><code>get_stream_info_all() -&gt; StreamInfoDict\n</code></pre> <p>Get metadata of all sub-streams.</p> <p>Returns:</p> Name Type Description <code>StreamInfoDict</code> <code>StreamInfoDict</code> <p>Nested dictionary of metadata, with device trees and sub-streams as keys.</p>"},{"location":"api/base/stream/#hermes.base.stream.Stream.get_stream_names","title":"get_stream_names","text":"<pre><code>get_stream_names(device_name: str | None = None) -&gt; list[str]\n</code></pre> <p>Get the names of sub-streams in a device tree.</p> <p>If device_name is None, will assume streams are the same for every device.</p> <p>Parameters:</p> Name Type Description Default <code>str | None</code> <p>Name of the device tree to query. Defaults to <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: Names of sub-streams in a device tree.</p>"},{"location":"api/base/stream/#hermes.base.stream.Stream.get_stream_names(device_name)","title":"<code>device_name</code>","text":""},{"location":"api/base/stream/#hermes.base.stream.Stream.peek_data_new","title":"peek_data_new","text":"<pre><code>peek_data_new(\n    device_name: str, stream_name: str, num_newest_to_peek: int | None = None\n) -&gt; Iterator[Any]\n</code></pre> <p>Wrap N newest samples in an iterator to peek.</p> <p>Will lock the device tree of the sub-stream to prevent appends muttating the iterator. Will allow popping of the oldest data (e.g. for Storage to flush). Peeking and popping ranges are protected by <code>timesteps_before_solidified</code>.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>Valid device tree name.</p> required <code>str</code> <p>Valid sub-stream name.</p> required <code>int | None</code> <p>Number of samples to peek, if less than <code>timesteps_before_solidified</code>. Defaults to <code>None</code>.</p> <code>None</code> <p>Yields:</p> Type Description <code>Any</code> <p>Iterator[Any]: Iterator over peekable newest samples.</p>"},{"location":"api/base/stream/#hermes.base.stream.Stream.peek_data_new(device_name)","title":"<code>device_name</code>","text":""},{"location":"api/base/stream/#hermes.base.stream.Stream.peek_data_new(stream_name)","title":"<code>stream_name</code>","text":""},{"location":"api/base/stream/#hermes.base.stream.Stream.peek_data_new(num_newest_to_peek)","title":"<code>num_newest_to_peek</code>","text":""},{"location":"api/base/stream/#hermes.base.stream.Stream.pop_data","title":"pop_data","text":"<pre><code>pop_data(\n    device_name: str,\n    stream_name: str,\n    num_oldest_to_pop: int | None = None,\n    is_flush: bool = False,\n) -&gt; Iterator[Any]\n</code></pre> <p>Wrap all samples ready to be popped in an iterator oldest-&gt;newest.</p> <p>Used by Storage to flush data to disk. Popped data is cleared from memory. Thread-safe without locks while appending new data.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>Valid device tree name.</p> required <code>str</code> <p>Valid sub-stream name.</p> required <code>int | None</code> <p>Number of samples to pop. Defaults to <code>None</code>.</p> <code>None</code> <code>bool</code> <p>Whether to pop all data in the stream, regardless of timesteps_before_solidified. Defaults to <code>False</code>.</p> <code>False</code> <p>Yields:</p> Type Description <code>Any</code> <p>Iterator[Any]: Iterator over poppable oldest-&gt;newest samples.</p>"},{"location":"api/base/stream/#hermes.base.stream.Stream.pop_data(device_name)","title":"<code>device_name</code>","text":""},{"location":"api/base/stream/#hermes.base.stream.Stream.pop_data(stream_name)","title":"<code>stream_name</code>","text":""},{"location":"api/base/stream/#hermes.base.stream.Stream.pop_data(num_oldest_to_pop)","title":"<code>num_oldest_to_pop</code>","text":""},{"location":"api/base/stream/#hermes.base.stream.Stream.pop_data(is_flush)","title":"<code>is_flush</code>","text":""},{"location":"api/datastructures/","title":"Datastructures","text":"<p>TODO: The module contains useful reusable datastructures encapsulated in the higher-level components of HERMES.</p>"},{"location":"api/datastructures/cache/","title":"Cache","text":""},{"location":"api/datastructures/cache/#hermes.datastructures.cache","title":"cache","text":"<p>Classes:</p> Name Description <code>Cache</code> <p>Caching module prefetches segments of data that has long IO, for more responsive experience.</p> <code>DataRequest</code> <p>Object wrapping user's element of interest into a fetch request.</p>"},{"location":"api/datastructures/cache/#hermes.datastructures.cache.Cache","title":"Cache","text":"<p>Caching module prefetches segments of data that has long IO, for more responsive experience.</p> <p>Methods:</p> Name Description <code>__init__</code> <p>Constructor of the Cache component for long IO prefetching to mask latency behind wide bandwidth.</p> <code>get_data</code> <p>Request data from the cache.</p> <code>join</code> <p>Wait on the background cache management thread.</p> <code>start</code> <p>Start the background cache management thread.</p>"},{"location":"api/datastructures/cache/#hermes.datastructures.cache.Cache.__init__","title":"__init__","text":"<pre><code>__init__(fetch_fn: Callable[[Any], Dict[Any, Any]], fetch_offset: int)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>Callable[[Any], Dict[Any, Any]]</code> <p>User-provided function with long IO to use for asynchronous prefetching (database operation, API call, FFmpeg decoding, etc.).</p> required <code>int</code> <p>How many elements before the requested to cache in case of jumping backwards during playback.</p> required"},{"location":"api/datastructures/cache/#hermes.datastructures.cache.Cache.__init__(fetch_fn)","title":"<code>fetch_fn</code>","text":""},{"location":"api/datastructures/cache/#hermes.datastructures.cache.Cache.__init__(fetch_offset)","title":"<code>fetch_offset</code>","text":""},{"location":"api/datastructures/cache/#hermes.datastructures.cache.Cache._fetch","title":"_fetch","text":"<pre><code>_fetch(key: Any) -&gt; Dict[Any, Any]\n</code></pre> <p>Fetches data from an external source using user-defined IO function.</p> <p>Returns:</p> Type Description <code>Dict[Any, Any]</code> <p>Dict[Any, Any]: Mapping from a unique key to the element of interest.</p>"},{"location":"api/datastructures/cache/#hermes.datastructures.cache.Cache._process_request","title":"_process_request","text":"<pre><code>_process_request(request: DataRequest)\n</code></pre> <p>Process user request for the next element of interest.</p> <p>Runs user-provided long-IO fetch procedure if the data is not immediately available in cache or isn't already being fetched. Updates the cache and notifies all watchers waiting for this element.</p> <p>Parameters:</p> Name Type Description Default <code>DataRequest</code> <p>User-requested element of interest.</p> required"},{"location":"api/datastructures/cache/#hermes.datastructures.cache.Cache._process_request(request)","title":"<code>request</code>","text":""},{"location":"api/datastructures/cache/#hermes.datastructures.cache.Cache._run_cache_manager","title":"_run_cache_manager","text":"<pre><code>_run_cache_manager()\n</code></pre> <p>Main loop of the background continuous cache management thread.</p> <p>Processes requests from the user and prefetches most likely used next segment of elements.</p>"},{"location":"api/datastructures/cache/#hermes.datastructures.cache.Cache.get_data","title":"get_data","text":"<pre><code>get_data(key: Any) -&gt; Any\n</code></pre> <p>Request data from the cache.</p> <p>Checks if data is already in the cache. Adds a request to the queue for background processing. Returns immediately if requested data is cached, otherwise waits for the background task to fetch it. Stalls until the data is available in the cache for the given key.</p> <p>Parameters:</p> Name Type Description Default <code>Any</code> <p>Unique key correctly identifying the element of interest in the user-provided fetch function.</p> required <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>The requested element of interest.</p>"},{"location":"api/datastructures/cache/#hermes.datastructures.cache.Cache.get_data(key)","title":"<code>key</code>","text":""},{"location":"api/datastructures/cache/#hermes.datastructures.cache.Cache.join","title":"join","text":"<pre><code>join()\n</code></pre> <p>Wait on the background cache management thread.</p>"},{"location":"api/datastructures/cache/#hermes.datastructures.cache.Cache.start","title":"start","text":"<pre><code>start()\n</code></pre> <p>Start the background cache management thread.</p>"},{"location":"api/datastructures/cache/#hermes.datastructures.cache.DataRequest","title":"DataRequest  <code>dataclass</code>","text":"<p>Object wrapping user's element of interest into a fetch request.</p>"},{"location":"api/datastructures/fifo/","title":"FIFO","text":""},{"location":"api/datastructures/fifo/#hermes.datastructures.fifo","title":"fifo","text":"<p>Classes:</p> Name Description <code>AlignedFifoBuffer</code> <p>Multichannel first-in first-out buffer that aligns asynchronous temporally-lossy samples across channels.</p> <code>BufferInterface</code> <p>Interface for the multi-channel FIFO buffer.</p> <code>NonOverflowingCounterAlignedFifoBuffer</code> <p>Multichannel first-in first-out buffer that aligns asynchronous temporally-lossy samples across channels by supplied correlated overflowing counter.</p> <code>NonOverflowingCounterConverter</code> <p>A counter value converter from overflowing fixed range to non-overflowing values, starting at 0 for the first received sample.</p> <code>TimestampAlignedFifoBuffer</code> <p>Multichannel first-in first-out buffer that aligns asynchronous temporally-lossy samples across channels by supplied correlated timestamps.</p> <code>TimestampToCounterConverter</code> <p>A counter value converter from overflowing fixed range timestamp to non-overflowing counter values, starting at 0 for the first received sample.</p>"},{"location":"api/datastructures/fifo/#hermes.datastructures.fifo.AlignedFifoBuffer","title":"AlignedFifoBuffer","text":"<p>               Bases: <code>BufferInterface</code></p> <pre><code>\n              flowchart TD\n              hermes.datastructures.fifo.AlignedFifoBuffer[AlignedFifoBuffer]\n              hermes.datastructures.fifo.BufferInterface[BufferInterface]\n\n                              hermes.datastructures.fifo.BufferInterface --&gt; hermes.datastructures.fifo.AlignedFifoBuffer\n                \n\n\n              click hermes.datastructures.fifo.AlignedFifoBuffer href \"\" \"hermes.datastructures.fifo.AlignedFifoBuffer\"\n              click hermes.datastructures.fifo.BufferInterface href \"\" \"hermes.datastructures.fifo.BufferInterface\"\n            </code></pre> <p>Multichannel first-in first-out buffer that aligns asynchronous temporally-lossy samples across channels.</p> <p>Receives asynchronous samples for each channel, aligns them, and returns to the user an aligned snapshot across all channels. Allows yeeting from buffer if some keys have been empty for a while (disconnection or out of range), while others continue producing.</p> <p>By default uses dynamically-growing Deque for the buffer, approprate for the sample rate of IMUs. <code>maxlen</code> offers possibility to turn into a fixed-length ring buffer, to avoid unnecessary memory allocations for higher performance, at the cost of lost data in case of slow consumers.</p> <p>Updates only on yeet to discard stale sample that arrived too late. Adds counter into the data payload to retreive on the reader. (Useful for time-&gt;counter converted buffer). If the snapshot had not been read, even if the measurement is stale (arrived later than specified), still adds it to the buffer. Empty pads if some intermediate timesteps did not recieve a packet for a specific key. If buffer contents are valid, moves snapshot into the output Queue. Update the frame counter to keep track of removed data to discard stale late arrivals.</p> <p>Methods:</p> Name Description <code>__init__</code> <p>Constructor of the AlignedFifoBuffer.</p> <code>flush</code> <p>Allow to evict all present data because no new samples will be captured.</p> <code>yeet</code> <p>Attempts to synchronously retrieve the oldest set of samples from all channels of the buffer with a timeout.</p>"},{"location":"api/datastructures/fifo/#hermes.datastructures.fifo.AlignedFifoBuffer.__init__","title":"__init__","text":"<pre><code>__init__(keys: Iterable, timesteps_before_stale: int, maxlen: int | None = None)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>Iterable</code> <p>Set of uniquely identifying channel keys.</p> required <code>int</code> <p>The number of samples in other channels after which a missing sample in a channel is marked missing.</p> required <code>int | None</code> <p>Fixed length of preallocated ring buffer. Defaults to None.</p> <code>None</code>"},{"location":"api/datastructures/fifo/#hermes.datastructures.fifo.AlignedFifoBuffer.__init__(keys)","title":"<code>keys</code>","text":""},{"location":"api/datastructures/fifo/#hermes.datastructures.fifo.AlignedFifoBuffer.__init__(timesteps_before_stale)","title":"<code>timesteps_before_stale</code>","text":""},{"location":"api/datastructures/fifo/#hermes.datastructures.fifo.AlignedFifoBuffer.__init__(maxlen)","title":"<code>maxlen</code>","text":""},{"location":"api/datastructures/fifo/#hermes.datastructures.fifo.AlignedFifoBuffer._put_output_queue","title":"_put_output_queue","text":"<pre><code>_put_output_queue(packet: dict) -&gt; None\n</code></pre> <p>Places a ready to consume complete snapshot onto the output queue.</p> <p>Parameters:</p> Name Type Description Default <code>dict</code> <p>Temporally aligned snapshot mapping unique channel-identifying keys to the corresponding sample.</p> required"},{"location":"api/datastructures/fifo/#hermes.datastructures.fifo.AlignedFifoBuffer._put_output_queue(packet)","title":"<code>packet</code>","text":""},{"location":"api/datastructures/fifo/#hermes.datastructures.fifo.AlignedFifoBuffer.flush","title":"flush","text":"<pre><code>flush() -&gt; None\n</code></pre> <p>Allow to evict all present data because no new samples will be captured.</p>"},{"location":"api/datastructures/fifo/#hermes.datastructures.fifo.AlignedFifoBuffer.yeet","title":"yeet","text":"<pre><code>yeet(timeout: float = 10.0) -&gt; dict | None\n</code></pre> <p>Attempts to synchronously retrieve the oldest set of samples from all channels of the buffer with a timeout.</p> <p>Parameters:</p> Name Type Description Default <code>float</code> <p>How long to wait for new snapshot. Defaults to <code>10.0</code>.</p> <code>10.0</code> <p>Returns:</p> Type Description <code>dict | None</code> <p>dict | None: Multi-channel vector of the oldest sample or None if no new data became available until timeout.</p>"},{"location":"api/datastructures/fifo/#hermes.datastructures.fifo.AlignedFifoBuffer.yeet(timeout)","title":"<code>timeout</code>","text":""},{"location":"api/datastructures/fifo/#hermes.datastructures.fifo.BufferInterface","title":"BufferInterface","text":"<p>               Bases: <code>ABC</code></p> <pre><code>\n              flowchart TD\n              hermes.datastructures.fifo.BufferInterface[BufferInterface]\n\n              \n\n              click hermes.datastructures.fifo.BufferInterface href \"\" \"hermes.datastructures.fifo.BufferInterface\"\n            </code></pre> <p>Interface for the multi-channel FIFO buffer.</p> <p>Methods:</p> Name Description <code>plop</code> <p>Asynchronously adds an element to the specified channel of the buffer.</p> <code>yeet</code> <p>Synchronously retrieves the oldest set of samples from all channels of the buffer.</p>"},{"location":"api/datastructures/fifo/#hermes.datastructures.fifo.BufferInterface.plop","title":"plop  <code>abstractmethod</code>","text":"<pre><code>plop(key: str, data: dict) -&gt; None\n</code></pre> <p>Asynchronously adds an element to the specified channel of the buffer.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>Unique identifier of the channel to add the data to.</p> required <code>dict</code> <p>Usecase-specific nested dictionary of data to add.</p> required"},{"location":"api/datastructures/fifo/#hermes.datastructures.fifo.BufferInterface.plop(key)","title":"<code>key</code>","text":""},{"location":"api/datastructures/fifo/#hermes.datastructures.fifo.BufferInterface.plop(data)","title":"<code>data</code>","text":""},{"location":"api/datastructures/fifo/#hermes.datastructures.fifo.BufferInterface.yeet","title":"yeet  <code>abstractmethod</code>","text":"<pre><code>yeet() -&gt; Any\n</code></pre> <p>Synchronously retrieves the oldest set of samples from all channels of the buffer.</p> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>Multi-channel vector of the oldest sample.</p>"},{"location":"api/datastructures/fifo/#hermes.datastructures.fifo.NonOverflowingCounterAlignedFifoBuffer","title":"NonOverflowingCounterAlignedFifoBuffer","text":"<p>               Bases: <code>AlignedFifoBuffer</code></p> <pre><code>\n              flowchart TD\n              hermes.datastructures.fifo.NonOverflowingCounterAlignedFifoBuffer[NonOverflowingCounterAlignedFifoBuffer]\n              hermes.datastructures.fifo.AlignedFifoBuffer[AlignedFifoBuffer]\n              hermes.datastructures.fifo.BufferInterface[BufferInterface]\n\n                              hermes.datastructures.fifo.AlignedFifoBuffer --&gt; hermes.datastructures.fifo.NonOverflowingCounterAlignedFifoBuffer\n                                hermes.datastructures.fifo.BufferInterface --&gt; hermes.datastructures.fifo.AlignedFifoBuffer\n                \n\n\n\n              click hermes.datastructures.fifo.NonOverflowingCounterAlignedFifoBuffer href \"\" \"hermes.datastructures.fifo.NonOverflowingCounterAlignedFifoBuffer\"\n              click hermes.datastructures.fifo.AlignedFifoBuffer href \"\" \"hermes.datastructures.fifo.AlignedFifoBuffer\"\n              click hermes.datastructures.fifo.BufferInterface href \"\" \"hermes.datastructures.fifo.BufferInterface\"\n            </code></pre> <p>Multichannel first-in first-out buffer that aligns asynchronous temporally-lossy samples across channels by supplied correlated overflowing counter.</p> <p>Methods:</p> Name Description <code>__init__</code> <p>Constructor of the NonOverflowingCounterAlignedFifoBuffer.</p> <code>flush</code> <p>Allow to evict all present data because no new samples will be captured.</p> <code>yeet</code> <p>Attempts to synchronously retrieve the oldest set of samples from all channels of the buffer with a timeout.</p>"},{"location":"api/datastructures/fifo/#hermes.datastructures.fifo.NonOverflowingCounterAlignedFifoBuffer.__init__","title":"__init__","text":"<pre><code>__init__(\n    keys: Iterable,\n    timesteps_before_stale: int,\n    num_bits_timestamp: int,\n    maxlen: int | None = None,\n)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>Iterable</code> <p>Set of uniquely identifying channel keys.</p> required <code>int</code> <p>The number of samples in other channels after which a missing sample in a channel is marked missing.</p> required <code>int</code> <p>The fixed-width of the counter generating the data.</p> required <code>int | None</code> <p>Fixed length of preallocated ring buffer. Defaults to <code>None</code>.</p> <code>None</code>"},{"location":"api/datastructures/fifo/#hermes.datastructures.fifo.NonOverflowingCounterAlignedFifoBuffer.__init__(keys)","title":"<code>keys</code>","text":""},{"location":"api/datastructures/fifo/#hermes.datastructures.fifo.NonOverflowingCounterAlignedFifoBuffer.__init__(timesteps_before_stale)","title":"<code>timesteps_before_stale</code>","text":""},{"location":"api/datastructures/fifo/#hermes.datastructures.fifo.NonOverflowingCounterAlignedFifoBuffer.__init__(num_bits_timestamp)","title":"<code>num_bits_timestamp</code>","text":""},{"location":"api/datastructures/fifo/#hermes.datastructures.fifo.NonOverflowingCounterAlignedFifoBuffer.__init__(maxlen)","title":"<code>maxlen</code>","text":""},{"location":"api/datastructures/fifo/#hermes.datastructures.fifo.NonOverflowingCounterAlignedFifoBuffer._put_output_queue","title":"_put_output_queue","text":"<pre><code>_put_output_queue(packet: dict) -&gt; None\n</code></pre> <p>Places a ready to consume complete snapshot onto the output queue.</p> <p>Parameters:</p> Name Type Description Default <code>dict</code> <p>Temporally aligned snapshot mapping unique channel-identifying keys to the corresponding sample.</p> required"},{"location":"api/datastructures/fifo/#hermes.datastructures.fifo.NonOverflowingCounterAlignedFifoBuffer._put_output_queue(packet)","title":"<code>packet</code>","text":""},{"location":"api/datastructures/fifo/#hermes.datastructures.fifo.NonOverflowingCounterAlignedFifoBuffer.flush","title":"flush","text":"<pre><code>flush() -&gt; None\n</code></pre> <p>Allow to evict all present data because no new samples will be captured.</p>"},{"location":"api/datastructures/fifo/#hermes.datastructures.fifo.NonOverflowingCounterAlignedFifoBuffer.yeet","title":"yeet","text":"<pre><code>yeet(timeout: float = 10.0) -&gt; dict | None\n</code></pre> <p>Attempts to synchronously retrieve the oldest set of samples from all channels of the buffer with a timeout.</p> <p>Parameters:</p> Name Type Description Default <code>float</code> <p>How long to wait for new snapshot. Defaults to <code>10.0</code>.</p> <code>10.0</code> <p>Returns:</p> Type Description <code>dict | None</code> <p>dict | None: Multi-channel vector of the oldest sample or None if no new data became available until timeout.</p>"},{"location":"api/datastructures/fifo/#hermes.datastructures.fifo.NonOverflowingCounterAlignedFifoBuffer.yeet(timeout)","title":"<code>timeout</code>","text":""},{"location":"api/datastructures/fifo/#hermes.datastructures.fifo.NonOverflowingCounterConverter","title":"NonOverflowingCounterConverter","text":"<p>A counter value converter from overflowing fixed range to non-overflowing values, starting at 0 for the first received sample.</p> <p>Converts overflowing monotonically increasing counter from a sensor into a non-overflowing value, starting counting from 0, regardless of device's actual onboard counter.</p> <p>Methods:</p> Name Description <code>__init__</code> <p>Constructor of the NonOverflowingCounterConverter.</p>"},{"location":"api/datastructures/fifo/#hermes.datastructures.fifo.NonOverflowingCounterConverter.__init__","title":"__init__","text":"<pre><code>__init__(keys: Iterable[Any], num_bits_counter: int)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>Iterable[Any]</code> <p>Set of uniquely identifying channel keys.</p> required <code>int</code> <p>The fixed-width of the counter generating the data.</p> required"},{"location":"api/datastructures/fifo/#hermes.datastructures.fifo.NonOverflowingCounterConverter.__init__(keys)","title":"<code>keys</code>","text":""},{"location":"api/datastructures/fifo/#hermes.datastructures.fifo.NonOverflowingCounterConverter.__init__(num_bits_counter)","title":"<code>num_bits_counter</code>","text":""},{"location":"api/datastructures/fifo/#hermes.datastructures.fifo.NonOverflowingCounterConverter._bar","title":"_bar","text":"<pre><code>_bar(key: Any, counter: int) -&gt; int | None\n</code></pre> <p>Optimized counter converter function for continuous steady-state operation.</p> <p>Previous counters are guaranteed to be non-0 after this function is activated.</p> <p>Parameters:</p> Name Type Description Default <code>Any</code> <p>The unique identifier of the channel.</p> required <code>int</code> <p>Monotonically increasing overflowing integer from a sensor.</p> required <p>Returns:</p> Type Description <code>int | None</code> <p>int | None: Converted counter value starting at 0 counter value.</p>"},{"location":"api/datastructures/fifo/#hermes.datastructures.fifo.NonOverflowingCounterConverter._bar(key)","title":"<code>key</code>","text":""},{"location":"api/datastructures/fifo/#hermes.datastructures.fifo.NonOverflowingCounterConverter._bar(counter)","title":"<code>counter</code>","text":""},{"location":"api/datastructures/fifo/#hermes.datastructures.fifo.NonOverflowingCounterConverter._foo","title":"_foo","text":"<pre><code>_foo(key: Any, counter: int) -&gt; int | None\n</code></pre> <p>Startup multi-channel function that converts correlated over-flowing counter values from asynchronous sensors to a non-overflowing counter.</p> <p>Switches to the continuous function when all channels have provided a starting sample. Else, reuses this function with branch conditional logic. The branched version is not ideal for continuous use, because other conditions never happen after the first iteration of the module on the channel.</p> <p>Parameters:</p> Name Type Description Default <code>Any</code> <p>The unique identifier of the channel.</p> required <code>int</code> <p>Monotonically increasing overflowing integer from a sensor.</p> required <p>Returns:</p> Type Description <code>int | None</code> <p>int | None: Converted counter value starting at 0 counter value.</p>"},{"location":"api/datastructures/fifo/#hermes.datastructures.fifo.NonOverflowingCounterConverter._foo(key)","title":"<code>key</code>","text":""},{"location":"api/datastructures/fifo/#hermes.datastructures.fifo.NonOverflowingCounterConverter._foo(counter)","title":"<code>counter</code>","text":""},{"location":"api/datastructures/fifo/#hermes.datastructures.fifo.TimestampAlignedFifoBuffer","title":"TimestampAlignedFifoBuffer","text":"<p>               Bases: <code>AlignedFifoBuffer</code></p> <pre><code>\n              flowchart TD\n              hermes.datastructures.fifo.TimestampAlignedFifoBuffer[TimestampAlignedFifoBuffer]\n              hermes.datastructures.fifo.AlignedFifoBuffer[AlignedFifoBuffer]\n              hermes.datastructures.fifo.BufferInterface[BufferInterface]\n\n                              hermes.datastructures.fifo.AlignedFifoBuffer --&gt; hermes.datastructures.fifo.TimestampAlignedFifoBuffer\n                                hermes.datastructures.fifo.BufferInterface --&gt; hermes.datastructures.fifo.AlignedFifoBuffer\n                \n\n\n\n              click hermes.datastructures.fifo.TimestampAlignedFifoBuffer href \"\" \"hermes.datastructures.fifo.TimestampAlignedFifoBuffer\"\n              click hermes.datastructures.fifo.AlignedFifoBuffer href \"\" \"hermes.datastructures.fifo.AlignedFifoBuffer\"\n              click hermes.datastructures.fifo.BufferInterface href \"\" \"hermes.datastructures.fifo.BufferInterface\"\n            </code></pre> <p>Multichannel first-in first-out buffer that aligns asynchronous temporally-lossy samples across channels by supplied correlated timestamps.</p> <p>Allows yeeting from buffer if some keys have been empty for a while, while others continue producing.</p> <p>Methods:</p> Name Description <code>__init__</code> <p>Constructor of the TimestampAlignedFifoBuffer.</p> <code>flush</code> <p>Allow to evict all present data because no new samples will be captured.</p> <code>yeet</code> <p>Attempts to synchronously retrieve the oldest set of samples from all channels of the buffer with a timeout.</p>"},{"location":"api/datastructures/fifo/#hermes.datastructures.fifo.TimestampAlignedFifoBuffer.__init__","title":"__init__","text":"<pre><code>__init__(\n    keys: Iterable,\n    timesteps_before_stale: int,\n    sampling_period: int,\n    counter_limit: int,\n    maxlen: int | None = None,\n)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>Iterable</code> <p>Set of uniquely identifying channel keys.</p> required <code>int</code> <p>The number of samples in other channels after which a missing sample in a channel is marked missing.</p> required <code>int</code> <p>Sampling period in the same units as timestamp limit and timestamps.</p> required <code>int</code> <p>The upper counting limit of the sensor's timestamp.</p> required <code>int | None</code> <p>Fixed length of preallocated ring buffer. Defaults to <code>None</code>.</p> <code>None</code>"},{"location":"api/datastructures/fifo/#hermes.datastructures.fifo.TimestampAlignedFifoBuffer.__init__(keys)","title":"<code>keys</code>","text":""},{"location":"api/datastructures/fifo/#hermes.datastructures.fifo.TimestampAlignedFifoBuffer.__init__(timesteps_before_stale)","title":"<code>timesteps_before_stale</code>","text":""},{"location":"api/datastructures/fifo/#hermes.datastructures.fifo.TimestampAlignedFifoBuffer.__init__(sampling_period)","title":"<code>sampling_period</code>","text":""},{"location":"api/datastructures/fifo/#hermes.datastructures.fifo.TimestampAlignedFifoBuffer.__init__(counter_limit)","title":"<code>counter_limit</code>","text":""},{"location":"api/datastructures/fifo/#hermes.datastructures.fifo.TimestampAlignedFifoBuffer.__init__(maxlen)","title":"<code>maxlen</code>","text":""},{"location":"api/datastructures/fifo/#hermes.datastructures.fifo.TimestampAlignedFifoBuffer._put_output_queue","title":"_put_output_queue","text":"<pre><code>_put_output_queue(packet: dict) -&gt; None\n</code></pre> <p>Places a ready to consume complete snapshot onto the output queue.</p> <p>Parameters:</p> Name Type Description Default <code>dict</code> <p>Temporally aligned snapshot mapping unique channel-identifying keys to the corresponding sample.</p> required"},{"location":"api/datastructures/fifo/#hermes.datastructures.fifo.TimestampAlignedFifoBuffer._put_output_queue(packet)","title":"<code>packet</code>","text":""},{"location":"api/datastructures/fifo/#hermes.datastructures.fifo.TimestampAlignedFifoBuffer.flush","title":"flush","text":"<pre><code>flush() -&gt; None\n</code></pre> <p>Allow to evict all present data because no new samples will be captured.</p>"},{"location":"api/datastructures/fifo/#hermes.datastructures.fifo.TimestampAlignedFifoBuffer.yeet","title":"yeet","text":"<pre><code>yeet(timeout: float = 10.0) -&gt; dict | None\n</code></pre> <p>Attempts to synchronously retrieve the oldest set of samples from all channels of the buffer with a timeout.</p> <p>Parameters:</p> Name Type Description Default <code>float</code> <p>How long to wait for new snapshot. Defaults to <code>10.0</code>.</p> <code>10.0</code> <p>Returns:</p> Type Description <code>dict | None</code> <p>dict | None: Multi-channel vector of the oldest sample or None if no new data became available until timeout.</p>"},{"location":"api/datastructures/fifo/#hermes.datastructures.fifo.TimestampAlignedFifoBuffer.yeet(timeout)","title":"<code>timeout</code>","text":""},{"location":"api/datastructures/fifo/#hermes.datastructures.fifo.TimestampToCounterConverter","title":"TimestampToCounterConverter","text":"<p>A counter value converter from overflowing fixed range timestamp to non-overflowing counter values, starting at 0 for the first received sample.</p> <p>Converts overflowing monotonically increasing timestamp of a certain sample rate from a sensor into a non-overflowing counter value, starting counting from 0, regardless of device's actual onboard timestamp.</p> <p>Methods:</p> Name Description <code>__init__</code> <p>Constructor of the TimestampToCounterConverter.</p>"},{"location":"api/datastructures/fifo/#hermes.datastructures.fifo.TimestampToCounterConverter.__init__","title":"__init__","text":"<pre><code>__init__(keys: Iterable[Any], sampling_period: int, counter_limit: int)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>Iterable[Any]</code> <p>Set of uniquely identifying channel keys.</p> required <code>int</code> <p>Sampling period in the same units as timestamp limit and timestamps.</p> required <code>int</code> <p>The upper counting limit of the sensor's timestamp.</p> required"},{"location":"api/datastructures/fifo/#hermes.datastructures.fifo.TimestampToCounterConverter.__init__(keys)","title":"<code>keys</code>","text":""},{"location":"api/datastructures/fifo/#hermes.datastructures.fifo.TimestampToCounterConverter.__init__(sampling_period)","title":"<code>sampling_period</code>","text":""},{"location":"api/datastructures/fifo/#hermes.datastructures.fifo.TimestampToCounterConverter.__init__(counter_limit)","title":"<code>counter_limit</code>","text":""},{"location":"api/datastructures/fifo/#hermes.datastructures.fifo.TimestampToCounterConverter._bar","title":"_bar","text":"<pre><code>_bar(key: Any, timestamp: int | float) -&gt; int | float | None\n</code></pre> <p>Optimized counter converter function for continuous steady-state operation.</p> <p>Measures the change in time between 2 measurements w.r.t. sensor device time and the max value before overlow. dt &gt; 0 always thanks to modulo, even if sensor on-board clock overflows. Converts to the number of sample periods in the measured time delta window, allowing for slight skew. Rolling correlation using sample rate, previous and current time is more accurate than averaging over whole timelife.</p> <p>Parameters:</p> Name Type Description Default <code>Any</code> <p>The unique identifier of the channel.</p> required <code>int</code> <p>Monotonically increasing overflowing integer from a sensor.</p> required <p>Returns:</p> Type Description <code>int | float | None</code> <p>int | None: Converted counter value starting at 0 counter value.</p>"},{"location":"api/datastructures/fifo/#hermes.datastructures.fifo.TimestampToCounterConverter._bar(key)","title":"<code>key</code>","text":""},{"location":"api/datastructures/fifo/#hermes.datastructures.fifo.TimestampToCounterConverter._bar(timestamp)","title":"<code>timestamp</code>","text":""},{"location":"api/datastructures/fifo/#hermes.datastructures.fifo.TimestampToCounterConverter._foo","title":"_foo","text":"<pre><code>_foo(key: Any, timestamp: int | float) -&gt; int | float | None\n</code></pre> <p>Startup multi-channel function that converts correlated over-flowing timestamp values from asynchronous sensors to a non-overflowing counter.</p> <p>Sets the start time according to the first received packet and switches to the monotone calculation routine after. Has some tolerance to temporally skewed samples, when the skew is less than hald a sampling period. If the channel sample is the first in the overall buffer, will use it as reference starting point onward. Will return 0 start counter at the end of the function.</p> <p>If it's not the very first packet, but first reading for this device, records if the capture was during or after the start reference. If the measurement taken during or after the reference measurement and no chance for overflow, will return 0 start counter at the end of the function. If the measurement taken after the overflow of the on-sensor clock and effectively after the reference measurement, will return 0 start counter at the end of the function. Will discard the sample as stale to ensure alignment otherwise.</p> <p>Parameters:</p> Name Type Description Default <code>Any</code> <p>The unique identifier of the channel.</p> required <code>int</code> <p>Monotonically increasing overflowing integer from a sensor.</p> required <p>Returns:</p> Type Description <code>int | float | None</code> <p>int | None: Converted counter value starting at 0 counter value.</p>"},{"location":"api/datastructures/fifo/#hermes.datastructures.fifo.TimestampToCounterConverter._foo(key)","title":"<code>key</code>","text":""},{"location":"api/datastructures/fifo/#hermes.datastructures.fifo.TimestampToCounterConverter._foo(timestamp)","title":"<code>timestamp</code>","text":""},{"location":"api/nodes/","title":"Overview","text":"<p>TODO: details of the <code>nodes</code> module structure and function.</p>"},{"location":"api/nodes/consumer/","title":"hermes.base.nodes","text":"<p>The module is responsible for wrapping common functionality of Consumer Nodes. It defines a unified interface to the ZeroMQ message exchange layer for all concrete Consumers.</p> <p><code>consumer_interface</code> - base interface for Consumer function.</p> <p><code>consumer</code> - abstract Consumer with common data ingestion logic to subclass.</p>"},{"location":"api/nodes/consumer/#hermes.base.nodes.consumer_interface","title":"consumer_interface","text":"<p>Classes:</p> Name Description <code>ConsumerInterface</code> <p>Interface for the Consumer Node component.</p>"},{"location":"api/nodes/consumer/#hermes.base.nodes.consumer_interface.ConsumerInterface","title":"ConsumerInterface","text":"<p>               Bases: <code>NodeInterface</code></p> <pre><code>\n              flowchart TD\n              hermes.base.nodes.consumer_interface.ConsumerInterface[ConsumerInterface]\n              hermes.base.nodes.node_interface.NodeInterface[NodeInterface]\n\n                              hermes.base.nodes.node_interface.NodeInterface --&gt; hermes.base.nodes.consumer_interface.ConsumerInterface\n                \n\n\n              click hermes.base.nodes.consumer_interface.ConsumerInterface href \"\" \"hermes.base.nodes.consumer_interface.ConsumerInterface\"\n              click hermes.base.nodes.node_interface.NodeInterface href \"\" \"hermes.base.nodes.node_interface.NodeInterface\"\n            </code></pre> <p>Interface for the Consumer Node component.</p>"},{"location":"api/nodes/consumer/#hermes.base.nodes.consumer_interface.ConsumerInterface._is_done","title":"_is_done  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>_is_done: bool\n</code></pre> <p>Read-only property identifying if the Node completed operation.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Whether the Node completed its function.</p>"},{"location":"api/nodes/consumer/#hermes.base.nodes.consumer_interface.ConsumerInterface._activate_data_poller","title":"_activate_data_poller  <code>abstractmethod</code>","text":"<pre><code>_activate_data_poller() -&gt; None\n</code></pre> <p>Start listening for new data from other Nodes.</p>"},{"location":"api/nodes/consumer/#hermes.base.nodes.consumer_interface.ConsumerInterface._activate_kill_poller","title":"_activate_kill_poller  <code>abstractmethod</code>","text":"<pre><code>_activate_kill_poller() -&gt; None\n</code></pre> <p>Start listening for the KILL signal on the special PUB/SUB socket that coordinates program termination.</p>"},{"location":"api/nodes/consumer/#hermes.base.nodes.consumer_interface.ConsumerInterface._deactivate_kill_poller","title":"_deactivate_kill_poller  <code>abstractmethod</code>","text":"<pre><code>_deactivate_kill_poller() -&gt; None\n</code></pre> <p>Stop listening for the KILL signal.</p>"},{"location":"api/nodes/consumer/#hermes.base.nodes.consumer_interface.ConsumerInterface._get_sync_socket","title":"_get_sync_socket  <code>abstractmethod</code>","text":"<pre><code>_get_sync_socket() -&gt; SyncSocket\n</code></pre> <p>Get reference to the socket used for synchronization of the Node to its master Broker.</p> <p>Returns:</p> Type Description <code>SyncSocket</code> <p>zmq.SyncSocket: ZeroMQ socket of the Node connected to the local master Broker.</p>"},{"location":"api/nodes/consumer/#hermes.base.nodes.consumer_interface.ConsumerInterface._initialize","title":"_initialize  <code>abstractmethod</code>","text":"<pre><code>_initialize() -&gt; None\n</code></pre> <p>Node-specific initialization procedure.</p> <p>Pre-run setup of the backend specific to the Node implementaiton. Generic setup should be run first.</p>"},{"location":"api/nodes/consumer/#hermes.base.nodes.consumer_interface.ConsumerInterface._log_source_tag","title":"_log_source_tag  <code>abstractmethod</code> <code>classmethod</code>","text":"<pre><code>_log_source_tag() -&gt; str\n</code></pre> <p>Read-only property uniquely identifying the Node.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Unique key identifying the Node in the data exchange.</p>"},{"location":"api/nodes/consumer/#hermes.base.nodes.consumer_interface.ConsumerInterface._on_poll","title":"_on_poll  <code>abstractmethod</code>","text":"<pre><code>_on_poll(poll_res: tuple[list[SyncSocket], list[int]]) -&gt; None\n</code></pre> <p>Callback to perform some logic everytime some data transactions are received by the Poller.</p> <p>Generic entry-point for all types of Nodes, based on their active Poller settings. NOTE: if Node in JoinState, kill socket is no longer in the Poller and only higher-level logic is triggered.</p> <p>Parameters:</p> Name Type Description Default <code>tuple[list[SyncSocket], list[int]]</code> <p>Reference to the complete captured result of listening by the Poller.</p> required"},{"location":"api/nodes/consumer/#hermes.base.nodes.consumer_interface.ConsumerInterface._on_poll(poll_res)","title":"<code>poll_res</code>","text":""},{"location":"api/nodes/consumer/#hermes.base.nodes.consumer_interface.ConsumerInterface._on_sync_complete","title":"_on_sync_complete  <code>abstractmethod</code>","text":"<pre><code>_on_sync_complete() -&gt; None\n</code></pre> <p>Callback to perform some logic after synchronization of Nodes is completed and indicated by the Broker.</p>"},{"location":"api/nodes/consumer/#hermes.base.nodes.consumer_interface.ConsumerInterface._poll","title":"_poll  <code>abstractmethod</code>","text":"<pre><code>_poll() -&gt; tuple[list[SyncSocket], list[int]]\n</code></pre> <p>Block for new ZeroMQ data to collect at the Poller.</p> <p>Listens for events when new data is received from or when new data can be written to sockets, based on the active Poller settings of the Node implementation.</p> <p>Returns:</p> Type Description <code>tuple[list[SyncSocket], list[int]]</code> <p>tuple[list[zmq.SyncSocket], list[int]]: Result of listening on the sockets registered by the Poller.</p>"},{"location":"api/nodes/consumer/#hermes.base.nodes.consumer_interface.ConsumerInterface._send_kill_to_broker","title":"_send_kill_to_broker  <code>abstractmethod</code>","text":"<pre><code>_send_kill_to_broker() -&gt; None\n</code></pre> <p>Send a slave KILL signal to the local Broker in case program termination by the slave Node is recorded.</p>"},{"location":"api/nodes/consumer/#hermes.base.nodes.consumer_interface.ConsumerInterface._set_state","title":"_set_state  <code>abstractmethod</code>","text":"<pre><code>_set_state(state) -&gt; None\n</code></pre> <p>User-defined logic for FSM state transition.</p> <p>Parameters:</p> Name Type Description Default <code>Any</code> <p>New state to transition to.</p> required"},{"location":"api/nodes/consumer/#hermes.base.nodes.consumer_interface.ConsumerInterface._set_state(state)","title":"<code>state</code>","text":""},{"location":"api/nodes/consumer/#hermes.base.nodes.consumer_interface.ConsumerInterface._trigger_stop","title":"_trigger_stop  <code>abstractmethod</code>","text":"<pre><code>_trigger_stop() -&gt; None\n</code></pre> <p>Trigger to the Node's internal procedures and background threads to gracefully wrap-up.</p> <p>Producer: stops sampling data, continue sending already captured until none is left, with last message labeled 'END'. Consumer: continues listening to data until each of subscribed Producers sent the last message. Pipeline: continues listening to data to produce results until each data sources sent the last message, and then labels the last message with 'END'.</p>"},{"location":"api/nodes/consumer/#hermes.base.nodes.consumer","title":"consumer","text":"<p>Classes:</p> Name Description <code>Consumer</code> <p>An abstract class to interface with a particular data consumer.</p>"},{"location":"api/nodes/consumer/#hermes.base.nodes.consumer.Consumer","title":"Consumer","text":"<p>               Bases: <code>ConsumerInterface</code>, <code>Node</code></p> <pre><code>\n              flowchart TD\n              hermes.base.nodes.consumer.Consumer[Consumer]\n              hermes.base.nodes.consumer_interface.ConsumerInterface[ConsumerInterface]\n              hermes.base.nodes.node.Node[Node]\n              hermes.base.nodes.node_interface.NodeInterface[NodeInterface]\n\n                              hermes.base.nodes.consumer_interface.ConsumerInterface --&gt; hermes.base.nodes.consumer.Consumer\n                                hermes.base.nodes.node_interface.NodeInterface --&gt; hermes.base.nodes.consumer_interface.ConsumerInterface\n                \n\n                hermes.base.nodes.node.Node --&gt; hermes.base.nodes.consumer.Consumer\n                                hermes.base.nodes.node_interface.NodeInterface --&gt; hermes.base.nodes.node.Node\n                \n\n\n\n              click hermes.base.nodes.consumer.Consumer href \"\" \"hermes.base.nodes.consumer.Consumer\"\n              click hermes.base.nodes.consumer_interface.ConsumerInterface href \"\" \"hermes.base.nodes.consumer_interface.ConsumerInterface\"\n              click hermes.base.nodes.node.Node href \"\" \"hermes.base.nodes.node.Node\"\n              click hermes.base.nodes.node_interface.NodeInterface href \"\" \"hermes.base.nodes.node_interface.NodeInterface\"\n            </code></pre> <p>An abstract class to interface with a particular data consumer.</p> <p>Subscribes to the modalities specified in and parametrized by <code>stream_in_specs</code>.</p> <p>Methods:</p> Name Description <code>__call__</code> <p>Node objects are callable to start the FSM as entry-point.</p> <code>__init__</code> <p>Constructor of the Consumer parent class.</p>"},{"location":"api/nodes/consumer/#hermes.base.nodes.consumer.Consumer.__call__","title":"__call__","text":"<pre><code>__call__()\n</code></pre> <p>Node objects are callable to start the FSM as entry-point.</p>"},{"location":"api/nodes/consumer/#hermes.base.nodes.consumer.Consumer.__init__","title":"__init__","text":"<pre><code>__init__(\n    host_ip: str,\n    stream_in_specs: list[dict],\n    logging_spec: LoggingSpec,\n    port_sub: str = PORT_FRONTEND,\n    port_sync: str = PORT_SYNC_HOST,\n    port_killsig: str = PORT_KILL,\n) -&gt; None\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>IP address of the local master Broker.</p> required <code>list[dict]</code> <p>List of mappings of user-configured incoming modalities.</p> required <code>LoggingSpec</code> <p>Specification of what and how to store.</p> required <code>str</code> <p>Local port to subscribe to for incoming relayed data from the local master Broker. Defaults to <code>PORT_FRONTEND</code>.</p> <code>PORT_FRONTEND</code> <code>str</code> <p>Local port to listen to for local master Broker's startup coordination. Defaults to <code>PORT_SYNC_HOST</code>.</p> <code>PORT_SYNC_HOST</code> <code>str</code> <p>Local port to listen to for local master Broker's termination signal. Defaults to <code>PORT_KILL</code>.</p> <code>PORT_KILL</code>"},{"location":"api/nodes/consumer/#hermes.base.nodes.consumer.Consumer.__init__(host_ip)","title":"<code>host_ip</code>","text":""},{"location":"api/nodes/consumer/#hermes.base.nodes.consumer.Consumer.__init__(stream_in_specs)","title":"<code>stream_in_specs</code>","text":""},{"location":"api/nodes/consumer/#hermes.base.nodes.consumer.Consumer.__init__(logging_spec)","title":"<code>logging_spec</code>","text":""},{"location":"api/nodes/consumer/#hermes.base.nodes.consumer.Consumer.__init__(port_sub)","title":"<code>port_sub</code>","text":""},{"location":"api/nodes/consumer/#hermes.base.nodes.consumer.Consumer.__init__(port_sync)","title":"<code>port_sync</code>","text":""},{"location":"api/nodes/consumer/#hermes.base.nodes.consumer.Consumer.__init__(port_killsig)","title":"<code>port_killsig</code>","text":""},{"location":"api/nodes/consumer/#hermes.base.nodes.consumer.Consumer._log_source_tag","title":"_log_source_tag  <code>abstractmethod</code> <code>classmethod</code>","text":"<pre><code>_log_source_tag() -&gt; str\n</code></pre> <p>Read-only property uniquely identifying the Node.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Unique key identifying the Node in the data exchange.</p>"},{"location":"api/nodes/consumer/#hermes.base.nodes.consumer.Consumer._poll_data_packets","title":"_poll_data_packets","text":"<pre><code>_poll_data_packets() -&gt; None\n</code></pre> <p>Receive data packets in a steady state.</p> <p>Gets called every time one of the requestes modalities produced new data. In normal operation mode, all messages are 2-part.</p>"},{"location":"api/nodes/consumer/#hermes.base.nodes.consumer.Consumer._poll_ending_data_packets","title":"_poll_ending_data_packets","text":"<pre><code>_poll_ending_data_packets() -&gt; None\n</code></pre> <p>Receive data packets from producers and monitor for end-of-stream signal.</p> <p>When system triggered a safe exit, Pipeline gets a mix of normal 2-part messages and 3-part 'END' message from each Producer that safely exited. It's more efficient to dynamically switch the callback instead of checking every message.</p> <p>Processes packets on each modality until all data sources sent the 'END' packet. If triggered to stop and no more available data, sends empty 'END' packet and joins.</p>"},{"location":"api/nodes/node/","title":"hermes.base.nodes","text":"<p>The module is responsible for wrapping common functionality of Nodes. It implements the FSM and defines unified state transitions for all the Nodes.</p> <p><code>node_interface</code> - base interface for Node function.</p> <p><code>node</code> - abstract FSM-based Node with common state transition logic.</p> <p><code>node_states</code> - FSM states of the Node.</p>"},{"location":"api/nodes/node/#hermes.base.nodes.node_interface","title":"node_interface","text":"<p>Classes:</p> Name Description <code>NodeInterface</code> <p>Interface for the Node components.</p>"},{"location":"api/nodes/node/#hermes.base.nodes.node_interface.NodeInterface","title":"NodeInterface","text":"<p>               Bases: <code>ABC</code></p> <pre><code>\n              flowchart TD\n              hermes.base.nodes.node_interface.NodeInterface[NodeInterface]\n\n              \n\n              click hermes.base.nodes.node_interface.NodeInterface href \"\" \"hermes.base.nodes.node_interface.NodeInterface\"\n            </code></pre> <p>Interface for the Node components.</p>"},{"location":"api/nodes/node/#hermes.base.nodes.node_interface.NodeInterface._is_done","title":"_is_done  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>_is_done: bool\n</code></pre> <p>Read-only property identifying if the Node completed operation.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Whether the Node completed its function.</p>"},{"location":"api/nodes/node/#hermes.base.nodes.node_interface.NodeInterface._activate_data_poller","title":"_activate_data_poller  <code>abstractmethod</code>","text":"<pre><code>_activate_data_poller() -&gt; None\n</code></pre> <p>Start listening for new data from other Nodes.</p>"},{"location":"api/nodes/node/#hermes.base.nodes.node_interface.NodeInterface._activate_kill_poller","title":"_activate_kill_poller  <code>abstractmethod</code>","text":"<pre><code>_activate_kill_poller() -&gt; None\n</code></pre> <p>Start listening for the KILL signal on the special PUB/SUB socket that coordinates program termination.</p>"},{"location":"api/nodes/node/#hermes.base.nodes.node_interface.NodeInterface._deactivate_kill_poller","title":"_deactivate_kill_poller  <code>abstractmethod</code>","text":"<pre><code>_deactivate_kill_poller() -&gt; None\n</code></pre> <p>Stop listening for the KILL signal.</p>"},{"location":"api/nodes/node/#hermes.base.nodes.node_interface.NodeInterface._get_sync_socket","title":"_get_sync_socket  <code>abstractmethod</code>","text":"<pre><code>_get_sync_socket() -&gt; SyncSocket\n</code></pre> <p>Get reference to the socket used for synchronization of the Node to its master Broker.</p> <p>Returns:</p> Type Description <code>SyncSocket</code> <p>zmq.SyncSocket: ZeroMQ socket of the Node connected to the local master Broker.</p>"},{"location":"api/nodes/node/#hermes.base.nodes.node_interface.NodeInterface._initialize","title":"_initialize  <code>abstractmethod</code>","text":"<pre><code>_initialize() -&gt; None\n</code></pre> <p>Node-specific initialization procedure.</p> <p>Pre-run setup of the backend specific to the Node implementaiton. Generic setup should be run first.</p>"},{"location":"api/nodes/node/#hermes.base.nodes.node_interface.NodeInterface._log_source_tag","title":"_log_source_tag  <code>abstractmethod</code> <code>classmethod</code>","text":"<pre><code>_log_source_tag() -&gt; str\n</code></pre> <p>Read-only property uniquely identifying the Node.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Unique key identifying the Node in the data exchange.</p>"},{"location":"api/nodes/node/#hermes.base.nodes.node_interface.NodeInterface._on_poll","title":"_on_poll  <code>abstractmethod</code>","text":"<pre><code>_on_poll(poll_res: tuple[list[SyncSocket], list[int]]) -&gt; None\n</code></pre> <p>Callback to perform some logic everytime some data transactions are received by the Poller.</p> <p>Generic entry-point for all types of Nodes, based on their active Poller settings. NOTE: if Node in JoinState, kill socket is no longer in the Poller and only higher-level logic is triggered.</p> <p>Parameters:</p> Name Type Description Default <code>tuple[list[SyncSocket], list[int]]</code> <p>Reference to the complete captured result of listening by the Poller.</p> required"},{"location":"api/nodes/node/#hermes.base.nodes.node_interface.NodeInterface._on_poll(poll_res)","title":"<code>poll_res</code>","text":""},{"location":"api/nodes/node/#hermes.base.nodes.node_interface.NodeInterface._on_sync_complete","title":"_on_sync_complete  <code>abstractmethod</code>","text":"<pre><code>_on_sync_complete() -&gt; None\n</code></pre> <p>Callback to perform some logic after synchronization of Nodes is completed and indicated by the Broker.</p>"},{"location":"api/nodes/node/#hermes.base.nodes.node_interface.NodeInterface._poll","title":"_poll  <code>abstractmethod</code>","text":"<pre><code>_poll() -&gt; tuple[list[SyncSocket], list[int]]\n</code></pre> <p>Block for new ZeroMQ data to collect at the Poller.</p> <p>Listens for events when new data is received from or when new data can be written to sockets, based on the active Poller settings of the Node implementation.</p> <p>Returns:</p> Type Description <code>tuple[list[SyncSocket], list[int]]</code> <p>tuple[list[zmq.SyncSocket], list[int]]: Result of listening on the sockets registered by the Poller.</p>"},{"location":"api/nodes/node/#hermes.base.nodes.node_interface.NodeInterface._send_kill_to_broker","title":"_send_kill_to_broker  <code>abstractmethod</code>","text":"<pre><code>_send_kill_to_broker() -&gt; None\n</code></pre> <p>Send a slave KILL signal to the local Broker in case program termination by the slave Node is recorded.</p>"},{"location":"api/nodes/node/#hermes.base.nodes.node_interface.NodeInterface._set_state","title":"_set_state  <code>abstractmethod</code>","text":"<pre><code>_set_state(state) -&gt; None\n</code></pre> <p>User-defined logic for FSM state transition.</p> <p>Parameters:</p> Name Type Description Default <code>Any</code> <p>New state to transition to.</p> required"},{"location":"api/nodes/node/#hermes.base.nodes.node_interface.NodeInterface._set_state(state)","title":"<code>state</code>","text":""},{"location":"api/nodes/node/#hermes.base.nodes.node_interface.NodeInterface._trigger_stop","title":"_trigger_stop  <code>abstractmethod</code>","text":"<pre><code>_trigger_stop() -&gt; None\n</code></pre> <p>Trigger to the Node's internal procedures and background threads to gracefully wrap-up.</p> <p>Producer: stops sampling data, continue sending already captured until none is left, with last message labeled 'END'. Consumer: continues listening to data until each of subscribed Producers sent the last message. Pipeline: continues listening to data to produce results until each data sources sent the last message, and then labels the last message with 'END'.</p>"},{"location":"api/nodes/node/#hermes.base.nodes.node","title":"node","text":"<p>Classes:</p> Name Description <code>Node</code> <p>An abstract class with common functionality for concrete Nodes.</p>"},{"location":"api/nodes/node/#hermes.base.nodes.node.Node","title":"Node","text":"<p>               Bases: <code>NodeInterface</code></p> <pre><code>\n              flowchart TD\n              hermes.base.nodes.node.Node[Node]\n              hermes.base.nodes.node_interface.NodeInterface[NodeInterface]\n\n                              hermes.base.nodes.node_interface.NodeInterface --&gt; hermes.base.nodes.node.Node\n                \n\n\n              click hermes.base.nodes.node.Node href \"\" \"hermes.base.nodes.node.Node\"\n              click hermes.base.nodes.node_interface.NodeInterface href \"\" \"hermes.base.nodes.node_interface.NodeInterface\"\n            </code></pre> <p>An abstract class with common functionality for concrete Nodes.</p> <p>Methods:</p> Name Description <code>__call__</code> <p>Node objects are callable to start the FSM as entry-point.</p> <code>__init__</code> <p>Constructor of the Node parent class.</p>"},{"location":"api/nodes/node/#hermes.base.nodes.node.Node.__call__","title":"__call__","text":"<pre><code>__call__()\n</code></pre> <p>Node objects are callable to start the FSM as entry-point.</p>"},{"location":"api/nodes/node/#hermes.base.nodes.node.Node.__init__","title":"__init__","text":"<pre><code>__init__(\n    ref_time: float,\n    host_ip: str = DNS_LOCALHOST,\n    port_sync: str = PORT_SYNC_HOST,\n    port_killsig: str = PORT_KILL,\n) -&gt; None\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>float</code> <p>Reference time of the local Broker w.r.t which to align all Nodes.</p> required <code>str</code> <p>IP address of the local master Broker. Defaults to <code>DNS_LOCALHOST</code>.</p> <code>DNS_LOCALHOST</code> <code>str</code> <p>Local port to listen to for local master Broker's startup coordination. Defaults to <code>PORT_SYNC_HOST</code>.</p> <code>PORT_SYNC_HOST</code> <code>str</code> <p>Local port to listen to for local master Broker's termination signal. Defaults to <code>PORT_KILL</code>.</p> <code>PORT_KILL</code>"},{"location":"api/nodes/node/#hermes.base.nodes.node.Node.__init__(ref_time)","title":"<code>ref_time</code>","text":""},{"location":"api/nodes/node/#hermes.base.nodes.node.Node.__init__(host_ip)","title":"<code>host_ip</code>","text":""},{"location":"api/nodes/node/#hermes.base.nodes.node.Node.__init__(port_sync)","title":"<code>port_sync</code>","text":""},{"location":"api/nodes/node/#hermes.base.nodes.node.Node.__init__(port_killsig)","title":"<code>port_killsig</code>","text":""},{"location":"api/nodes/node/#hermes.base.nodes.node.Node._cleanup","title":"_cleanup  <code>abstractmethod</code>","text":"<pre><code>_cleanup()\n</code></pre> <p>Release of generic Node resources, must be done after releasing higher-level resources.</p>"},{"location":"api/nodes/node/#hermes.base.nodes.node.Node._log_source_tag","title":"_log_source_tag  <code>abstractmethod</code> <code>classmethod</code>","text":"<pre><code>_log_source_tag() -&gt; str\n</code></pre> <p>Read-only property uniquely identifying the Node.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Unique key identifying the Node in the data exchange.</p>"},{"location":"api/nodes/node/#hermes.base.nodes.node.Node._on_sync_complete","title":"_on_sync_complete  <code>abstractmethod</code>","text":"<pre><code>_on_sync_complete() -&gt; None\n</code></pre> <p>Callback to perform some logic after synchronization of Nodes is completed and indicated by the Broker.</p>"},{"location":"api/nodes/node/#hermes.base.nodes.node_states","title":"node_states","text":"<p>Classes:</p> Name Description <code>AbstractNodeState</code> <p>Abstract class for the Node FSM.</p> <code>JoinState</code> <p>Gracefully exit state of the Node to coordinate closure to the local master Broker.</p> <code>KillState</code> <p>Termination state of the Node that gracefully processes the external KILL signal from the local master Broker.</p> <code>RunningState</code> <p>Running state of the Node with the steady-state main loop listening for data and triggering user-provided callbacks on it.</p> <code>StartState</code> <p>Starting state of the Node that initializes corresponding internal logic of the specified Node.</p> <code>SyncState</code> <p>Synchronization state of the Node to coordinate readiness to start working to the local master Broker.</p>"},{"location":"api/nodes/node/#hermes.base.nodes.node_states.AbstractNodeState","title":"AbstractNodeState","text":"<p>               Bases: <code>StateInterface</code></p> <pre><code>\n              flowchart TD\n              hermes.base.nodes.node_states.AbstractNodeState[AbstractNodeState]\n              hermes.base.state_interface.StateInterface[StateInterface]\n\n                              hermes.base.state_interface.StateInterface --&gt; hermes.base.nodes.node_states.AbstractNodeState\n                \n\n\n              click hermes.base.nodes.node_states.AbstractNodeState href \"\" \"hermes.base.nodes.node_states.AbstractNodeState\"\n              click hermes.base.state_interface.StateInterface href \"\" \"hermes.base.state_interface.StateInterface\"\n            </code></pre> <p>Abstract class for the Node FSM.</p> <p>Can be externally triggered into the KILL state from any child State class.</p> <p>Methods:</p> Name Description <code>__init__</code> <p>Constructor of the AbstractNodeState parent class.</p> <code>run</code> <p>Run the logic of the currently selected state.</p>"},{"location":"api/nodes/node/#hermes.base.nodes.node_states.AbstractNodeState.__init__","title":"__init__","text":"<pre><code>__init__(context: NodeInterface)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>NodeInterface</code> <p>Reference to the Node object.</p> required"},{"location":"api/nodes/node/#hermes.base.nodes.node_states.AbstractNodeState.__init__(context)","title":"<code>context</code>","text":""},{"location":"api/nodes/node/#hermes.base.nodes.node_states.AbstractNodeState.run","title":"run  <code>abstractmethod</code>","text":"<pre><code>run() -&gt; None\n</code></pre> <p>Run the logic of the currently selected state.</p>"},{"location":"api/nodes/node/#hermes.base.nodes.node_states.JoinState","title":"JoinState","text":"<p>               Bases: <code>AbstractNodeState</code></p> <pre><code>\n              flowchart TD\n              hermes.base.nodes.node_states.JoinState[JoinState]\n              hermes.base.nodes.node_states.AbstractNodeState[AbstractNodeState]\n              hermes.base.state_interface.StateInterface[StateInterface]\n\n                              hermes.base.nodes.node_states.AbstractNodeState --&gt; hermes.base.nodes.node_states.JoinState\n                                hermes.base.state_interface.StateInterface --&gt; hermes.base.nodes.node_states.AbstractNodeState\n                \n\n\n\n              click hermes.base.nodes.node_states.JoinState href \"\" \"hermes.base.nodes.node_states.JoinState\"\n              click hermes.base.nodes.node_states.AbstractNodeState href \"\" \"hermes.base.nodes.node_states.AbstractNodeState\"\n              click hermes.base.state_interface.StateInterface href \"\" \"hermes.base.state_interface.StateInterface\"\n            </code></pre> <p>Gracefully exit state of the Node to coordinate closure to the local master Broker.</p> <p>Methods:</p> Name Description <code>__init__</code> <p>Constructor of the AbstractNodeState parent class.</p>"},{"location":"api/nodes/node/#hermes.base.nodes.node_states.JoinState.__init__","title":"__init__","text":"<pre><code>__init__(context: NodeInterface)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>NodeInterface</code> <p>Reference to the Node object.</p> required"},{"location":"api/nodes/node/#hermes.base.nodes.node_states.JoinState.__init__(context)","title":"<code>context</code>","text":""},{"location":"api/nodes/node/#hermes.base.nodes.node_states.KillState","title":"KillState","text":"<p>               Bases: <code>AbstractNodeState</code></p> <pre><code>\n              flowchart TD\n              hermes.base.nodes.node_states.KillState[KillState]\n              hermes.base.nodes.node_states.AbstractNodeState[AbstractNodeState]\n              hermes.base.state_interface.StateInterface[StateInterface]\n\n                              hermes.base.nodes.node_states.AbstractNodeState --&gt; hermes.base.nodes.node_states.KillState\n                                hermes.base.state_interface.StateInterface --&gt; hermes.base.nodes.node_states.AbstractNodeState\n                \n\n\n\n              click hermes.base.nodes.node_states.KillState href \"\" \"hermes.base.nodes.node_states.KillState\"\n              click hermes.base.nodes.node_states.AbstractNodeState href \"\" \"hermes.base.nodes.node_states.AbstractNodeState\"\n              click hermes.base.state_interface.StateInterface href \"\" \"hermes.base.state_interface.StateInterface\"\n            </code></pre> <p>Termination state of the Node that gracefully processes the external KILL signal from the local master Broker.</p> <p>Methods:</p> Name Description <code>__init__</code> <p>Constructor of the AbstractNodeState parent class.</p>"},{"location":"api/nodes/node/#hermes.base.nodes.node_states.KillState.__init__","title":"__init__","text":"<pre><code>__init__(context: NodeInterface)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>NodeInterface</code> <p>Reference to the Node object.</p> required"},{"location":"api/nodes/node/#hermes.base.nodes.node_states.KillState.__init__(context)","title":"<code>context</code>","text":""},{"location":"api/nodes/node/#hermes.base.nodes.node_states.RunningState","title":"RunningState","text":"<p>               Bases: <code>AbstractNodeState</code></p> <pre><code>\n              flowchart TD\n              hermes.base.nodes.node_states.RunningState[RunningState]\n              hermes.base.nodes.node_states.AbstractNodeState[AbstractNodeState]\n              hermes.base.state_interface.StateInterface[StateInterface]\n\n                              hermes.base.nodes.node_states.AbstractNodeState --&gt; hermes.base.nodes.node_states.RunningState\n                                hermes.base.state_interface.StateInterface --&gt; hermes.base.nodes.node_states.AbstractNodeState\n                \n\n\n\n              click hermes.base.nodes.node_states.RunningState href \"\" \"hermes.base.nodes.node_states.RunningState\"\n              click hermes.base.nodes.node_states.AbstractNodeState href \"\" \"hermes.base.nodes.node_states.AbstractNodeState\"\n              click hermes.base.state_interface.StateInterface href \"\" \"hermes.base.state_interface.StateInterface\"\n            </code></pre> <p>Running state of the Node with the steady-state main loop listening for data and triggering user-provided callbacks on it.</p>"},{"location":"api/nodes/node/#hermes.base.nodes.node_states.StartState","title":"StartState","text":"<p>               Bases: <code>AbstractNodeState</code></p> <pre><code>\n              flowchart TD\n              hermes.base.nodes.node_states.StartState[StartState]\n              hermes.base.nodes.node_states.AbstractNodeState[AbstractNodeState]\n              hermes.base.state_interface.StateInterface[StateInterface]\n\n                              hermes.base.nodes.node_states.AbstractNodeState --&gt; hermes.base.nodes.node_states.StartState\n                                hermes.base.state_interface.StateInterface --&gt; hermes.base.nodes.node_states.AbstractNodeState\n                \n\n\n\n              click hermes.base.nodes.node_states.StartState href \"\" \"hermes.base.nodes.node_states.StartState\"\n              click hermes.base.nodes.node_states.AbstractNodeState href \"\" \"hermes.base.nodes.node_states.AbstractNodeState\"\n              click hermes.base.state_interface.StateInterface href \"\" \"hermes.base.state_interface.StateInterface\"\n            </code></pre> <p>Starting state of the Node that initializes corresponding internal logic of the specified Node.</p> <p>Activates data poller in case Node goes into KillState.</p> <p>Methods:</p> Name Description <code>__init__</code> <p>Constructor of the AbstractNodeState parent class.</p>"},{"location":"api/nodes/node/#hermes.base.nodes.node_states.StartState.__init__","title":"__init__","text":"<pre><code>__init__(context: NodeInterface)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>NodeInterface</code> <p>Reference to the Node object.</p> required"},{"location":"api/nodes/node/#hermes.base.nodes.node_states.StartState.__init__(context)","title":"<code>context</code>","text":""},{"location":"api/nodes/node/#hermes.base.nodes.node_states.SyncState","title":"SyncState","text":"<p>               Bases: <code>AbstractNodeState</code></p> <pre><code>\n              flowchart TD\n              hermes.base.nodes.node_states.SyncState[SyncState]\n              hermes.base.nodes.node_states.AbstractNodeState[AbstractNodeState]\n              hermes.base.state_interface.StateInterface[StateInterface]\n\n                              hermes.base.nodes.node_states.AbstractNodeState --&gt; hermes.base.nodes.node_states.SyncState\n                                hermes.base.state_interface.StateInterface --&gt; hermes.base.nodes.node_states.AbstractNodeState\n                \n\n\n\n              click hermes.base.nodes.node_states.SyncState href \"\" \"hermes.base.nodes.node_states.SyncState\"\n              click hermes.base.nodes.node_states.AbstractNodeState href \"\" \"hermes.base.nodes.node_states.AbstractNodeState\"\n              click hermes.base.state_interface.StateInterface href \"\" \"hermes.base.state_interface.StateInterface\"\n            </code></pre> <p>Synchronization state of the Node to coordinate readiness to start working to the local master Broker.</p>"},{"location":"api/nodes/pipeline/","title":"hermes.base.nodes","text":"<p>The module is responsible for wrapping common functionality of Pipeline Nodes. It defines a unified interface to the ZeroMQ message exchange layer for all concrete Pipelines.</p> <p><code>pipeline_interface</code> - base interface for Pipeline function.</p> <p><code>pipeline</code> - abstract Pipeline with common data generation and ingestion logic to subclass.</p>"},{"location":"api/nodes/pipeline/#hermes.base.nodes.pipeline_interface","title":"pipeline_interface","text":"<p>Classes:</p> Name Description <code>PipelineInterface</code> <p>Interface for the Pipeline Node component.</p>"},{"location":"api/nodes/pipeline/#hermes.base.nodes.pipeline_interface.PipelineInterface","title":"PipelineInterface","text":"<p>               Bases: <code>NodeInterface</code></p> <pre><code>\n              flowchart TD\n              hermes.base.nodes.pipeline_interface.PipelineInterface[PipelineInterface]\n              hermes.base.nodes.node_interface.NodeInterface[NodeInterface]\n\n                              hermes.base.nodes.node_interface.NodeInterface --&gt; hermes.base.nodes.pipeline_interface.PipelineInterface\n                \n\n\n              click hermes.base.nodes.pipeline_interface.PipelineInterface href \"\" \"hermes.base.nodes.pipeline_interface.PipelineInterface\"\n              click hermes.base.nodes.node_interface.NodeInterface href \"\" \"hermes.base.nodes.node_interface.NodeInterface\"\n            </code></pre> <p>Interface for the Pipeline Node component.</p> <p>Methods:</p> Name Description <code>create_stream</code> <p>Instantiate Stream datastructure object specific to this Pipeline.</p>"},{"location":"api/nodes/pipeline/#hermes.base.nodes.pipeline_interface.PipelineInterface._is_done","title":"_is_done  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>_is_done: bool\n</code></pre> <p>Read-only property identifying if the Node completed operation.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Whether the Node completed its function.</p>"},{"location":"api/nodes/pipeline/#hermes.base.nodes.pipeline_interface.PipelineInterface._activate_data_poller","title":"_activate_data_poller  <code>abstractmethod</code>","text":"<pre><code>_activate_data_poller() -&gt; None\n</code></pre> <p>Start listening for new data from other Nodes.</p>"},{"location":"api/nodes/pipeline/#hermes.base.nodes.pipeline_interface.PipelineInterface._activate_kill_poller","title":"_activate_kill_poller  <code>abstractmethod</code>","text":"<pre><code>_activate_kill_poller() -&gt; None\n</code></pre> <p>Start listening for the KILL signal on the special PUB/SUB socket that coordinates program termination.</p>"},{"location":"api/nodes/pipeline/#hermes.base.nodes.pipeline_interface.PipelineInterface._deactivate_kill_poller","title":"_deactivate_kill_poller  <code>abstractmethod</code>","text":"<pre><code>_deactivate_kill_poller() -&gt; None\n</code></pre> <p>Stop listening for the KILL signal.</p>"},{"location":"api/nodes/pipeline/#hermes.base.nodes.pipeline_interface.PipelineInterface._get_sync_socket","title":"_get_sync_socket  <code>abstractmethod</code>","text":"<pre><code>_get_sync_socket() -&gt; SyncSocket\n</code></pre> <p>Get reference to the socket used for synchronization of the Node to its master Broker.</p> <p>Returns:</p> Type Description <code>SyncSocket</code> <p>zmq.SyncSocket: ZeroMQ socket of the Node connected to the local master Broker.</p>"},{"location":"api/nodes/pipeline/#hermes.base.nodes.pipeline_interface.PipelineInterface._initialize","title":"_initialize  <code>abstractmethod</code>","text":"<pre><code>_initialize() -&gt; None\n</code></pre> <p>Node-specific initialization procedure.</p> <p>Pre-run setup of the backend specific to the Node implementaiton. Generic setup should be run first.</p>"},{"location":"api/nodes/pipeline/#hermes.base.nodes.pipeline_interface.PipelineInterface._log_source_tag","title":"_log_source_tag  <code>abstractmethod</code> <code>classmethod</code>","text":"<pre><code>_log_source_tag() -&gt; str\n</code></pre> <p>Read-only property uniquely identifying the Node.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Unique key identifying the Node in the data exchange.</p>"},{"location":"api/nodes/pipeline/#hermes.base.nodes.pipeline_interface.PipelineInterface._on_poll","title":"_on_poll  <code>abstractmethod</code>","text":"<pre><code>_on_poll(poll_res: tuple[list[SyncSocket], list[int]]) -&gt; None\n</code></pre> <p>Callback to perform some logic everytime some data transactions are received by the Poller.</p> <p>Generic entry-point for all types of Nodes, based on their active Poller settings. NOTE: if Node in JoinState, kill socket is no longer in the Poller and only higher-level logic is triggered.</p> <p>Parameters:</p> Name Type Description Default <code>tuple[list[SyncSocket], list[int]]</code> <p>Reference to the complete captured result of listening by the Poller.</p> required"},{"location":"api/nodes/pipeline/#hermes.base.nodes.pipeline_interface.PipelineInterface._on_poll(poll_res)","title":"<code>poll_res</code>","text":""},{"location":"api/nodes/pipeline/#hermes.base.nodes.pipeline_interface.PipelineInterface._on_sync_complete","title":"_on_sync_complete  <code>abstractmethod</code>","text":"<pre><code>_on_sync_complete() -&gt; None\n</code></pre> <p>Callback to perform some logic after synchronization of Nodes is completed and indicated by the Broker.</p>"},{"location":"api/nodes/pipeline/#hermes.base.nodes.pipeline_interface.PipelineInterface._poll","title":"_poll  <code>abstractmethod</code>","text":"<pre><code>_poll() -&gt; tuple[list[SyncSocket], list[int]]\n</code></pre> <p>Block for new ZeroMQ data to collect at the Poller.</p> <p>Listens for events when new data is received from or when new data can be written to sockets, based on the active Poller settings of the Node implementation.</p> <p>Returns:</p> Type Description <code>tuple[list[SyncSocket], list[int]]</code> <p>tuple[list[zmq.SyncSocket], list[int]]: Result of listening on the sockets registered by the Poller.</p>"},{"location":"api/nodes/pipeline/#hermes.base.nodes.pipeline_interface.PipelineInterface._process_data","title":"_process_data  <code>abstractmethod</code>","text":"<pre><code>_process_data(topic: str, msg: dict) -&gt; None\n</code></pre> <p>Main iteration loop logic for the Node during its running phase.</p> <p>Contained logic has to deal with async multiple modalities. Must end with calling <code>_send_end_packet</code>.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>Uniquely identified modality of the contained data.</p> required <code>dict</code> <p>Received data of the corresponding modality.</p> required"},{"location":"api/nodes/pipeline/#hermes.base.nodes.pipeline_interface.PipelineInterface._process_data(topic)","title":"<code>topic</code>","text":""},{"location":"api/nodes/pipeline/#hermes.base.nodes.pipeline_interface.PipelineInterface._process_data(msg)","title":"<code>msg</code>","text":""},{"location":"api/nodes/pipeline/#hermes.base.nodes.pipeline_interface.PipelineInterface._send_kill_to_broker","title":"_send_kill_to_broker  <code>abstractmethod</code>","text":"<pre><code>_send_kill_to_broker() -&gt; None\n</code></pre> <p>Send a slave KILL signal to the local Broker in case program termination by the slave Node is recorded.</p>"},{"location":"api/nodes/pipeline/#hermes.base.nodes.pipeline_interface.PipelineInterface._set_state","title":"_set_state  <code>abstractmethod</code>","text":"<pre><code>_set_state(state) -&gt; None\n</code></pre> <p>User-defined logic for FSM state transition.</p> <p>Parameters:</p> Name Type Description Default <code>Any</code> <p>New state to transition to.</p> required"},{"location":"api/nodes/pipeline/#hermes.base.nodes.pipeline_interface.PipelineInterface._set_state(state)","title":"<code>state</code>","text":""},{"location":"api/nodes/pipeline/#hermes.base.nodes.pipeline_interface.PipelineInterface._stop_new_data","title":"_stop_new_data  <code>abstractmethod</code>","text":"<pre><code>_stop_new_data() -&gt; None\n</code></pre> <p>Stop sampling data, continue sending already captured until none is left.</p>"},{"location":"api/nodes/pipeline/#hermes.base.nodes.pipeline_interface.PipelineInterface._trigger_stop","title":"_trigger_stop  <code>abstractmethod</code>","text":"<pre><code>_trigger_stop() -&gt; None\n</code></pre> <p>Trigger to the Node's internal procedures and background threads to gracefully wrap-up.</p> <p>Producer: stops sampling data, continue sending already captured until none is left, with last message labeled 'END'. Consumer: continues listening to data until each of subscribed Producers sent the last message. Pipeline: continues listening to data to produce results until each data sources sent the last message, and then labels the last message with 'END'.</p>"},{"location":"api/nodes/pipeline/#hermes.base.nodes.pipeline_interface.PipelineInterface.create_stream","title":"create_stream  <code>abstractmethod</code> <code>classmethod</code>","text":"<pre><code>create_stream(stream_spec: dict) -&gt; Stream\n</code></pre> <p>Instantiate Stream datastructure object specific to this Pipeline.</p> <p>Should also be a class method to create Stream objects on consumers.</p> <p>Parameters:</p> Name Type Description Default <code>dict</code> <p>Mapping of corresponding Stream object parameters to user-defined configuration values.</p> required <p>Returns:</p> Name Type Description <code>Stream</code> <code>Stream</code> <p>Datastructure object of the corresponding Node, configured according to the user-provided specification.</p>"},{"location":"api/nodes/pipeline/#hermes.base.nodes.pipeline_interface.PipelineInterface.create_stream(stream_spec)","title":"<code>stream_spec</code>","text":""},{"location":"api/nodes/pipeline/#hermes.base.nodes.pipeline","title":"pipeline","text":"<p>Classes:</p> Name Description <code>Pipeline</code> <p>An abstract class to interface with a data-producing worker.</p>"},{"location":"api/nodes/pipeline/#hermes.base.nodes.pipeline.Pipeline","title":"Pipeline","text":"<p>               Bases: <code>PipelineInterface</code>, <code>Node</code></p> <pre><code>\n              flowchart TD\n              hermes.base.nodes.pipeline.Pipeline[Pipeline]\n              hermes.base.nodes.pipeline_interface.PipelineInterface[PipelineInterface]\n              hermes.base.nodes.node.Node[Node]\n              hermes.base.nodes.node_interface.NodeInterface[NodeInterface]\n\n                              hermes.base.nodes.pipeline_interface.PipelineInterface --&gt; hermes.base.nodes.pipeline.Pipeline\n                                hermes.base.nodes.node_interface.NodeInterface --&gt; hermes.base.nodes.pipeline_interface.PipelineInterface\n                \n\n                hermes.base.nodes.node.Node --&gt; hermes.base.nodes.pipeline.Pipeline\n                                hermes.base.nodes.node_interface.NodeInterface --&gt; hermes.base.nodes.node.Node\n                \n\n\n\n              click hermes.base.nodes.pipeline.Pipeline href \"\" \"hermes.base.nodes.pipeline.Pipeline\"\n              click hermes.base.nodes.pipeline_interface.PipelineInterface href \"\" \"hermes.base.nodes.pipeline_interface.PipelineInterface\"\n              click hermes.base.nodes.node.Node href \"\" \"hermes.base.nodes.node.Node\"\n              click hermes.base.nodes.node_interface.NodeInterface href \"\" \"hermes.base.nodes.node_interface.NodeInterface\"\n            </code></pre> <p>An abstract class to interface with a data-producing worker.</p> <p>Methods:</p> Name Description <code>__call__</code> <p>Node objects are callable to start the FSM as entry-point.</p> <code>__init__</code> <p>Constructor of the Pipeline parent class.</p> <code>create_stream</code> <p>Instantiate Stream datastructure object specific to this Pipeline.</p>"},{"location":"api/nodes/pipeline/#hermes.base.nodes.pipeline.Pipeline.__call__","title":"__call__","text":"<pre><code>__call__()\n</code></pre> <p>Node objects are callable to start the FSM as entry-point.</p>"},{"location":"api/nodes/pipeline/#hermes.base.nodes.pipeline.Pipeline.__init__","title":"__init__","text":"<pre><code>__init__(\n    host_ip: str,\n    stream_out_spec: dict,\n    stream_in_specs: list[dict],\n    logging_spec: LoggingSpec,\n    port_pub: str = PORT_BACKEND,\n    port_sub: str = PORT_FRONTEND,\n    port_sync: str = PORT_SYNC_HOST,\n    port_killsig: str = PORT_KILL,\n) -&gt; None\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>IP address of the local master Broker.</p> required <code>dict</code> <p>Mapping of corresponding Stream object parameters to user-defined configuration values.</p> required <code>list[dict]</code> <p>List of mappings of user-configured incoming modalities.</p> required <code>LoggingSpec</code> <p>Specification of what and how to store.</p> required <code>str</code> <p>Local port to publish to for local master Broker to relay. Defaults to <code>PORT_BACKEND</code>.</p> <code>PORT_BACKEND</code> <code>str</code> <p>Local port to subscribe to for incoming relayed data from the local master Broker. Defaults to <code>PORT_FRONTEND</code>.</p> <code>PORT_FRONTEND</code> <code>str</code> <p>Local port to listen to for local master Broker's startup coordination. Defaults to <code>PORT_SYNC_HOST</code>.</p> <code>PORT_SYNC_HOST</code> <code>str</code> <p>Local port to listen to for local master Broker's termination signal. Defaults to <code>PORT_KILL</code>.</p> <code>PORT_KILL</code>"},{"location":"api/nodes/pipeline/#hermes.base.nodes.pipeline.Pipeline.__init__(host_ip)","title":"<code>host_ip</code>","text":""},{"location":"api/nodes/pipeline/#hermes.base.nodes.pipeline.Pipeline.__init__(stream_out_spec)","title":"<code>stream_out_spec</code>","text":""},{"location":"api/nodes/pipeline/#hermes.base.nodes.pipeline.Pipeline.__init__(stream_in_specs)","title":"<code>stream_in_specs</code>","text":""},{"location":"api/nodes/pipeline/#hermes.base.nodes.pipeline.Pipeline.__init__(logging_spec)","title":"<code>logging_spec</code>","text":""},{"location":"api/nodes/pipeline/#hermes.base.nodes.pipeline.Pipeline.__init__(port_pub)","title":"<code>port_pub</code>","text":""},{"location":"api/nodes/pipeline/#hermes.base.nodes.pipeline.Pipeline.__init__(port_sub)","title":"<code>port_sub</code>","text":""},{"location":"api/nodes/pipeline/#hermes.base.nodes.pipeline.Pipeline.__init__(port_sync)","title":"<code>port_sync</code>","text":""},{"location":"api/nodes/pipeline/#hermes.base.nodes.pipeline.Pipeline.__init__(port_killsig)","title":"<code>port_killsig</code>","text":""},{"location":"api/nodes/pipeline/#hermes.base.nodes.pipeline.Pipeline._log_source_tag","title":"_log_source_tag  <code>abstractmethod</code> <code>classmethod</code>","text":"<pre><code>_log_source_tag() -&gt; str\n</code></pre> <p>Read-only property uniquely identifying the Node.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Unique key identifying the Node in the data exchange.</p>"},{"location":"api/nodes/pipeline/#hermes.base.nodes.pipeline.Pipeline._poll_data_packets","title":"_poll_data_packets","text":"<pre><code>_poll_data_packets() -&gt; None\n</code></pre> <p>Receive data packets in a steady state.</p> <p>Gets called every time one of the requestes modalities produced new data. In normal operation mode, all messages are 2-part.</p>"},{"location":"api/nodes/pipeline/#hermes.base.nodes.pipeline.Pipeline._poll_ending_data_packets","title":"_poll_ending_data_packets","text":"<pre><code>_poll_ending_data_packets() -&gt; None\n</code></pre> <p>Receive data packets from producers and monitor for end-of-stream signal.</p> <p>When system triggered a safe exit, Pipeline gets a mix of normal 2-part messages and 3-part 'END' message from each Producer that safely exited. It's more efficient to dynamically switch the callback instead of checking every message.</p> <p>Processes packets on each modality until all data sources sent the 'END' packet. If triggered to stop and no more available data, sends empty 'END' packet and joins.</p>"},{"location":"api/nodes/pipeline/#hermes.base.nodes.pipeline.Pipeline._process_data","title":"_process_data  <code>abstractmethod</code>","text":"<pre><code>_process_data(topic: str, msg: dict) -&gt; None\n</code></pre> <p>Main iteration loop logic for the Node during its running phase.</p> <p>Contained logic has to deal with async multiple modalities. Must end with calling <code>_send_end_packet</code>.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>Uniquely identified modality of the contained data.</p> required <code>dict</code> <p>Received data of the corresponding modality.</p> required"},{"location":"api/nodes/pipeline/#hermes.base.nodes.pipeline.Pipeline._process_data(topic)","title":"<code>topic</code>","text":""},{"location":"api/nodes/pipeline/#hermes.base.nodes.pipeline.Pipeline._process_data(msg)","title":"<code>msg</code>","text":""},{"location":"api/nodes/pipeline/#hermes.base.nodes.pipeline.Pipeline._publish","title":"_publish","text":"<pre><code>_publish(tag: str, process_time_s: float, **kwargs) -&gt; None\n</code></pre> <p>Pass generated data to the ZeroMQ message exchange layer.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>Uniquely identifying key for the data generated by the Node.</p> required"},{"location":"api/nodes/pipeline/#hermes.base.nodes.pipeline.Pipeline._publish(tag)","title":"<code>tag</code>","text":""},{"location":"api/nodes/pipeline/#hermes.base.nodes.pipeline.Pipeline._send_end_packet","title":"_send_end_packet","text":"<pre><code>_send_end_packet() -&gt; None\n</code></pre> <p>Send 'END' empty packet and label Node as done to safely finish and exit the process and its threads.</p>"},{"location":"api/nodes/pipeline/#hermes.base.nodes.pipeline.Pipeline._stop_new_data","title":"_stop_new_data  <code>abstractmethod</code>","text":"<pre><code>_stop_new_data() -&gt; None\n</code></pre> <p>Stop sampling data, continue sending already captured until none is left.</p>"},{"location":"api/nodes/pipeline/#hermes.base.nodes.pipeline.Pipeline._store_and_broadcast","title":"_store_and_broadcast","text":"<pre><code>_store_and_broadcast(tag: str, process_time_s: float, **kwargs) -&gt; None\n</code></pre> <p>Place captured data into the corresponding Stream datastructure and transmit serialized ZeroMQ packets to subscribers.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>Uniquely identifying key for the modality to label data for message exchange.</p> required"},{"location":"api/nodes/pipeline/#hermes.base.nodes.pipeline.Pipeline._store_and_broadcast(tag)","title":"<code>tag</code>","text":""},{"location":"api/nodes/pipeline/#hermes.base.nodes.pipeline.Pipeline.create_stream","title":"create_stream  <code>abstractmethod</code> <code>classmethod</code>","text":"<pre><code>create_stream(stream_spec: dict) -&gt; Stream\n</code></pre> <p>Instantiate Stream datastructure object specific to this Pipeline.</p> <p>Should also be a class method to create Stream objects on consumers.</p> <p>Parameters:</p> Name Type Description Default <code>dict</code> <p>Mapping of corresponding Stream object parameters to user-defined configuration values.</p> required <p>Returns:</p> Name Type Description <code>Stream</code> <code>Stream</code> <p>Datastructure object of the corresponding Node, configured according to the user-provided specification.</p>"},{"location":"api/nodes/pipeline/#hermes.base.nodes.pipeline.Pipeline.create_stream(stream_spec)","title":"<code>stream_spec</code>","text":""},{"location":"api/nodes/producer/","title":"hermes.base.nodes","text":"<p>The module is responsible for wrapping common functionality of Producer Nodes. It defines a unified interface to the ZeroMQ message exchange layer for all concrete Producers.</p> <p><code>producer_interface</code> - base interface for Producer function.</p> <p><code>producer</code> - abstract Producer with common data generation logic to subclass.</p>"},{"location":"api/nodes/producer/#hermes.base.nodes.producer_interface","title":"producer_interface","text":"<p>Classes:</p> Name Description <code>ProducerInterface</code> <p>Interface for the Producer Node component.</p>"},{"location":"api/nodes/producer/#hermes.base.nodes.producer_interface.ProducerInterface","title":"ProducerInterface","text":"<p>               Bases: <code>NodeInterface</code></p> <pre><code>\n              flowchart TD\n              hermes.base.nodes.producer_interface.ProducerInterface[ProducerInterface]\n              hermes.base.nodes.node_interface.NodeInterface[NodeInterface]\n\n                              hermes.base.nodes.node_interface.NodeInterface --&gt; hermes.base.nodes.producer_interface.ProducerInterface\n                \n\n\n              click hermes.base.nodes.producer_interface.ProducerInterface href \"\" \"hermes.base.nodes.producer_interface.ProducerInterface\"\n              click hermes.base.nodes.node_interface.NodeInterface href \"\" \"hermes.base.nodes.node_interface.NodeInterface\"\n            </code></pre> <p>Interface for the Producer Node component.</p> <p>Methods:</p> Name Description <code>create_stream</code> <p>Instantiate Stream datastructure object specific to this Pipeline.</p>"},{"location":"api/nodes/producer/#hermes.base.nodes.producer_interface.ProducerInterface._is_done","title":"_is_done  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>_is_done: bool\n</code></pre> <p>Read-only property identifying if the Node completed operation.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Whether the Node completed its function.</p>"},{"location":"api/nodes/producer/#hermes.base.nodes.producer_interface.ProducerInterface._activate_data_poller","title":"_activate_data_poller  <code>abstractmethod</code>","text":"<pre><code>_activate_data_poller() -&gt; None\n</code></pre> <p>Start listening for new data from other Nodes.</p>"},{"location":"api/nodes/producer/#hermes.base.nodes.producer_interface.ProducerInterface._activate_kill_poller","title":"_activate_kill_poller  <code>abstractmethod</code>","text":"<pre><code>_activate_kill_poller() -&gt; None\n</code></pre> <p>Start listening for the KILL signal on the special PUB/SUB socket that coordinates program termination.</p>"},{"location":"api/nodes/producer/#hermes.base.nodes.producer_interface.ProducerInterface._connect","title":"_connect  <code>abstractmethod</code>","text":"<pre><code>_connect() -&gt; bool\n</code></pre> <p>Connect to device via its corresponding backend.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Whether connection to the device succeeded.</p>"},{"location":"api/nodes/producer/#hermes.base.nodes.producer_interface.ProducerInterface._deactivate_kill_poller","title":"_deactivate_kill_poller  <code>abstractmethod</code>","text":"<pre><code>_deactivate_kill_poller() -&gt; None\n</code></pre> <p>Stop listening for the KILL signal.</p>"},{"location":"api/nodes/producer/#hermes.base.nodes.producer_interface.ProducerInterface._get_sync_socket","title":"_get_sync_socket  <code>abstractmethod</code>","text":"<pre><code>_get_sync_socket() -&gt; SyncSocket\n</code></pre> <p>Get reference to the socket used for synchronization of the Node to its master Broker.</p> <p>Returns:</p> Type Description <code>SyncSocket</code> <p>zmq.SyncSocket: ZeroMQ socket of the Node connected to the local master Broker.</p>"},{"location":"api/nodes/producer/#hermes.base.nodes.producer_interface.ProducerInterface._initialize","title":"_initialize  <code>abstractmethod</code>","text":"<pre><code>_initialize() -&gt; None\n</code></pre> <p>Node-specific initialization procedure.</p> <p>Pre-run setup of the backend specific to the Node implementaiton. Generic setup should be run first.</p>"},{"location":"api/nodes/producer/#hermes.base.nodes.producer_interface.ProducerInterface._keep_samples","title":"_keep_samples  <code>abstractmethod</code>","text":"<pre><code>_keep_samples() -&gt; None\n</code></pre> <p>Node-specific externally triggered function to start keeping in memory streamed data.</p>"},{"location":"api/nodes/producer/#hermes.base.nodes.producer_interface.ProducerInterface._log_source_tag","title":"_log_source_tag  <code>abstractmethod</code> <code>classmethod</code>","text":"<pre><code>_log_source_tag() -&gt; str\n</code></pre> <p>Read-only property uniquely identifying the Node.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Unique key identifying the Node in the data exchange.</p>"},{"location":"api/nodes/producer/#hermes.base.nodes.producer_interface.ProducerInterface._on_poll","title":"_on_poll  <code>abstractmethod</code>","text":"<pre><code>_on_poll(poll_res: tuple[list[SyncSocket], list[int]]) -&gt; None\n</code></pre> <p>Callback to perform some logic everytime some data transactions are received by the Poller.</p> <p>Generic entry-point for all types of Nodes, based on their active Poller settings. NOTE: if Node in JoinState, kill socket is no longer in the Poller and only higher-level logic is triggered.</p> <p>Parameters:</p> Name Type Description Default <code>tuple[list[SyncSocket], list[int]]</code> <p>Reference to the complete captured result of listening by the Poller.</p> required"},{"location":"api/nodes/producer/#hermes.base.nodes.producer_interface.ProducerInterface._on_poll(poll_res)","title":"<code>poll_res</code>","text":""},{"location":"api/nodes/producer/#hermes.base.nodes.producer_interface.ProducerInterface._on_sync_complete","title":"_on_sync_complete  <code>abstractmethod</code>","text":"<pre><code>_on_sync_complete() -&gt; None\n</code></pre> <p>Callback to perform some logic after synchronization of Nodes is completed and indicated by the Broker.</p>"},{"location":"api/nodes/producer/#hermes.base.nodes.producer_interface.ProducerInterface._ping_device","title":"_ping_device  <code>abstractmethod</code>","text":"<pre><code>_ping_device() -&gt; None\n</code></pre> <p>Device-specific procedure for round-trip time estimation.</p> <p>Concrete implementation of Producer must override the method if required to measure transmission delay   for realtime/post-processing alignment of modalities that don't support system clock sync.</p>"},{"location":"api/nodes/producer/#hermes.base.nodes.producer_interface.ProducerInterface._poll","title":"_poll  <code>abstractmethod</code>","text":"<pre><code>_poll() -&gt; tuple[list[SyncSocket], list[int]]\n</code></pre> <p>Block for new ZeroMQ data to collect at the Poller.</p> <p>Listens for events when new data is received from or when new data can be written to sockets, based on the active Poller settings of the Node implementation.</p> <p>Returns:</p> Type Description <code>tuple[list[SyncSocket], list[int]]</code> <p>tuple[list[zmq.SyncSocket], list[int]]: Result of listening on the sockets registered by the Poller.</p>"},{"location":"api/nodes/producer/#hermes.base.nodes.producer_interface.ProducerInterface._process_data","title":"_process_data  <code>abstractmethod</code>","text":"<pre><code>_process_data() -&gt; None\n</code></pre> <p>Main iteration loop logic for the Node during its running phase.</p> <p>Acquire data from your sensor as desired, and for each timestep. SDK thread pushes data into shared memory space, this thread pulls data and does all the processing, ensuring that lost packets are responsibility of the slow consumer.</p>"},{"location":"api/nodes/producer/#hermes.base.nodes.producer_interface.ProducerInterface._send_kill_to_broker","title":"_send_kill_to_broker  <code>abstractmethod</code>","text":"<pre><code>_send_kill_to_broker() -&gt; None\n</code></pre> <p>Send a slave KILL signal to the local Broker in case program termination by the slave Node is recorded.</p>"},{"location":"api/nodes/producer/#hermes.base.nodes.producer_interface.ProducerInterface._set_state","title":"_set_state  <code>abstractmethod</code>","text":"<pre><code>_set_state(state) -&gt; None\n</code></pre> <p>User-defined logic for FSM state transition.</p> <p>Parameters:</p> Name Type Description Default <code>Any</code> <p>New state to transition to.</p> required"},{"location":"api/nodes/producer/#hermes.base.nodes.producer_interface.ProducerInterface._set_state(state)","title":"<code>state</code>","text":""},{"location":"api/nodes/producer/#hermes.base.nodes.producer_interface.ProducerInterface._stop_new_data","title":"_stop_new_data  <code>abstractmethod</code>","text":"<pre><code>_stop_new_data() -&gt; None\n</code></pre> <p>Stop sampling data, continue sending already captured until none is left.</p>"},{"location":"api/nodes/producer/#hermes.base.nodes.producer_interface.ProducerInterface._trigger_stop","title":"_trigger_stop  <code>abstractmethod</code>","text":"<pre><code>_trigger_stop() -&gt; None\n</code></pre> <p>Trigger to the Node's internal procedures and background threads to gracefully wrap-up.</p> <p>Producer: stops sampling data, continue sending already captured until none is left, with last message labeled 'END'. Consumer: continues listening to data until each of subscribed Producers sent the last message. Pipeline: continues listening to data to produce results until each data sources sent the last message, and then labels the last message with 'END'.</p>"},{"location":"api/nodes/producer/#hermes.base.nodes.producer_interface.ProducerInterface.create_stream","title":"create_stream  <code>abstractmethod</code> <code>classmethod</code>","text":"<pre><code>create_stream(stream_spec: dict) -&gt; Stream\n</code></pre> <p>Instantiate Stream datastructure object specific to this Pipeline.</p> <p>Should also be a class method to create Stream objects on consumers.</p> <p>Parameters:</p> Name Type Description Default <code>dict</code> <p>Mapping of corresponding Stream object parameters to user-defined configuration values.</p> required <p>Returns:</p> Name Type Description <code>Stream</code> <code>Stream</code> <p>Datastructure object of the corresponding Node, configured according to the user-provided specification.</p>"},{"location":"api/nodes/producer/#hermes.base.nodes.producer_interface.ProducerInterface.create_stream(stream_spec)","title":"<code>stream_spec</code>","text":""},{"location":"api/nodes/producer/#hermes.base.nodes.producer","title":"producer","text":"<p>Classes:</p> Name Description <code>Producer</code> <p>An abstract class wrapping an interface with a particular device into a Producer Node.</p>"},{"location":"api/nodes/producer/#hermes.base.nodes.producer.Producer","title":"Producer","text":"<p>               Bases: <code>ProducerInterface</code>, <code>Node</code></p> <pre><code>\n              flowchart TD\n              hermes.base.nodes.producer.Producer[Producer]\n              hermes.base.nodes.producer_interface.ProducerInterface[ProducerInterface]\n              hermes.base.nodes.node.Node[Node]\n              hermes.base.nodes.node_interface.NodeInterface[NodeInterface]\n\n                              hermes.base.nodes.producer_interface.ProducerInterface --&gt; hermes.base.nodes.producer.Producer\n                                hermes.base.nodes.node_interface.NodeInterface --&gt; hermes.base.nodes.producer_interface.ProducerInterface\n                \n\n                hermes.base.nodes.node.Node --&gt; hermes.base.nodes.producer.Producer\n                                hermes.base.nodes.node_interface.NodeInterface --&gt; hermes.base.nodes.node.Node\n                \n\n\n\n              click hermes.base.nodes.producer.Producer href \"\" \"hermes.base.nodes.producer.Producer\"\n              click hermes.base.nodes.producer_interface.ProducerInterface href \"\" \"hermes.base.nodes.producer_interface.ProducerInterface\"\n              click hermes.base.nodes.node.Node href \"\" \"hermes.base.nodes.node.Node\"\n              click hermes.base.nodes.node_interface.NodeInterface href \"\" \"hermes.base.nodes.node_interface.NodeInterface\"\n            </code></pre> <p>An abstract class wrapping an interface with a particular device into a Producer Node.</p> <p>Methods:</p> Name Description <code>__call__</code> <p>Node objects are callable to start the FSM as entry-point.</p> <code>__init__</code> <p>Constructor of the Producer parent class.</p> <code>create_stream</code> <p>Instantiate Stream datastructure object specific to this Pipeline.</p>"},{"location":"api/nodes/producer/#hermes.base.nodes.producer.Producer.__call__","title":"__call__","text":"<pre><code>__call__()\n</code></pre> <p>Node objects are callable to start the FSM as entry-point.</p>"},{"location":"api/nodes/producer/#hermes.base.nodes.producer.Producer.__init__","title":"__init__","text":"<pre><code>__init__(\n    host_ip: str,\n    stream_out_spec: dict,\n    logging_spec: LoggingSpec,\n    sampling_rate_hz: float = float(\"nan\"),\n    port_pub: str = PORT_BACKEND,\n    port_sync: str = PORT_SYNC_HOST,\n    port_killsig: str = PORT_KILL,\n    transmit_delay_sample_period_s: float = float(\"nan\"),\n) -&gt; None\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>IP address of the local master Broker.</p> required <code>dict</code> <p>Mapping of corresponding Stream object parameters to user-defined configuration values.</p> required <code>LoggingSpec</code> <p>Specification of what and how to store.</p> required <code>float</code> <p>Expected sample rate of the device. Defaults to <code>float('nan')</code>.</p> <code>float('nan')</code> <code>str</code> <p>Local port to publish to for local master Broker to relay. Defaults to <code>PORT_BACKEND</code>.</p> <code>PORT_BACKEND</code> <code>str</code> <p>Local port to listen to for local master Broker's startup coordination. Defaults to <code>PORT_SYNC_HOST</code>.</p> <code>PORT_SYNC_HOST</code> <code>str</code> <p>Local port to listen to for local master Broker's termination signal. Defaults to <code>PORT_KILL</code>.</p> <code>PORT_KILL</code> <code>float</code> <p>Duration of the period over which to estimate propagation delay of measurements from the corresponding device. Defaults to <code>float('nan')</code>.</p> <code>float('nan')</code>"},{"location":"api/nodes/producer/#hermes.base.nodes.producer.Producer.__init__(host_ip)","title":"<code>host_ip</code>","text":""},{"location":"api/nodes/producer/#hermes.base.nodes.producer.Producer.__init__(stream_out_spec)","title":"<code>stream_out_spec</code>","text":""},{"location":"api/nodes/producer/#hermes.base.nodes.producer.Producer.__init__(logging_spec)","title":"<code>logging_spec</code>","text":""},{"location":"api/nodes/producer/#hermes.base.nodes.producer.Producer.__init__(sampling_rate_hz)","title":"<code>sampling_rate_hz</code>","text":""},{"location":"api/nodes/producer/#hermes.base.nodes.producer.Producer.__init__(port_pub)","title":"<code>port_pub</code>","text":""},{"location":"api/nodes/producer/#hermes.base.nodes.producer.Producer.__init__(port_sync)","title":"<code>port_sync</code>","text":""},{"location":"api/nodes/producer/#hermes.base.nodes.producer.Producer.__init__(port_killsig)","title":"<code>port_killsig</code>","text":""},{"location":"api/nodes/producer/#hermes.base.nodes.producer.Producer.__init__(transmit_delay_sample_period_s)","title":"<code>transmit_delay_sample_period_s</code>","text":""},{"location":"api/nodes/producer/#hermes.base.nodes.producer.Producer._connect","title":"_connect  <code>abstractmethod</code>","text":"<pre><code>_connect() -&gt; bool\n</code></pre> <p>Connect to device via its corresponding backend.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Whether connection to the device succeeded.</p>"},{"location":"api/nodes/producer/#hermes.base.nodes.producer.Producer._keep_samples","title":"_keep_samples  <code>abstractmethod</code>","text":"<pre><code>_keep_samples() -&gt; None\n</code></pre> <p>Node-specific externally triggered function to start keeping in memory streamed data.</p>"},{"location":"api/nodes/producer/#hermes.base.nodes.producer.Producer._log_source_tag","title":"_log_source_tag  <code>abstractmethod</code> <code>classmethod</code>","text":"<pre><code>_log_source_tag() -&gt; str\n</code></pre> <p>Read-only property uniquely identifying the Node.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Unique key identifying the Node in the data exchange.</p>"},{"location":"api/nodes/producer/#hermes.base.nodes.producer.Producer._ping_device","title":"_ping_device  <code>abstractmethod</code>","text":"<pre><code>_ping_device() -&gt; None\n</code></pre> <p>Device-specific procedure for round-trip time estimation.</p> <p>Concrete implementation of Producer must override the method if required to measure transmission delay   for realtime/post-processing alignment of modalities that don't support system clock sync.</p>"},{"location":"api/nodes/producer/#hermes.base.nodes.producer.Producer._process_data","title":"_process_data  <code>abstractmethod</code>","text":"<pre><code>_process_data() -&gt; None\n</code></pre> <p>Main iteration loop logic for the Node during its running phase.</p> <p>Acquire data from your sensor as desired, and for each timestep. SDK thread pushes data into shared memory space, this thread pulls data and does all the processing, ensuring that lost packets are responsibility of the slow consumer.</p>"},{"location":"api/nodes/producer/#hermes.base.nodes.producer.Producer._publish","title":"_publish","text":"<pre><code>_publish(tag: str, **kwargs) -&gt; None\n</code></pre> <p>Common method to save and publish the captured sample.</p> <p>Best to deal with data structure (threading primitives) AFTER handing off packet to ZeroMQ. That way network thread can already start processing the packet.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>Uniquely identifying key for the modality to label data for message exchange.</p> required"},{"location":"api/nodes/producer/#hermes.base.nodes.producer.Producer._publish(tag)","title":"<code>tag</code>","text":""},{"location":"api/nodes/producer/#hermes.base.nodes.producer.Producer._send_end_packet","title":"_send_end_packet","text":"<pre><code>_send_end_packet() -&gt; None\n</code></pre> <p>Send 'END' empty packet and label Node as done to safely finish and exit the process and its threads.</p>"},{"location":"api/nodes/producer/#hermes.base.nodes.producer.Producer._stop_new_data","title":"_stop_new_data  <code>abstractmethod</code>","text":"<pre><code>_stop_new_data() -&gt; None\n</code></pre> <p>Stop sampling data, continue sending already captured until none is left.</p>"},{"location":"api/nodes/producer/#hermes.base.nodes.producer.Producer._store_and_broadcast","title":"_store_and_broadcast","text":"<pre><code>_store_and_broadcast(tag: str, process_time_s: float, **kwargs) -&gt; None\n</code></pre> <p>Place captured data into the corresponding Stream datastructure and transmit serialized ZeroMQ packets to subscribers.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>Uniquely identifying key for the modality to label data for message exchange.</p> required"},{"location":"api/nodes/producer/#hermes.base.nodes.producer.Producer._store_and_broadcast(tag)","title":"<code>tag</code>","text":""},{"location":"api/nodes/producer/#hermes.base.nodes.producer.Producer.create_stream","title":"create_stream  <code>abstractmethod</code> <code>classmethod</code>","text":"<pre><code>create_stream(stream_spec: dict) -&gt; Stream\n</code></pre> <p>Instantiate Stream datastructure object specific to this Pipeline.</p> <p>Should also be a class method to create Stream objects on consumers.</p> <p>Parameters:</p> Name Type Description Default <code>dict</code> <p>Mapping of corresponding Stream object parameters to user-defined configuration values.</p> required <p>Returns:</p> Name Type Description <code>Stream</code> <code>Stream</code> <p>Datastructure object of the corresponding Node, configured according to the user-provided specification.</p>"},{"location":"api/nodes/producer/#hermes.base.nodes.producer.Producer.create_stream(stream_spec)","title":"<code>stream_spec</code>","text":""},{"location":"api/utils/","title":"Utilities","text":"<p>Some useful utilities abstracting or enriching functionality of the main source.</p>"},{"location":"api/utils/#hermes.utils.types","title":"types","text":"<p>Classes:</p> Name Description <code>AudioCodec</code> <p>Object specifying audio codec options for FFmpeg.</p> <code>AudioFormatEnum</code> <p>Audio format enumeration for supported FFmpeg video formats.</p> <code>LoggingSpec</code> <p>Object specifying data storage options.</p> <code>VideoCodec</code> <p>Object specifying video codec options for FFmpeg.</p> <code>VideoFormatEnum</code> <p>Video format enumeration for supported FFmpeg video formats.</p>"},{"location":"api/utils/#hermes.utils.types.AudioCodec","title":"AudioCodec  <code>dataclass</code>","text":"<p>Object specifying audio codec options for FFmpeg.</p>"},{"location":"api/utils/#hermes.utils.types.AudioFormatEnum","title":"AudioFormatEnum","text":"<p>               Bases: <code>Enum</code></p> <pre><code>\n              flowchart TD\n              hermes.utils.types.AudioFormatEnum[AudioFormatEnum]\n\n              \n\n              click hermes.utils.types.AudioFormatEnum href \"\" \"hermes.utils.types.AudioFormatEnum\"\n            </code></pre> <p>Audio format enumeration for supported FFmpeg video formats.</p> <p>TODO: Must be a tuple of (, ...), where:     write format is one of: <code>ffmpeg -formats</code>"},{"location":"api/utils/#hermes.utils.types.LoggingSpec","title":"LoggingSpec  <code>dataclass</code>","text":"<p>Object specifying data storage options.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>Path to the directory on disk to flush data to.</p> required <code>dict[str, str]</code> <p>Nested setup definition of Nodes across distributed hosts.</p> required <code>float</code> <p>Start time of saving data.</p> required <code>float</code> <p>Reference time of the Broker to align all Nodes to.</p> required <code>float</code> <p>Duration of periods over which to flush streamed accumulated data from memory to disk. Defaults to <code>30.0</code>.</p> <code>30.0</code> <code>bool</code> <p>Whether to print FFmpeg stats to the terminal. Defaults to <code>False</code>.</p> <code>False</code> <code>bool</code> <p>Whether to stream data into HDF5 files. Defaults to <code>False</code>.</p> <code>False</code> <code>bool</code> <p>Whether to stream video data into MP4/MKV files. Defaults to <code>False</code>.</p> <code>False</code> <code>bool</code> <p>Whether to stream data into CSV files. Defaults to <code>False</code>.</p> <code>False</code> <code>bool</code> <p>Whether to stream audio data into MP3/WAV files. Defaults to <code>False</code>.</p> <code>False</code> <code>bool</code> <p>Weather to dump in-memory recorded data in CSV files. Defaults to <code>False</code>.</p> <code>False</code> <code>bool</code> <p>Weather to dump in-memory recorded data in HDF5 files. Defaults to <code>False</code>.</p> <code>False</code> <code>bool</code> <p>Weather to dump in-memory recorded video data in MP4/MKV files. Defaults to <code>False</code>.</p> <code>False</code> <code>bool</code> <p>Weather to dump in-memory recorded audio data in MP3/WAV files. Defaults to <code>False</code>.</p> <code>False</code> <code>VideoCodec</code> <p>Definition of the video codec to use for FFmpeg. Defaults to <code>None</code>.</p> <code>None</code> <code>AudioCodec</code> <p>Definition of the audio codec to use for FFmpeg. Defaults to <code>None</code>.</p> <code>None</code>"},{"location":"api/utils/#hermes.utils.types.LoggingSpec(log_dir)","title":"<code>log_dir</code>","text":""},{"location":"api/utils/#hermes.utils.types.LoggingSpec(experiment)","title":"<code>experiment</code>","text":""},{"location":"api/utils/#hermes.utils.types.LoggingSpec(log_time_s)","title":"<code>log_time_s</code>","text":""},{"location":"api/utils/#hermes.utils.types.LoggingSpec(ref_time_s)","title":"<code>ref_time_s</code>","text":""},{"location":"api/utils/#hermes.utils.types.LoggingSpec(stream_period_s)","title":"<code>stream_period_s</code>","text":""},{"location":"api/utils/#hermes.utils.types.LoggingSpec(is_quiet)","title":"<code>is_quiet</code>","text":""},{"location":"api/utils/#hermes.utils.types.LoggingSpec(stream_hdf5)","title":"<code>stream_hdf5</code>","text":""},{"location":"api/utils/#hermes.utils.types.LoggingSpec(stream_video)","title":"<code>stream_video</code>","text":""},{"location":"api/utils/#hermes.utils.types.LoggingSpec(stream_csv)","title":"<code>stream_csv</code>","text":""},{"location":"api/utils/#hermes.utils.types.LoggingSpec(stream_audio)","title":"<code>stream_audio</code>","text":""},{"location":"api/utils/#hermes.utils.types.LoggingSpec(dump_csv)","title":"<code>dump_csv</code>","text":""},{"location":"api/utils/#hermes.utils.types.LoggingSpec(dump_hdf5)","title":"<code>dump_hdf5</code>","text":""},{"location":"api/utils/#hermes.utils.types.LoggingSpec(dump_video)","title":"<code>dump_video</code>","text":""},{"location":"api/utils/#hermes.utils.types.LoggingSpec(dump_audio)","title":"<code>dump_audio</code>","text":""},{"location":"api/utils/#hermes.utils.types.LoggingSpec(video_codec)","title":"<code>video_codec</code>","text":""},{"location":"api/utils/#hermes.utils.types.LoggingSpec(audio_codec)","title":"<code>audio_codec</code>","text":""},{"location":"api/utils/#hermes.utils.types.VideoCodec","title":"VideoCodec  <code>dataclass</code>","text":"<p>Object specifying video codec options for FFmpeg.</p>"},{"location":"api/utils/#hermes.utils.types.VideoFormatEnum","title":"VideoFormatEnum","text":"<p>               Bases: <code>Enum</code></p> <pre><code>\n              flowchart TD\n              hermes.utils.types.VideoFormatEnum[VideoFormatEnum]\n\n              \n\n              click hermes.utils.types.VideoFormatEnum href \"\" \"hermes.utils.types.VideoFormatEnum\"\n            </code></pre> <p>Video format enumeration for supported FFmpeg video formats.</p> <p>Must be a tuple of (, ), where:     write format is one of: <code>ffmpeg -formats</code>     pixel color is one of: <code>ffmpeg -pix_fmts</code>"},{"location":"api/utils/#hermes.utils.time_utils","title":"time_utils","text":"<p>Classes:</p> Name Description <code>SystemTime</code> <p>Highly accurate system time Singleton that uses performance counters of the host device.</p> <p>Functions:</p> Name Description <code>get_ref_time</code> <p>Gets the current process's <code>SystemTime</code> Singleton reference time.</p> <code>get_time</code> <p>Gets the highly accurate current system time.</p> <code>get_time_s_from_local_str</code> <p>Gets seconds since epoch from provided local time string.</p> <code>get_time_s_from_utc_time_no_date_str</code> <p>Gets local time in seconds since epoch from provided UTC time strings.</p> <code>get_time_str</code> <p>Gets a date string from seconds since epoch.</p> <code>init_time</code> <p>Initialize the current process's <code>SystemTime</code> Singleton with a common reference time.</p>"},{"location":"api/utils/#hermes.utils.time_utils.SystemTime","title":"SystemTime","text":"<p>Highly accurate system time Singleton that uses performance counters of the host device.</p> <p>Performance counters of the host devices are not Unix float numbers since epoch, but a float starting from 0 on the boot-up of the device. This Singleton uses less accurate system time with the <code>time.time()</code> call and combines with the performance counters, to get highly accurate time of the host device.</p> <p>This Singleton's methods should not be called directly. Use the global methods instead.</p> <p>Each subprocess of the application must be initialized via <code>init_time(...)</code> with a reference time obtained in the parent process via <code>get_ref_time()</code>.</p>"},{"location":"api/utils/#hermes.utils.time_utils.get_ref_time","title":"get_ref_time","text":"<pre><code>get_ref_time() -&gt; float\n</code></pre> <p>Gets the current process's <code>SystemTime</code> Singleton reference time.</p>"},{"location":"api/utils/#hermes.utils.time_utils.get_time","title":"get_time","text":"<pre><code>get_time() -&gt; float\n</code></pre> <p>Gets the highly accurate current system time.</p>"},{"location":"api/utils/#hermes.utils.time_utils.get_time_s_from_local_str","title":"get_time_s_from_local_str","text":"<pre><code>get_time_s_from_local_str(\n    time_local_str: str,\n    input_time_format: str = \"%H:%M:%S.%f\",\n    date_local_str: str | None = None,\n    input_date_format: str = \"%Y-%m-%d\",\n) -&gt; float\n</code></pre> <p>Gets seconds since epoch from provided local time string.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>local time string to convert to seconds.</p> required <code>str</code> <p>Time string format of the provided time. Defaults to <code>%H:%M:%S.%f</code>.</p> <code>'%H:%M:%S.%f'</code> <code>str</code> <p>local date string to convert to seconds. Defaults to <code>None</code>.</p> <code>None</code> <code>str</code> <p>Date string format of the provided date. Defaults to <code>%Y-%m-%d</code>.</p> <code>'%Y-%m-%d'</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Seconds count since epoch, corresponding to the provided local time strings.</p>"},{"location":"api/utils/#hermes.utils.time_utils.get_time_s_from_local_str(time_local_str)","title":"<code>time_local_str</code>","text":""},{"location":"api/utils/#hermes.utils.time_utils.get_time_s_from_local_str(input_time_format)","title":"<code>input_time_format</code>","text":""},{"location":"api/utils/#hermes.utils.time_utils.get_time_s_from_local_str(date_local_str)","title":"<code>date_local_str</code>","text":""},{"location":"api/utils/#hermes.utils.time_utils.get_time_s_from_local_str(input_date_format)","title":"<code>input_date_format</code>","text":""},{"location":"api/utils/#hermes.utils.time_utils.get_time_s_from_utc_time_no_date_str","title":"get_time_s_from_utc_time_no_date_str","text":"<pre><code>get_time_s_from_utc_time_no_date_str(\n    time_utc_str: str,\n    input_time_format: str = \"%H:%M:%S.%f\",\n    date_utc_str: str | None = None,\n    input_date_format: str = \"%Y-%m-%d\",\n) -&gt; float\n</code></pre> <p>Gets local time in seconds since epoch from provided UTC time strings.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>UTC time string to convert to seconds.</p> required <code>str</code> <p>Time string format of the provided time. Defaults to <code>%H:%M:%S.%f</code>.</p> <code>'%H:%M:%S.%f'</code> <code>str</code> <p>UTC date to convert to seconds. Defaults to <code>None</code>.</p> <code>None</code> <code>str</code> <p>Date string format of the provided date. Defaults to <code>%Y-%m-%d</code>.</p> <code>'%Y-%m-%d'</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Seconds count since epoch, corresponding to the provided UTC time strings.</p>"},{"location":"api/utils/#hermes.utils.time_utils.get_time_s_from_utc_time_no_date_str(time_utc_str)","title":"<code>time_utc_str</code>","text":""},{"location":"api/utils/#hermes.utils.time_utils.get_time_s_from_utc_time_no_date_str(input_time_format)","title":"<code>input_time_format</code>","text":""},{"location":"api/utils/#hermes.utils.time_utils.get_time_s_from_utc_time_no_date_str(date_utc_str)","title":"<code>date_utc_str</code>","text":""},{"location":"api/utils/#hermes.utils.time_utils.get_time_s_from_utc_time_no_date_str(input_date_format)","title":"<code>input_date_format</code>","text":""},{"location":"api/utils/#hermes.utils.time_utils.get_time_str","title":"get_time_str","text":"<pre><code>get_time_str(time_s: float = get_time(), format: str = '%Y-%m-%d_%H-%M-%S') -&gt; str\n</code></pre> <p>Gets a date string from seconds since epoch.</p> <p>Parameters:</p> Name Type Description Default <code>float</code> <p>Time since epoch to convert to the human-readable string. Defaults to the current system time.</p> <code>get_time()</code> <code>str</code> <p>Format to construct the date string. Default to <code>%Y-%m-%d_%H-%M-%S</code>.</p> <code>'%Y-%m-%d_%H-%M-%S'</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Formatted date string corresponding to the provided time since epoch.</p>"},{"location":"api/utils/#hermes.utils.time_utils.get_time_str(time_s)","title":"<code>time_s</code>","text":""},{"location":"api/utils/#hermes.utils.time_utils.get_time_str(format)","title":"<code>format</code>","text":""},{"location":"api/utils/#hermes.utils.time_utils.init_time","title":"init_time","text":"<pre><code>init_time(ref_time: float) -&gt; None\n</code></pre> <p>Initialize the current process's <code>SystemTime</code> Singleton with a common reference time.</p> <p>Parameters:</p> Name Type Description Default <code>float</code> <p>Time obtained via <code>get_ref_time()</code> in the parent process to use as a reference for performance counters in the current process.</p> required"},{"location":"api/utils/#hermes.utils.time_utils.init_time(ref_time)","title":"<code>ref_time</code>","text":""},{"location":"api/utils/#hermes.utils.node_utils","title":"node_utils","text":"<p>Functions:</p> Name Description <code>launch_node</code> <p>Launches callable <code>Node</code> objects using the user-provided specification.</p> <code>search_node_class</code> <p>Queries the current Python environment to match the requested <code>hermes.&lt;module&gt;</code>.</p>"},{"location":"api/utils/#hermes.utils.node_utils.launch_node","title":"launch_node","text":"<pre><code>launch_node(spec: dict, input_queue: Queue[tuple[float, str]])\n</code></pre> <p>Launches callable <code>Node</code> objects using the user-provided specification.</p> <p>Parameters:</p> Name Type Description Default <code>dict</code> <p>Specification containing at least package and <code>Node</code> names, and constructor arguments specific to that <code>Node</code>.</p> required <code>Queue[tuple[float, str]]</code> <p>Multiprocessing queue to fan-in user keyboard inputs if the <code>Node</code> is interested to receive any.</p> required"},{"location":"api/utils/#hermes.utils.node_utils.launch_node(spec)","title":"<code>spec</code>","text":""},{"location":"api/utils/#hermes.utils.node_utils.launch_node(input_queue)","title":"<code>input_queue</code>","text":""},{"location":"api/utils/#hermes.utils.node_utils.search_node_class","title":"search_node_class","text":"<pre><code>search_node_class(module_name: str, class_name: str) -&gt; type[NodeInterface]\n</code></pre> <p>Queries the current Python environment to match the requested <code>hermes.&lt;module&gt;</code>.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>Name of the Python module containing the requested HERMES type <code>Node</code>.</p> required <code>str</code> <p>Name of the <code>Node</code> in the provided module to retrieve for construction.</p> required"},{"location":"api/utils/#hermes.utils.node_utils.search_node_class(module_name)","title":"<code>module_name</code>","text":""},{"location":"api/utils/#hermes.utils.node_utils.search_node_class(class_name)","title":"<code>class_name</code>","text":""},{"location":"api/utils/#hermes.utils.mp_utils","title":"mp_utils","text":"<p>Functions:</p> Name Description <code>launch_broker</code> <p>Builds the <code>Broker</code> using provided configurations and manage all the components of the experiment.</p> <code>launch_callable</code> <p>Launches a callable object with the user-provided inputs.</p>"},{"location":"api/utils/#hermes.utils.mp_utils.launch_broker","title":"launch_broker","text":"<pre><code>launch_broker(\n    args: Namespace,\n    node_specs: list[dict],\n    input_queue: Queue[tuple[float, str]],\n    is_ready_event: Event,\n    is_quit_event: Event,\n    is_done_event: Event,\n    ref_time_s: float,\n) -&gt; None\n</code></pre> <p>Builds the <code>Broker</code> using provided configurations and manage all the components of the experiment.</p> <p>Meant to be used as a target for a spawned Process or Thread.</p> <p>Parameters:</p> Name Type Description Default <code>Namespace</code> <p>HERMES top-level user input arguments for the experiment definition.</p> required <code>list[dict]</code> <p>Configuration dictionaries of the Broker's locally managed <code>Node</code>s.</p> required <code>Queue[tuple[float, str]]</code> <p>Multiprocessing queue to fan-out user keyboard inputs to all <code>Broker</code>s locally managed <code>Node</code>s.</p> required <code>Event</code> <p>Multiprocessing synchronization primitive indicating completion of <code>Broker</code>s setup and handshaking with <code>Node</code>s.</p> required <code>Event</code> <p>Multiprocessing synchronization primitive triggering to the <code>Broker</code> to gracefully wrap up and end.</p> required <code>Event</code> <p>Multiprocessing synchronization primitive indicating that the <code>Broker</code> is finished and experiment ended.</p> required <code>float</code> <p>Main process reference system time obtained with <code>get_ref_time()</code> to use in all child processes for syncing the data.</p> required"},{"location":"api/utils/#hermes.utils.mp_utils.launch_broker(args)","title":"<code>args</code>","text":""},{"location":"api/utils/#hermes.utils.mp_utils.launch_broker(node_specs)","title":"<code>node_specs</code>","text":""},{"location":"api/utils/#hermes.utils.mp_utils.launch_broker(input_queue)","title":"<code>input_queue</code>","text":""},{"location":"api/utils/#hermes.utils.mp_utils.launch_broker(is_ready_event)","title":"<code>is_ready_event</code>","text":""},{"location":"api/utils/#hermes.utils.mp_utils.launch_broker(is_quit_event)","title":"<code>is_quit_event</code>","text":""},{"location":"api/utils/#hermes.utils.mp_utils.launch_broker(is_done_event)","title":"<code>is_done_event</code>","text":""},{"location":"api/utils/#hermes.utils.mp_utils.launch_broker(ref_time_s)","title":"<code>ref_time_s</code>","text":""},{"location":"api/utils/#hermes.utils.mp_utils.launch_callable","title":"launch_callable","text":"<pre><code>launch_callable(obj: Callable, *args, **kwargs) -&gt; None\n</code></pre> <p>Launches a callable object with the user-provided inputs.</p> <p>Parameters:</p> Name Type Description Default <code>list</code> <p>Ordered unnamed inputs to provide to the callable object.</p> <code>()</code> <code>dict</code> <p>Named key-value inputs to provide to the callable object.</p> <code>{}</code>"},{"location":"api/utils/#hermes.utils.mp_utils.launch_callable(args)","title":"<code>args</code>","text":""},{"location":"api/utils/#hermes.utils.mp_utils.launch_callable(kwargs)","title":"<code>kwargs</code>","text":""},{"location":"api/utils/#hermes.utils.msgpack_utils","title":"msgpack_utils","text":"<p>Functions:</p> Name Description <code>convert_bytes_keys_to_strings</code> <p>Recursively decodes keys of the key-value mappings into strings.</p> <code>decode_ndarray</code> <p>Decodes received bytes and reconstructs detected NumPy arrays into original objects.</p> <code>deserialize</code> <p>Deserializes the received message to construct the original Python object.</p> <code>encode_ndarray</code> <p>Encodes NumPy contents of the provided object into bytes.</p> <code>serialize</code> <p>Serializes a Python dict-like object for ZeroMQ transmission.</p>"},{"location":"api/utils/#hermes.utils.msgpack_utils.convert_bytes_keys_to_strings","title":"convert_bytes_keys_to_strings","text":"<pre><code>convert_bytes_keys_to_strings(obj: object) -&gt; object\n</code></pre> <p>Recursively decodes keys of the key-value mappings into strings.</p> <p>Parameters:</p> Name Type Description Default <code>object</code> <p>Object whose keys to decode.</p> required <p>Returns:</p> Name Type Description <code>object</code> <code>object</code> <p>Processed object with keys converted into proper dictionary string fields.</p>"},{"location":"api/utils/#hermes.utils.msgpack_utils.convert_bytes_keys_to_strings(obj)","title":"<code>obj</code>","text":""},{"location":"api/utils/#hermes.utils.msgpack_utils.decode_ndarray","title":"decode_ndarray","text":"<pre><code>decode_ndarray(obj: object) -&gt; object\n</code></pre> <p>Decodes received bytes and reconstructs detected NumPy arrays into original objects.</p> <p>Parameters:</p> Name Type Description Default <code>object</code> <p>Raw bytes to convert into NumPy arrays if any detected.</p> required <p>Returns:</p> Name Type Description <code>object</code> <code>object</code> <p>Decoded key-value mapping with NumPy arrays reconstructed.</p>"},{"location":"api/utils/#hermes.utils.msgpack_utils.decode_ndarray(obj)","title":"<code>obj</code>","text":""},{"location":"api/utils/#hermes.utils.msgpack_utils.deserialize","title":"deserialize","text":"<pre><code>deserialize(msg: bytes) -&gt; dict\n</code></pre> <p>Deserializes the received message to construct the original Python object.</p> <p>Parameters:</p> Name Type Description Default <code>bytes</code> <p>Raw binary data containing the original Python object.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Python object with the key-value pairs preserved and any NumPy arrays reconstructed.</p>"},{"location":"api/utils/#hermes.utils.msgpack_utils.deserialize(msg)","title":"<code>msg</code>","text":""},{"location":"api/utils/#hermes.utils.msgpack_utils.encode_ndarray","title":"encode_ndarray","text":"<pre><code>encode_ndarray(obj: object) -&gt; object\n</code></pre> <p>Encodes NumPy contents of the provided object into bytes.</p> <p>Parameters:</p> Name Type Description Default <code>object</code> <p>NumPy array to encode as serializeable key-value pair.</p> required <p>Returns:</p> Name Type Description <code>object</code> <code>object</code> <p>Encoded key-value mapping with NumPy arrays serialized to bytes.</p>"},{"location":"api/utils/#hermes.utils.msgpack_utils.encode_ndarray(obj)","title":"<code>obj</code>","text":""},{"location":"api/utils/#hermes.utils.msgpack_utils.serialize","title":"serialize","text":"<pre><code>serialize(**kwargs) -&gt; bytes\n</code></pre> <p>Serializes a Python dict-like object for ZeroMQ transmission.</p> <p>Preserves named arguments as key-value pairs.</p> <p>Parameters:</p> Name Type Description Default <code>dict</code> <p>Inputs to serialize using a custom encoding hook for NumPy arrays.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>bytes</code> <code>bytes</code> <p>Serialized binary data safe to transmit.</p>"},{"location":"api/utils/#hermes.utils.msgpack_utils.serialize(kwargs)","title":"<code>kwargs</code>","text":""},{"location":"api/utils/#hermes.utils.argparse_utils","title":"argparse_utils","text":"<p>Classes:</p> Name Description <code>ParseExperimentKwargs</code> <p>Parsing object for experiment details specification.</p> <code>ParseNodeKwargs</code> <p>Parsing object for <code>Node</code> specifications.</p> <code>ParseStorageKwargs</code> <p>Parsing object for <code>Storage</code> specification.</p> <p>Functions:</p> Name Description <code>parse_type</code> <p>Parsing utility to convert data types to native Python objects.</p> <code>validate_ip4</code> <p>Validates whether parsed value is a valid IPv4 address.</p> <code>validate_path</code> <p>Validates whether parsed file path exists.</p>"},{"location":"api/utils/#hermes.utils.argparse_utils.ParseExperimentKwargs","title":"ParseExperimentKwargs","text":"<p>               Bases: <code>Action</code></p> <pre><code>\n              flowchart TD\n              hermes.utils.argparse_utils.ParseExperimentKwargs[ParseExperimentKwargs]\n\n              \n\n              click hermes.utils.argparse_utils.ParseExperimentKwargs href \"\" \"hermes.utils.argparse_utils.ParseExperimentKwargs\"\n            </code></pre> <p>Parsing object for experiment details specification.</p>"},{"location":"api/utils/#hermes.utils.argparse_utils.ParseNodeKwargs","title":"ParseNodeKwargs","text":"<p>               Bases: <code>Action</code></p> <pre><code>\n              flowchart TD\n              hermes.utils.argparse_utils.ParseNodeKwargs[ParseNodeKwargs]\n\n              \n\n              click hermes.utils.argparse_utils.ParseNodeKwargs href \"\" \"hermes.utils.argparse_utils.ParseNodeKwargs\"\n            </code></pre> <p>Parsing object for <code>Node</code> specifications.</p>"},{"location":"api/utils/#hermes.utils.argparse_utils.ParseStorageKwargs","title":"ParseStorageKwargs","text":"<p>               Bases: <code>Action</code></p> <pre><code>\n              flowchart TD\n              hermes.utils.argparse_utils.ParseStorageKwargs[ParseStorageKwargs]\n\n              \n\n              click hermes.utils.argparse_utils.ParseStorageKwargs href \"\" \"hermes.utils.argparse_utils.ParseStorageKwargs\"\n            </code></pre> <p>Parsing object for <code>Storage</code> specification.</p>"},{"location":"api/utils/#hermes.utils.argparse_utils.parse_type","title":"parse_type","text":"<pre><code>parse_type(s: str) -&gt; int | float | bool | str\n</code></pre> <p>Parsing utility to convert data types to native Python objects.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>Text to convert to the corresponding data type.</p> required <p>Returns:</p> Type Description <code>int | float | bool | str</code> <p>int | float | bool | str: Parsed primitive data type.</p>"},{"location":"api/utils/#hermes.utils.argparse_utils.parse_type(s)","title":"<code>s</code>","text":""},{"location":"api/utils/#hermes.utils.argparse_utils.validate_ip4","title":"validate_ip4","text":"<pre><code>validate_ip4(s: str) -&gt; str\n</code></pre> <p>Validates whether parsed value is a valid IPv4 address.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>Parsed text value to test for validity as IPv4 address.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Unchanged text value to use as IP address.</p> <p>Raises:</p> Type Description <code>ArgumentTypeError</code> <p>If the parsed value is not a valid IPv4 address.</p>"},{"location":"api/utils/#hermes.utils.argparse_utils.validate_ip4(s)","title":"<code>s</code>","text":""},{"location":"api/utils/#hermes.utils.argparse_utils.validate_path","title":"validate_path","text":"<pre><code>validate_path(s: str) -&gt; str\n</code></pre> <p>Validates whether parsed file path exists.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>File path to parse.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Unchanged path if it exists.</p> <p>Raises:</p> Type Description <code>ArgumentTypeError</code> <p>If the provided path does not exist.</p>"},{"location":"api/utils/#hermes.utils.argparse_utils.validate_path(s)","title":"<code>s</code>","text":""},{"location":"api/utils/#hermes.utils.sensor_utils","title":"sensor_utils","text":"<p>Functions:</p> Name Description <code>estimate_transmission_delay</code> <p>Estimates the mean transmission delay of the provided \"ping\" function.</p>"},{"location":"api/utils/#hermes.utils.sensor_utils.estimate_transmission_delay","title":"estimate_transmission_delay","text":"<pre><code>estimate_transmission_delay(ping_fn: Callable, num_samples: int = 100) -&gt; float\n</code></pre> <p>Estimates the mean transmission delay of the provided \"ping\" function.</p> <p>Used with the custom provided <code>ping_fn</code> to measure the one-way delay to use for offsetting sensor data streams from the <code>toa_s</code> to obtain true sample time.</p> <p>Parameters:</p> Name Type Description Default <code>Callable</code> <p>User's function that wraps \"ping\" like functionality to the specific device.</p> required <code>int</code> <p>Number of round-trip transmission to perform to average over. Defaults to <code>100</code>.</p> <code>100</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Estimated mean delay for samples from the device.</p>"},{"location":"api/utils/#hermes.utils.sensor_utils.estimate_transmission_delay(ping_fn)","title":"<code>ping_fn</code>","text":""},{"location":"api/utils/#hermes.utils.sensor_utils.estimate_transmission_delay(num_samples)","title":"<code>num_samples</code>","text":""},{"location":"api/utils/#hermes.utils.numpy_utils","title":"numpy_utils","text":""},{"location":"api/utils/#hermes.utils.dict_utils","title":"dict_utils","text":""},{"location":"api/utils/#hermes.utils.angle_utils","title":"angle_utils","text":""},{"location":"api/utils/#hermes.utils.print_utils","title":"print_utils","text":"<p>Classes:</p> Name Description <code>SystemTime</code> <p>Highly accurate system time Singleton that uses performance counters of the host device.</p> <p>Functions:</p> Name Description <code>get_ref_time</code> <p>Gets the current process's <code>SystemTime</code> Singleton reference time.</p> <code>get_time</code> <p>Gets the highly accurate current system time.</p> <code>get_time_s_from_local_str</code> <p>Gets seconds since epoch from provided local time string.</p> <code>get_time_s_from_utc_time_no_date_str</code> <p>Gets local time in seconds since epoch from provided UTC time strings.</p> <code>get_time_str</code> <p>Gets a date string from seconds since epoch.</p> <code>init_time</code> <p>Initialize the current process's <code>SystemTime</code> Singleton with a common reference time.</p>"},{"location":"api/utils/#hermes.utils.print_utils.SystemTime","title":"SystemTime","text":"<p>Highly accurate system time Singleton that uses performance counters of the host device.</p> <p>Performance counters of the host devices are not Unix float numbers since epoch, but a float starting from 0 on the boot-up of the device. This Singleton uses less accurate system time with the <code>time.time()</code> call and combines with the performance counters, to get highly accurate time of the host device.</p> <p>This Singleton's methods should not be called directly. Use the global methods instead.</p> <p>Each subprocess of the application must be initialized via <code>init_time(...)</code> with a reference time obtained in the parent process via <code>get_ref_time()</code>.</p>"},{"location":"api/utils/#hermes.utils.print_utils.get_ref_time","title":"get_ref_time","text":"<pre><code>get_ref_time() -&gt; float\n</code></pre> <p>Gets the current process's <code>SystemTime</code> Singleton reference time.</p>"},{"location":"api/utils/#hermes.utils.print_utils.get_time","title":"get_time","text":"<pre><code>get_time() -&gt; float\n</code></pre> <p>Gets the highly accurate current system time.</p>"},{"location":"api/utils/#hermes.utils.print_utils.get_time_s_from_local_str","title":"get_time_s_from_local_str","text":"<pre><code>get_time_s_from_local_str(\n    time_local_str: str,\n    input_time_format: str = \"%H:%M:%S.%f\",\n    date_local_str: str | None = None,\n    input_date_format: str = \"%Y-%m-%d\",\n) -&gt; float\n</code></pre> <p>Gets seconds since epoch from provided local time string.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>local time string to convert to seconds.</p> required <code>str</code> <p>Time string format of the provided time. Defaults to <code>%H:%M:%S.%f</code>.</p> <code>'%H:%M:%S.%f'</code> <code>str</code> <p>local date string to convert to seconds. Defaults to <code>None</code>.</p> <code>None</code> <code>str</code> <p>Date string format of the provided date. Defaults to <code>%Y-%m-%d</code>.</p> <code>'%Y-%m-%d'</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Seconds count since epoch, corresponding to the provided local time strings.</p>"},{"location":"api/utils/#hermes.utils.print_utils.get_time_s_from_local_str(time_local_str)","title":"<code>time_local_str</code>","text":""},{"location":"api/utils/#hermes.utils.print_utils.get_time_s_from_local_str(input_time_format)","title":"<code>input_time_format</code>","text":""},{"location":"api/utils/#hermes.utils.print_utils.get_time_s_from_local_str(date_local_str)","title":"<code>date_local_str</code>","text":""},{"location":"api/utils/#hermes.utils.print_utils.get_time_s_from_local_str(input_date_format)","title":"<code>input_date_format</code>","text":""},{"location":"api/utils/#hermes.utils.print_utils.get_time_s_from_utc_time_no_date_str","title":"get_time_s_from_utc_time_no_date_str","text":"<pre><code>get_time_s_from_utc_time_no_date_str(\n    time_utc_str: str,\n    input_time_format: str = \"%H:%M:%S.%f\",\n    date_utc_str: str | None = None,\n    input_date_format: str = \"%Y-%m-%d\",\n) -&gt; float\n</code></pre> <p>Gets local time in seconds since epoch from provided UTC time strings.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>UTC time string to convert to seconds.</p> required <code>str</code> <p>Time string format of the provided time. Defaults to <code>%H:%M:%S.%f</code>.</p> <code>'%H:%M:%S.%f'</code> <code>str</code> <p>UTC date to convert to seconds. Defaults to <code>None</code>.</p> <code>None</code> <code>str</code> <p>Date string format of the provided date. Defaults to <code>%Y-%m-%d</code>.</p> <code>'%Y-%m-%d'</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Seconds count since epoch, corresponding to the provided UTC time strings.</p>"},{"location":"api/utils/#hermes.utils.print_utils.get_time_s_from_utc_time_no_date_str(time_utc_str)","title":"<code>time_utc_str</code>","text":""},{"location":"api/utils/#hermes.utils.print_utils.get_time_s_from_utc_time_no_date_str(input_time_format)","title":"<code>input_time_format</code>","text":""},{"location":"api/utils/#hermes.utils.print_utils.get_time_s_from_utc_time_no_date_str(date_utc_str)","title":"<code>date_utc_str</code>","text":""},{"location":"api/utils/#hermes.utils.print_utils.get_time_s_from_utc_time_no_date_str(input_date_format)","title":"<code>input_date_format</code>","text":""},{"location":"api/utils/#hermes.utils.print_utils.get_time_str","title":"get_time_str","text":"<pre><code>get_time_str(time_s: float = get_time(), format: str = '%Y-%m-%d_%H-%M-%S') -&gt; str\n</code></pre> <p>Gets a date string from seconds since epoch.</p> <p>Parameters:</p> Name Type Description Default <code>float</code> <p>Time since epoch to convert to the human-readable string. Defaults to the current system time.</p> <code>get_time()</code> <code>str</code> <p>Format to construct the date string. Default to <code>%Y-%m-%d_%H-%M-%S</code>.</p> <code>'%Y-%m-%d_%H-%M-%S'</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Formatted date string corresponding to the provided time since epoch.</p>"},{"location":"api/utils/#hermes.utils.print_utils.get_time_str(time_s)","title":"<code>time_s</code>","text":""},{"location":"api/utils/#hermes.utils.print_utils.get_time_str(format)","title":"<code>format</code>","text":""},{"location":"api/utils/#hermes.utils.print_utils.init_time","title":"init_time","text":"<pre><code>init_time(ref_time: float) -&gt; None\n</code></pre> <p>Initialize the current process's <code>SystemTime</code> Singleton with a common reference time.</p> <p>Parameters:</p> Name Type Description Default <code>float</code> <p>Time obtained via <code>get_ref_time()</code> in the parent process to use as a reference for performance counters in the current process.</p> required"},{"location":"api/utils/#hermes.utils.print_utils.init_time(ref_time)","title":"<code>ref_time</code>","text":""},{"location":"api/utils/#hermes.utils.zmq_utils","title":"zmq_utils","text":""},{"location":"architecture/","title":"Architecture","text":"<p>TODO: showcase how HERMES is designed and what are its primary principles.</p>"},{"location":"firststeps/","title":"Getting started","text":""},{"location":"firststeps/#installation","title":"Installation","text":"<p>TODO: provide explanation on how to install the base and any optional supported packages.</p>"},{"location":"firststeps/#ssh-keys","title":"SSH keys","text":"<p>Generate and exchange public SSH keys across distributed hosts.</p>"},{"location":"firststeps/#extra-modules","title":"Extra modules","text":"<p>Install any of the desired supported modules for the sensors you intend to use.</p>"},{"location":"firststeps/#adding-custom-device","title":"Adding custom device","text":"<p>User creates the proper structure that Python recognizes as a namespace HERMES module.</p>"},{"location":"firststeps/#running","title":"Running","text":"<p>User specifies YAML configuration file (incl. custom Nodes) and launches the CLI. The CLI spins up stream processing on all the distributed hosts on the local network.</p>"},{"location":"firststeps/changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog.</p> <p>This project adheres to Semantic Versioning.</p>"},{"location":"firststeps/changelog/#hermes","title":"HERMES","text":""},{"location":"firststeps/changelog/#017-december-04-2025","title":"0.1.7 December 04, 2025","text":"<ul> <li>Bugfix: <code>Broker</code> doesn't fan-out stdin in multiprocessing -&gt; threading instead.</li> </ul>"},{"location":"firststeps/changelog/#016-december-02-2025","title":"0.1.6 December 02, 2025","text":"<ul> <li>Bugfix: <code>Broker</code> and <code>Storage</code> use stale reference clock.</li> </ul>"},{"location":"firststeps/changelog/#015-december-02-2025","title":"0.1.5 December 02, 2025","text":"<ul> <li>Replaced <code>keyboard</code> package with <code>input()</code> calls for rootless keyboard interaction.</li> </ul>"},{"location":"firststeps/changelog/#014-november-28-2025","title":"0.1.4 November 28, 2025","text":"<ul> <li>Propagates user keyboard inputs via <code>keyboard</code> package to all threads.</li> </ul>"},{"location":"firststeps/changelog/#013-november-25-2025","title":"0.1.3 November 25, 2025","text":"<ul> <li>Automatic parsing of Video codec from config file.</li> </ul>"},{"location":"firststeps/changelog/#012-november-21-2025","title":"0.1.2 November 21, 2025","text":"<ul> <li>Bugfix: divergent reference system start time.</li> </ul>"},{"location":"firststeps/changelog/#011-october-19-2025","title":"0.1.1 October 19, 2025","text":"<ul> <li>Patched namespace build.</li> <li>Added CLI with config-based setup.</li> </ul>"},{"location":"firststeps/changelog/#010-october-11-2025","title":"0.1.0 October 11, 2025","text":"<ul> <li>Initial publically available version of the framework.</li> </ul>"},{"location":"firststeps/contributing/","title":"Contributing","text":"<p>We want to make contributing to this project as easy and transparent as possible.</p>"},{"location":"firststeps/contributing/#pull-requests","title":"Pull Requests","text":"<p>We actively welcome your pull requests.</p> <ol> <li>Fork the repo and create your branch from <code>main</code>.</li> <li>If you've added code that should be tested, add tests.</li> <li>If you've changed APIs, update the documentation.</li> </ol>"},{"location":"firststeps/contributing/#issues","title":"Issues","text":"<p>We use GitHub issues to track public bugs. Please ensure your description is clear and has sufficient instructions to be able to reproduce the issue.</p>"},{"location":"firststeps/contributing/#license","title":"License","text":"<p>By contributing to HERMES, you agree that your contributions will be licensed under the LICENSE file in the root directory of this source tree.</p>"},{"location":"firststeps/license/","title":"License","text":""},{"location":"firststeps/license/#sourcecode-license","title":"Sourcecode license","text":"<p>The MIT License (MIT)</p> <p>Copyright (c) 2024-2025 Maxim Yudayev and KU Leuven eMedia Lab.</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"firststeps/license/#creative-artworks-license","title":"Creative artworks license","text":"<p>The creative artwork for HERMES is Copyright (c) 2025 Maxim Yudayev, all rights reserved.</p> <p>The logo is trademark (or service mark) of Maxim Yudayev and is licensed under the  Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License (CC BY-NC-ND 4.0).</p> <p>Use of this logo does not constitute an endorsement by Maxim Yudayev.</p> <p>Any commercial use, modification, or use in a manner that suggests endorsement or association  with the project's source or origin is strictly prohibited without a separate written agreement.</p>"},{"location":"firststeps/tutorials/","title":"Tutorials","text":"<p>TODO: introduction of the sample projects enabled by HERMES to inspire your usage.</p>"},{"location":"firststeps/tutorials/acquisition/","title":"Data acquisition","text":""},{"location":"firststeps/tutorials/ai-worker/","title":"Closed-loop AI worker","text":""},{"location":"firststeps/tutorials/annotation/","title":"Data annotation","text":""},{"location":"helpdesk/faq/","title":"FAQ","text":"<p>TODO: what is frequently missed by the user and how to resolve it.</p>"},{"location":"helpdesk/issues/","title":"Known issues","text":"<p>TODO: we are aware of these shortcomings and are fixing them.</p>"},{"location":"helpdesk/limitations/","title":"Current limitations","text":"<p>TODO: transparent acknowledgement of current limitations (either outside of scope, on the roadmap, or has room for improvement).</p>"},{"location":"helpdesk/roadmap/","title":"Development roadmap","text":"<p>TODO: items planned on our roadmap to enhance the functionality of the system.</p>"}]}